#![feature(prelude_import)]
//! # rfgrep - High-Performance File Search Library
//!
//! A comprehensive Rust library for fast, memory-efficient file searching with advanced
//! filtering capabilities, parallel processing, and multiple search algorithms.
//!
//! ## Features
//!
//! - **Multiple Search Algorithms**: SIMD-optimized, Boyer-Moore, regex, and simple string matching
//! - **Parallel Processing**: Multi-threaded file processing with adaptive chunking
//! - **Memory Optimization**: Memory-mapped I/O, zero-copy string processing, and intelligent caching
//! - **Plugin System**: Extensible architecture with dynamic plugin loading
//! - **Interactive TUI**: Real-time search interface with live pattern editing
//! - **Streaming Search**: Handles files larger than available memory
//! - **File Type Classification**: Smart handling of 153+ file formats
//! - **Performance Monitoring**: Built-in metrics and benchmarking tools
//!
//! ## Quick Start
//!
//! ```rust
//! use rfgrep::{app_simple::RfgrepApp, Cli, Commands, SearchMode};
//! use clap::Parser;
//!
//! #[tokio::main]
//! async fn main() -> rfgrep::Result<()> {
//!     // In a real application, you would parse from command line
//!     let cli = Cli::try_parse_from(&["rfgrep", ".", "search", "pattern"]).unwrap();
//!     let app = RfgrepApp::new_async().await?;
//!     app.run(cli).await?;
//!     Ok(())
//! }
//! ```
//!
//! ## Search Algorithms
//!
//! ```rust
//! use rfgrep::search_algorithms::{SearchAlgorithm, SearchAlgorithmFactory};
//!
//! // Create a search algorithm
//! let algorithm = SearchAlgorithmFactory::create(SearchAlgorithm::BoyerMoore, "pattern");
//!
//! // Search in text
//! let matches = algorithm.search("Hello, world!", "world");
//! ```
//!
//! ## Performance Features
//!
//! - **SIMD Acceleration**: Hardware-optimized string matching
//! - **Memory Pooling**: Reuses expensive resources (mmap, compiled regex)
//! - **Adaptive Strategies**: Chooses optimal algorithm based on context
//! - **Zero-Copy Operations**: Minimizes memory allocations
//! - **Intelligent Caching**: LRU with TTL and invalidation
//!
//! ## Examples
//!
//! See the `examples/` directory for comprehensive usage examples:
//! - `real_world_demo.rs` - Real-world performance demonstration
//! - `performance_benchmark_demo.rs` - Benchmarking suite
//!
//! ## Thread Safety
//!
//! All public APIs are designed to be thread-safe and can be used in concurrent
//! environments. The library uses `Arc` and atomic operations for shared state.
//!
//! ## Performance Characteristics
//!
//! | Algorithm | Best Case | Average Case | Worst Case | Memory |
//! |-----------|-----------|--------------|------------|--------|
//! | SIMD Search | O(n) | O(n) | O(n) | O(1) |
//! | Boyer-Moore | O(n/m) | O(n/m) | O(n) | O(m) |
//! | Regex | O(n) | O(n) | O(nÂ²) | O(m) |
//! | Zero-Copy | O(n) | O(n) | O(n) | O(1) |
//!
//! Where: n = text length, m = pattern length
#![allow(clippy::uninlined_format_args)]
#![allow(dead_code)]
#![allow(clippy::op_ref)]
#![allow(clippy::needless_range_loop)]
#![allow(clippy::collapsible_if)]
#![allow(clippy::borrowed_box)]
#![allow(clippy::unnecessary_map_or)]
#![allow(clippy::new_without_default)]
#![allow(unused_assignments)]
#![allow(clippy::redundant_closure)]
#![allow(clippy::needless_borrows_for_generic_args)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::print_literal)]
extern crate std;
#[prelude_import]
use std::prelude::rust_2021::*;
/// Simplified application architecture with async runtime support
pub mod app_simple {
    //! Simplified application structure
    use crate::app::{
        stdin::StdinSearchOptions, FileFilter, FileFilterOptions, StdinSearcher,
    };
    use crate::cli::{
        Cli, Commands, PluginCommands, SearchAlgorithm as CliSearchAlgorithm, SearchMode,
    };
    use crate::error::{Result as RfgrepResult, RfgrepError};
    use crate::output_formats::OutputFormatter;
    use crate::plugin_cli::PluginCli;
    use crate::plugin_system::{EnhancedPluginManager, PluginRegistry};
    use crate::processor::search_file;
    use crate::search_algorithms::SearchAlgorithm;
    use crate::streaming_search::{StreamingConfig, StreamingSearchPipeline};
    use crate::tui::{init_terminal, restore_terminal, TuiApp};
    use crate::walker::walk_dir;
    use colored::Colorize;
    use std::path::Path;
    use std::sync::Arc;
    /// Simplified application that uses existing components
    pub struct RfgrepApp {
        plugin_manager: Arc<EnhancedPluginManager>,
    }
    impl RfgrepApp {
        /// Create a new application instance
        pub fn new() -> RfgrepResult<Self> {
            let plugin_manager = Arc::new(EnhancedPluginManager::new());
            let registry = PluginRegistry::new(plugin_manager.clone());
            let rt = match tokio::runtime::Handle::try_current() {
                Ok(handle) => {
                    handle.block_on(async { registry.load_plugins().await })?;
                    return Ok(Self { plugin_manager });
                }
                Err(_) => {
                    tokio::runtime::Runtime::new()
                        .map_err(|e| {
                            crate::error::RfgrepError::Other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Failed to create runtime: {0}", e),
                                    )
                                }),
                            )
                        })?
                }
            };
            rt.block_on(async { registry.load_plugins().await })?;
            Ok(Self { plugin_manager })
        }
        /// Create a new application instance with async support
        pub async fn new_async() -> RfgrepResult<Self> {
            let plugin_manager = Arc::new(EnhancedPluginManager::new());
            let registry = PluginRegistry::new(plugin_manager.clone());
            registry.load_plugins().await?;
            Ok(Self { plugin_manager })
        }
        /// Run the application with the given CLI arguments
        pub async fn run(&self, cli: Cli) -> RfgrepResult<()> {
            if let Some(log_path) = &cli.log {
                std::fs::write(log_path, "rfgrep log file created\n")
                    .map_err(RfgrepError::Io)?;
            }
            let is_piped = !is_terminal::is_terminal(&std::io::stdout());
            let quiet = cli.quiet || is_piped;
            match &cli.command {
                Commands::Search {
                    pattern,
                    mode,
                    algorithm,
                    recursive,
                    context_lines,
                    case_sensitive,
                    invert_match,
                    max_matches,
                    timeout_per_file,
                    path: cmd_path,
                    path_flag: cmd_path_flag,
                    output_format,
                    file_types,
                    include_extensions,
                    exclude_extensions,
                    search_all_files,
                    text_only,
                    ndjson,
                    count,
                    files_with_matches,
                    ..
                } => {
                    self.handle_search(
                            pattern,
                            mode.clone(),
                            algorithm.clone(),
                            *recursive,
                            *context_lines,
                            *case_sensitive,
                            *invert_match,
                            *max_matches,
                            *timeout_per_file,
                            cmd_path
                                .as_ref()
                                .or(cmd_path_flag.as_ref())
                                .map(|p| p.as_path())
                                .unwrap_or(&cli.path),
                            cli.max_size,
                            cli.skip_binary,
                            output_format.clone(),
                            file_types.clone(),
                            include_extensions.clone(),
                            exclude_extensions.clone(),
                            *search_all_files,
                            *text_only,
                            cli.safety_policy.clone(),
                            cli.threads,
                            *ndjson,
                            *count,
                            *files_with_matches,
                            quiet,
                        )
                        .await
                }
                Commands::List {
                    extensions,
                    long,
                    recursive,
                    show_hidden,
                    max_size,
                    min_size,
                    detailed,
                    simple,
                    stats,
                    sort,
                    reverse,
                    limit,
                    copy,
                    output_format,
                    path: cmd_path,
                    path_flag: cmd_path_flag,
                } => {
                    self.handle_list(
                            extensions.as_deref(),
                            *long,
                            *recursive,
                            *show_hidden,
                            *max_size,
                            *min_size,
                            *detailed,
                            *simple,
                            *stats,
                            sort.clone(),
                            *reverse,
                            *limit,
                            *copy,
                            output_format.clone(),
                            cmd_path.as_ref().map(|p| p.as_path()),
                            cmd_path_flag.as_ref().map(|p| p.as_path()),
                            &cli.path,
                        )
                        .await
                }
                Commands::Interactive { .. } => {
                    {
                        ::std::io::_print(
                            format_args!(
                                "Interactive command not yet implemented in simplified version\n",
                            ),
                        );
                    };
                    Ok(())
                }
                Commands::Completions { shell } => self.handle_completions(*shell),
                Commands::Simulate {} => {
                    use std::fs;
                    use std::time::Instant;
                    let results_dir = cli.path.join("results");
                    if let Err(e) = fs::create_dir_all(&results_dir) {
                        return Err(RfgrepError::Io(e));
                    }
                    let search_root = cli.path.join("bench_data");
                    let search_root = if search_root.exists() {
                        search_root
                    } else {
                        cli.path.clone()
                    };
                    let entries: Vec<_> = crate::walker::walk_dir(
                            &search_root,
                            true,
                            true,
                        )
                        .collect();
                    let files: Vec<_> = entries
                        .into_iter()
                        .filter(|e| e.path().is_file())
                        .map(|e| e.path().to_path_buf())
                        .collect();
                    if files.is_empty() {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "Warning: No files found in search directory: {0}\n",
                                    search_root.display(),
                                ),
                            );
                        };
                        {
                            ::std::io::_print(
                                format_args!(
                                    "Creating a small test file for simulation...\n",
                                ),
                            );
                        };
                        let test_file = search_root.join("test_simulation.txt");
                        let test_content = "This is a test file for simulation.\nIt contains some error messages.\nTODO: Add more test cases.\nThe quick brown fox jumps over the lazy dog.\n";
                        fs::write(&test_file, test_content).map_err(RfgrepError::Io)?;
                        let entries: Vec<_> = crate::walker::walk_dir(
                                &search_root,
                                true,
                                true,
                            )
                            .collect();
                        let files: Vec<_> = entries
                            .into_iter()
                            .filter(|e| e.path().is_file())
                            .map(|e| e.path().to_path_buf())
                            .collect();
                        if files.is_empty() {
                            return Err(
                                RfgrepError::Other(
                                    "No files available for simulation".to_string(),
                                ),
                            );
                        }
                    }
                    {
                        ::std::io::_print(
                            format_args!(
                                "Running simulations on {0} files in {1}\n",
                                files.len(),
                                search_root.display(),
                            ),
                        );
                    };
                    let scenarios = <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            ("regex_short", r"error".to_string()),
                            ("word_boundary", r"\bTODO\b".to_string()),
                            (
                                "literal_long",
                                "the quick brown fox jumps over".to_string(),
                            ),
                        ]),
                    );
                    let mut report = String::from("Scenario,Millis,Matches,Files\n");
                    for (name, pat) in scenarios {
                        let start = Instant::now();
                        let mut total = 0usize;
                        let mut files_processed = 0usize;
                        let regex = crate::processor::get_or_compile_regex(&pat)?;
                        for f in &files {
                            if let Ok(matches) = crate::processor::search_file(
                                f,
                                &regex,
                            ) {
                                total += matches.len();
                                files_processed += 1;
                            }
                        }
                        let elapsed = start.elapsed().as_millis();
                        report
                            .push_str(
                                &::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0},{1},{2},{3}\n",
                                            name,
                                            elapsed,
                                            total,
                                            files_processed,
                                        ),
                                    )
                                }),
                            );
                    }
                    let report_path = results_dir.join("simulations.csv");
                    fs::write(&report_path, &report).map_err(RfgrepError::Io)?;
                    {
                        ::std::io::_print(
                            format_args!(
                                "Simulations complete. Report: {0}\n",
                                report_path.display(),
                            ),
                        );
                    };
                    {
                        ::std::io::_print(format_args!("\n{0}\n", report));
                    };
                    Ok(())
                }
                Commands::Worker { path, pattern } => {
                    self.handle_worker(path, pattern).await
                }
                Commands::Plugins { command } => {
                    self.handle_plugin_command(command).await
                }
                Commands::Tui {
                    pattern,
                    algorithm,
                    case_sensitive,
                    mode,
                    context_lines,
                    path,
                } => {
                    self.handle_tui_command(
                            pattern.as_deref(),
                            algorithm,
                            *case_sensitive,
                            mode,
                            *context_lines,
                            path,
                        )
                        .await
                }
            }
        }
        async fn handle_search(
            &self,
            pattern: &str,
            mode: crate::cli::SearchMode,
            algorithm: CliSearchAlgorithm,
            recursive: bool,
            context_lines: usize,
            case_sensitive: bool,
            invert_match: bool,
            max_matches: Option<usize>,
            timeout_per_file: Option<u64>,
            search_path: &Path,
            max_size: Option<usize>,
            _skip_binary: bool,
            output_format: crate::cli::OutputFormat,
            file_types: crate::cli::FileTypeStrategy,
            include_extensions: Option<Vec<String>>,
            exclude_extensions: Option<Vec<String>>,
            search_all_files: bool,
            text_only: bool,
            safety_policy: crate::cli::SafetyPolicy,
            threads: Option<usize>,
            ndjson: bool,
            count: bool,
            files_with_matches: bool,
            quiet: bool,
        ) -> RfgrepResult<()> {
            let search_pattern = self.build_search_pattern(pattern, mode);
            let search_algorithm = self.map_search_algorithm(algorithm);
            let stdin_is_piped = !is_terminal::is_terminal(&std::io::stdin());
            let search_path_str = search_path.to_string_lossy();
            let is_default_path = search_path_str == "." || search_path_str.is_empty();
            if stdin_is_piped && is_default_path {
                let stdin_searcher = StdinSearcher::new();
                let options = StdinSearchOptions {
                    search_pattern,
                    original_pattern: pattern.to_string(),
                    case_sensitive,
                    invert_match,
                    max_matches,
                    output_format,
                    ndjson,
                    count,
                    files_with_matches,
                    quiet,
                };
                return stdin_searcher.search(options).await;
            }
            let files = self.collect_files(search_path, recursive);
            let filter_options = FileFilterOptions {
                max_size,
                skip_binary: _skip_binary,
                safety_policy,
                include_extensions,
                exclude_extensions,
                search_all_files,
                text_only,
                file_types,
            };
            let file_filter = FileFilter::new(filter_options);
            let filtered_files = file_filter.filter_files(files);
            if !quiet && output_format != crate::cli::OutputFormat::Json && !ndjson {
                {
                    ::std::io::_print(
                        format_args!("Searching {0} files...\n", filtered_files.len()),
                    );
                };
            }
            let all_matches = self
                .perform_search(
                    &filtered_files,
                    &search_pattern,
                    search_algorithm,
                    context_lines,
                    case_sensitive,
                    invert_match,
                    max_matches,
                    timeout_per_file,
                    threads,
                    files_with_matches,
                    count,
                )
                .await?;
            self.output_results(
                &all_matches,
                pattern,
                search_path,
                output_format,
                ndjson,
                count,
                files_with_matches,
                quiet,
            )
        }
        /// Build search pattern based on mode
        fn build_search_pattern(
            &self,
            pattern: &str,
            mode: crate::cli::SearchMode,
        ) -> String {
            match mode {
                crate::cli::SearchMode::Text => pattern.to_string(),
                crate::cli::SearchMode::Word => {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("\\b{0}\\b", regex::escape(pattern)),
                        )
                    })
                }
                crate::cli::SearchMode::Regex => pattern.to_string(),
            }
        }
        /// Map CLI search algorithm to internal algorithm
        fn map_search_algorithm(
            &self,
            algorithm: CliSearchAlgorithm,
        ) -> SearchAlgorithm {
            match algorithm {
                CliSearchAlgorithm::BoyerMoore => SearchAlgorithm::BoyerMoore,
                CliSearchAlgorithm::Regex => SearchAlgorithm::Regex,
                CliSearchAlgorithm::Simple => SearchAlgorithm::Simple,
            }
        }
        /// Collect files from directory
        fn collect_files(
            &self,
            search_path: &Path,
            recursive: bool,
        ) -> Vec<std::path::PathBuf> {
            let entries: Vec<_> = walk_dir(search_path, recursive, true).collect();
            entries
                .into_iter()
                .filter(|entry| entry.path().is_file())
                .map(|entry| entry.path().to_path_buf())
                .collect()
        }
        /// Perform the actual search
        async fn perform_search(
            &self,
            filtered_files: &[std::path::PathBuf],
            search_pattern: &str,
            search_algorithm: SearchAlgorithm,
            context_lines: usize,
            case_sensitive: bool,
            invert_match: bool,
            max_matches: Option<usize>,
            timeout_per_file: Option<u64>,
            threads: Option<usize>,
            files_with_matches: bool,
            count: bool,
        ) -> RfgrepResult<Vec<crate::processor::SearchMatch>> {
            let config = StreamingConfig {
                algorithm: search_algorithm,
                context_lines,
                case_sensitive,
                invert_match,
                max_matches,
                timeout_per_file,
                chunk_size: 8192,
                buffer_size: 65536,
            };
            let thread_count = threads.unwrap_or_else(|| num_cpus::get().min(8));
            let pipeline = StreamingSearchPipeline::new(config);
            let file_refs: Vec<&Path> = filtered_files
                .iter()
                .map(|p| p.as_path())
                .collect();
            let parallel_threshold = if files_with_matches {
                5
            } else if count {
                7
            } else {
                10
            };
            if files_with_matches {
                use rayon::prelude::*;
                let matches: Vec<crate::processor::SearchMatch> = file_refs
                    .par_iter()
                    .filter_map(|file| {
                        let found = futures::executor::block_on(
                            pipeline.search_file_fast_exit(file, search_pattern),
                        );
                        match found {
                            Ok(true) => {
                                Some(crate::processor::SearchMatch {
                                    path: file.to_path_buf(),
                                    ..Default::default()
                                })
                            }
                            _ => None,
                        }
                    })
                    .collect();
                Ok(matches)
            } else if file_refs.len() > parallel_threshold {
                pipeline
                    .search_files_parallel(&file_refs, search_pattern, thread_count)
                    .await
            } else {
                let mut all_matches = Vec::new();
                for file in filtered_files {
                    match pipeline.search_file(file, search_pattern).await {
                        Ok(matches) => all_matches.extend(matches),
                        Err(e) => {
                            {
                                ::std::io::_eprint(
                                    format_args!(
                                        "Error searching {0}: {1}\n",
                                        file.display(),
                                        e,
                                    ),
                                );
                            };
                        }
                    }
                }
                Ok(all_matches)
            }
        }
        /// Output the search results
        fn output_results(
            &self,
            all_matches: &[crate::processor::SearchMatch],
            pattern: &str,
            search_path: &Path,
            output_format: crate::cli::OutputFormat,
            ndjson: bool,
            count: bool,
            files_with_matches: bool,
            quiet: bool,
        ) -> RfgrepResult<()> {
            if all_matches.is_empty() {
                self.output_no_matches(count, files_with_matches, output_format)
            } else if count {
                {
                    ::std::io::_print(format_args!("{0}\n", all_matches.len()));
                };
            } else if files_with_matches {} else {
                self.output_matches(
                    all_matches,
                    pattern,
                    search_path,
                    output_format,
                    ndjson,
                    quiet,
                )
            }
            Ok(())
        }
        /// Handle case when no matches are found
        fn output_no_matches(
            &self,
            count: bool,
            files_with_matches: bool,
            output_format: crate::cli::OutputFormat,
        ) {
            if count {
                {
                    ::std::io::_print(format_args!("0\n"));
                };
            } else if files_with_matches {} else if output_format
                != crate::cli::OutputFormat::Json
            {
                {
                    ::std::io::_print(
                        format_args!("{0}\n", "No matches found".yellow()),
                    );
                };
            }
        }
        /// Output list of files containing matches
        fn output_files_with_matches(
            &self,
            all_matches: &[crate::processor::SearchMatch],
        ) {
            use std::collections::HashSet;
            let mut unique_files: HashSet<String> = HashSet::new();
            for m in all_matches {
                unique_files.insert(m.path.to_string_lossy().to_string());
            }
            let mut files: Vec<_> = unique_files.into_iter().collect();
            files.sort();
        }
        /// Output the actual matches
        fn output_matches(
            &self,
            all_matches: &[crate::processor::SearchMatch],
            pattern: &str,
            search_path: &Path,
            output_format: crate::cli::OutputFormat,
            ndjson: bool,
            quiet: bool,
        ) {
            if !quiet && output_format != crate::cli::OutputFormat::Json && !ndjson {
                {
                    ::std::io::_print(
                        format_args!(
                            "\n{0} {1} {2}\n",
                            "Found".green(),
                            all_matches.len(),
                            "matches:".green(),
                        ),
                    );
                };
            }
            let formatter = OutputFormatter::new(
                    if ndjson {
                        crate::output_formats::OutputFormat::Json
                    } else {
                        match output_format {
                            crate::cli::OutputFormat::Text => {
                                crate::output_formats::OutputFormat::Text
                            }
                            crate::cli::OutputFormat::Json => {
                                crate::output_formats::OutputFormat::Json
                            }
                            crate::cli::OutputFormat::Xml => {
                                crate::output_formats::OutputFormat::Xml
                            }
                            crate::cli::OutputFormat::Html => {
                                crate::output_formats::OutputFormat::Html
                            }
                            crate::cli::OutputFormat::Markdown => {
                                crate::output_formats::OutputFormat::Markdown
                            }
                            crate::cli::OutputFormat::Csv => {
                                crate::output_formats::OutputFormat::Csv
                            }
                            crate::cli::OutputFormat::Tsv => {
                                crate::output_formats::OutputFormat::Tsv
                            }
                        }
                    },
                )
                .with_ndjson(ndjson);
            let output = formatter.format_results(all_matches, pattern, search_path);
            if output_format == crate::cli::OutputFormat::Json || ndjson {
                {
                    ::std::io::_print(format_args!("{0}", output));
                };
            } else {
                {
                    ::std::io::_print(format_args!("\n{0}\n", output));
                };
            }
        }
        fn handle_completions(&self, shell: clap_complete::Shell) -> RfgrepResult<()> {
            use clap::CommandFactory;
            let mut cmd = Cli::command();
            clap_complete::generate(shell, &mut cmd, "rfgrep", &mut std::io::stdout());
            Ok(())
        }
        async fn handle_worker(
            &self,
            path: &std::path::Path,
            pattern: &str,
        ) -> RfgrepResult<()> {
            if let Ok(s) = std::env::var("RFGREP_WORKER_SLEEP") {
                if let Ok(sec) = s.parse::<u64>() {
                    std::thread::sleep(std::time::Duration::from_secs(sec));
                }
            }
            let regex = crate::processor::get_or_compile_regex(pattern)?;
            let matches = search_file(path, &regex)?;
            for m in matches {
                if let Ok(json) = serde_json::to_string(&m) {
                    {
                        ::std::io::_print(format_args!("{0}\n", json));
                    };
                }
            }
            Ok(())
        }
        async fn handle_plugin_command(
            &self,
            command: &PluginCommands,
        ) -> RfgrepResult<()> {
            let plugin_cli = PluginCli::new(self.plugin_manager.clone());
            match command {
                PluginCommands::List => plugin_cli.list_plugins().await,
                PluginCommands::Stats => plugin_cli.show_stats().await,
                PluginCommands::Info { name } => plugin_cli.show_plugin_info(name).await,
                PluginCommands::Enable { name } => plugin_cli.enable_plugin(name).await,
                PluginCommands::Disable { name } => plugin_cli.disable_plugin(name).await,
                PluginCommands::Priority { name, priority } => {
                    plugin_cli.set_priority(name, *priority).await
                }
                PluginCommands::Config { name } => {
                    plugin_cli.show_config_options(name).await
                }
                PluginCommands::Test { name, file, pattern } => {
                    plugin_cli.test_plugin(name, file, pattern).await
                }
            }
        }
        async fn handle_tui_command(
            &self,
            pattern: Option<&str>,
            algorithm: &CliSearchAlgorithm,
            case_sensitive: bool,
            mode: &SearchMode,
            context_lines: usize,
            _path: &str,
        ) -> RfgrepResult<()> {
            let mut terminal = init_terminal()?;
            let mut app = TuiApp::new().await?;
            if let Some(p) = pattern {
                app.set_pattern(p.to_string());
            }
            let tui_algorithm = match algorithm {
                CliSearchAlgorithm::BoyerMoore => SearchAlgorithm::BoyerMoore,
                CliSearchAlgorithm::Regex => SearchAlgorithm::Regex,
                CliSearchAlgorithm::Simple => SearchAlgorithm::Simple,
            };
            let tui_mode = match mode {
                SearchMode::Text => crate::tui::SearchMode::Text,
                SearchMode::Word => crate::tui::SearchMode::Word,
                SearchMode::Regex => crate::tui::SearchMode::Regex,
            };
            app.state.algorithm = tui_algorithm;
            app.state.case_sensitive = case_sensitive;
            app.state.context_lines = context_lines;
            app.state.search_mode = tui_mode;
            if let Some(p) = pattern {
                app.state.status_message = ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("Searching for: {0}", p))
                });
                let mut all_matches = Vec::new();
                let search_root = std::path::PathBuf::from(_path);
                let search_root = if search_root.as_os_str().is_empty() {
                    std::path::PathBuf::from(".")
                } else {
                    search_root
                };
                let entries: Vec<_> = walk_dir(&search_root, true, false).collect();
                for entry in entries {
                    let path = entry.path();
                    if path.is_file() {
                        if let Ok(mut matches) = self
                            .plugin_manager
                            .search_file(path, p)
                            .await
                        {
                            all_matches.append(&mut matches);
                        }
                    }
                }
                app.set_matches(all_matches);
            }
            let result = app.run(&mut terminal).await;
            restore_terminal(&mut terminal)?;
            result
        }
        async fn handle_list(
            &self,
            extensions: Option<&[String]>,
            long: bool,
            recursive: bool,
            show_hidden: bool,
            max_size: Option<usize>,
            min_size: Option<usize>,
            _detailed: bool,
            simple: bool,
            stats: bool,
            sort: crate::cli::SortCriteria,
            reverse: bool,
            limit: Option<usize>,
            _copy: bool,
            _output_format: crate::cli::OutputFormat,
            cmd_path: Option<&Path>,
            cmd_path_flag: Option<&Path>,
            default_path: &Path,
        ) -> RfgrepResult<()> {
            let search_path = cmd_path_flag.or(cmd_path).unwrap_or(default_path);
            let entries: Vec<_> = walk_dir(search_path, recursive, show_hidden)
                .collect();
            let mut files: Vec<_> = entries
                .into_iter()
                .filter(|entry| entry.path().is_file())
                .map(|entry| entry.path().to_path_buf())
                .collect();
            files
                .retain(|path| {
                    if let Some(exts) = extensions {
                        if let Some(ext) = path.extension() {
                            if let Some(ext_str) = ext.to_str() {
                                if !exts.iter().any(|e| e.eq_ignore_ascii_case(ext_str)) {
                                    return false;
                                }
                            } else {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    }
                    if let Ok(metadata) = path.metadata() {
                        let size_mb = metadata.len() as f64 / (1024.0 * 1024.0);
                        if let Some(max) = max_size {
                            if size_mb > max as f64 {
                                return false;
                            }
                        }
                        if let Some(min) = min_size {
                            if size_mb < min as f64 {
                                return false;
                            }
                        }
                    }
                    true
                });
            match sort {
                crate::cli::SortCriteria::Name => {
                    files.sort_by(|a, b| a.file_name().cmp(&b.file_name()))
                }
                crate::cli::SortCriteria::Size => {
                    files
                        .sort_by(|a, b| {
                            let size_a = a.metadata().map(|m| m.len()).unwrap_or(0);
                            let size_b = b.metadata().map(|m| m.len()).unwrap_or(0);
                            size_a.cmp(&size_b)
                        });
                }
                crate::cli::SortCriteria::Date => {
                    files
                        .sort_by(|a, b| {
                            let time_a = a
                                .metadata()
                                .and_then(|m| m.modified())
                                .unwrap_or(std::time::UNIX_EPOCH);
                            let time_b = b
                                .metadata()
                                .and_then(|m| m.modified())
                                .unwrap_or(std::time::UNIX_EPOCH);
                            time_a.cmp(&time_b)
                        });
                }
                crate::cli::SortCriteria::Type => {
                    files
                        .sort_by(|a, b| {
                            let ext_a = a
                                .extension()
                                .and_then(|e| e.to_str())
                                .unwrap_or("");
                            let ext_b = b
                                .extension()
                                .and_then(|e| e.to_str())
                                .unwrap_or("");
                            ext_a.cmp(ext_b)
                        });
                }
                crate::cli::SortCriteria::Path => {
                    files.sort();
                }
            }
            if reverse {
                files.reverse();
            }
            if let Some(limit) = limit {
                files.truncate(limit);
            }
            if stats {
                {
                    ::std::io::_print(
                        format_args!("Summary: {0} files found\n", files.len()),
                    );
                };
            } else if simple {
                for file in &files {
                    {
                        ::std::io::_print(format_args!("{0}\n", file.display()));
                    };
                }
            } else {
                for file in &files {
                    if long {
                        if let Ok(metadata) = file.metadata() {
                            let size = metadata.len();
                            let modified = metadata
                                .modified()
                                .unwrap_or(std::time::UNIX_EPOCH);
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "{0} {1} {2}\n",
                                        size,
                                        modified
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_secs(),
                                        file.display(),
                                    ),
                                );
                            };
                        } else {
                            {
                                ::std::io::_print(format_args!("{0}\n", file.display()));
                            };
                        }
                    } else {
                        {
                            ::std::io::_print(format_args!("{0}\n", file.display()));
                        };
                    }
                }
                {
                    ::std::io::_print(
                        format_args!("Summary: {0} files found\n", files.len()),
                    );
                };
                if long {
                    let mut extensions: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
                    for file in &files {
                        if let Some(ext) = file.extension() {
                            if let Some(ext_str) = ext.to_str() {
                                *extensions.entry(ext_str.to_string()).or_insert(0) += 1;
                            }
                        }
                    }
                    if !extensions.is_empty() {
                        {
                            ::std::io::_print(format_args!("Extensions:\n"));
                        };
                        let mut ext_vec: Vec<_> = extensions.iter().collect();
                        ext_vec.sort_by(|a, b| a.0.cmp(b.0));
                        for (ext, count) in ext_vec {
                            {
                                ::std::io::_print(
                                    format_args!("  .{0}: {1} files\n", ext, count),
                                );
                            };
                        }
                    }
                }
            }
            Ok(())
        }
    }
    impl Default for RfgrepApp {
        fn default() -> Self {
            Self::new().expect("Failed to create RfgrepApp")
        }
    }
}
/// Application submodules (stdin, filters, handlers, etc.)
pub mod app {
    /// Application submodules for rfgrep
    ///
    /// This module contains the decomposed components of the main application,
    /// separated by responsibility for better maintainability and testability.
    pub mod filters {
        /// File filtering logic for rfgrep
        ///
        /// This module provides comprehensive file filtering capabilities including:
        /// - Extension-based filtering (include/exclude)
        /// - Size-based filtering
        /// - Safety policy enforcement
        /// - File type strategy application
        /// - Binary file detection
        use crate::cli::{FileTypeStrategy, SafetyPolicy};
        use crate::file_types::{FileTypeClassifier, SearchDecision};
        use std::path::Path;
        /// Configuration options for file filtering
        pub struct FileFilterOptions {
            pub max_size: Option<usize>,
            pub skip_binary: bool,
            pub safety_policy: SafetyPolicy,
            pub include_extensions: Option<Vec<String>>,
            pub exclude_extensions: Option<Vec<String>>,
            pub search_all_files: bool,
            pub text_only: bool,
            pub file_types: FileTypeStrategy,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FileFilterOptions {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "max_size",
                    "skip_binary",
                    "safety_policy",
                    "include_extensions",
                    "exclude_extensions",
                    "search_all_files",
                    "text_only",
                    "file_types",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.max_size,
                    &self.skip_binary,
                    &self.safety_policy,
                    &self.include_extensions,
                    &self.exclude_extensions,
                    &self.search_all_files,
                    &self.text_only,
                    &&self.file_types,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "FileFilterOptions",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FileFilterOptions {
            #[inline]
            fn clone(&self) -> FileFilterOptions {
                FileFilterOptions {
                    max_size: ::core::clone::Clone::clone(&self.max_size),
                    skip_binary: ::core::clone::Clone::clone(&self.skip_binary),
                    safety_policy: ::core::clone::Clone::clone(&self.safety_policy),
                    include_extensions: ::core::clone::Clone::clone(
                        &self.include_extensions,
                    ),
                    exclude_extensions: ::core::clone::Clone::clone(
                        &self.exclude_extensions,
                    ),
                    search_all_files: ::core::clone::Clone::clone(
                        &self.search_all_files,
                    ),
                    text_only: ::core::clone::Clone::clone(&self.text_only),
                    file_types: ::core::clone::Clone::clone(&self.file_types),
                }
            }
        }
        impl Default for FileFilterOptions {
            fn default() -> Self {
                Self {
                    max_size: None,
                    skip_binary: false,
                    safety_policy: SafetyPolicy::Default,
                    include_extensions: None,
                    exclude_extensions: None,
                    search_all_files: false,
                    text_only: false,
                    file_types: FileTypeStrategy::Default,
                }
            }
        }
        /// Handler for filtering files based on various criteria
        pub struct FileFilter {
            options: FileFilterOptions,
        }
        impl FileFilter {
            /// Create a new file filter with the given options
            pub fn new(options: FileFilterOptions) -> Self {
                Self { options }
            }
            /// Filter a list of files based on configured criteria
            ///
            /// # Arguments
            ///
            /// * `files` - Vector of file paths to filter
            ///
            /// # Returns
            ///
            /// Filtered vector containing only files that pass all filter criteria
            pub fn filter_files(
                &self,
                files: Vec<std::path::PathBuf>,
            ) -> Vec<std::path::PathBuf> {
                files.into_iter().filter(|path| self.should_search_file(path)).collect()
            }
            /// Determine if a specific file should be searched
            ///
            /// # Arguments
            ///
            /// * `path` - Path to the file to check
            ///
            /// # Returns
            ///
            /// `true` if the file passes all filter criteria, `false` otherwise
            pub fn should_search_file(&self, path: &Path) -> bool {
                let metadata = match path.metadata() {
                    Ok(m) => m,
                    Err(_) => return false,
                };
                let ext = path
                    .extension()
                    .and_then(|e| e.to_str())
                    .map(|s| s.to_ascii_lowercase())
                    .unwrap_or_default();
                if self.options.skip_binary && crate::processor::is_binary(path) {
                    return false;
                }
                if !self.apply_safety_policy(&metadata, &ext) {
                    return false;
                }
                if !self.apply_extension_filters(&ext) {
                    return false;
                }
                if !self.should_search_by_file_type(path, &metadata, &ext) {
                    return false;
                }
                if !self.apply_size_limits(&metadata) {
                    return false;
                }
                true
            }
            /// Apply safety policy constraints
            fn apply_safety_policy(
                &self,
                metadata: &std::fs::Metadata,
                ext: &str,
            ) -> bool {
                match self.options.safety_policy {
                    SafetyPolicy::Conservative => {
                        let file_size = metadata.len();
                        if file_size > 10 * 1024 * 1024 {
                            return false;
                        }
                        let classifier = FileTypeClassifier::new();
                        classifier.is_always_search(ext)
                    }
                    SafetyPolicy::Performance => {
                        let file_size = metadata.len();
                        file_size <= 500 * 1024 * 1024
                    }
                    SafetyPolicy::Default => true,
                }
            }
            /// Apply extension filters (include/exclude)
            fn apply_extension_filters(&self, ext: &str) -> bool {
                if let Some(ref include_exts) = self.options.include_extensions {
                    if !include_exts.iter().any(|e| e.eq_ignore_ascii_case(ext)) {
                        return false;
                    }
                }
                if let Some(ref exclude_exts) = self.options.exclude_extensions {
                    if exclude_exts.iter().any(|e| e.eq_ignore_ascii_case(ext)) {
                        return false;
                    }
                }
                true
            }
            /// Determine if file should be searched based on file type strategy
            fn should_search_by_file_type(
                &self,
                path: &Path,
                metadata: &std::fs::Metadata,
                ext: &str,
            ) -> bool {
                if self.options.search_all_files {
                    return true;
                }
                if self.options.text_only {
                    let classifier = FileTypeClassifier::new();
                    return classifier.is_always_search(ext);
                }
                let classifier = FileTypeClassifier::new();
                match self.options.file_types {
                    FileTypeStrategy::Comprehensive => !classifier.is_never_search(ext),
                    FileTypeStrategy::Conservative => classifier.is_always_search(ext),
                    FileTypeStrategy::Performance => {
                        classifier.is_always_search(ext)
                            || classifier.is_conditional_search(ext)
                    }
                    FileTypeStrategy::Default => {
                        #[allow(non_exhaustive_omitted_patterns)]
                        match classifier.should_search(path, metadata) {
                            SearchDecision::Search(_)
                            | SearchDecision::Conditional(_, _) => true,
                            _ => false,
                        }
                    }
                }
            }
            /// Apply size limits
            fn apply_size_limits(&self, metadata: &std::fs::Metadata) -> bool {
                if let Some(max_size) = self.options.max_size {
                    let size_mb = metadata.len() as f64 / (1024.0 * 1024.0);
                    if size_mb > max_size as f64 {
                        return false;
                    }
                }
                true
            }
        }
    }
    pub mod stdin {
        /// Stdin search handler for piped input
        ///
        /// This module provides dedicated functionality for searching content from stdin,
        /// enabling Unix pipeline integration like: `cat file.log | rfgrep search "pattern"`
        use crate::cli::OutputFormat as CliOutputFormat;
        use crate::error::{Result as RfgrepResult, RfgrepError};
        use crate::output_formats::OutputFormatter;
        use crate::processor::SearchMatch;
        use colored::Colorize;
        use std::io::{BufRead, BufReader};
        use std::path::{Path, PathBuf};
        /// Configuration options for stdin search
        pub struct StdinSearchOptions {
            pub search_pattern: String,
            pub original_pattern: String,
            pub case_sensitive: bool,
            pub invert_match: bool,
            pub max_matches: Option<usize>,
            pub output_format: CliOutputFormat,
            pub ndjson: bool,
            pub count: bool,
            pub files_with_matches: bool,
            pub quiet: bool,
        }
        /// Handler for searching stdin input
        pub struct StdinSearcher;
        impl StdinSearcher {
            /// Create a new stdin searcher
            pub fn new() -> Self {
                Self
            }
            /// Search stdin for patterns (handles piped input)
            ///
            /// # Arguments
            ///
            /// * `options` - Search configuration options
            ///
            /// # Returns
            ///
            /// Result indicating success or error
            ///
            /// # Examples
            ///
            /// ```no_run
            /// use rfgrep::app::StdinSearcher;
            /// use rfgrep::app::stdin::StdinSearchOptions;
            /// use rfgrep::cli::OutputFormat;
            ///
            /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
            /// let options = StdinSearchOptions {
            ///     search_pattern: "error".to_string(),
            ///     original_pattern: "error".to_string(),
            ///     case_sensitive: true,
            ///     invert_match: false,
            ///     max_matches: None,
            ///     output_format: OutputFormat::Text,
            ///     ndjson: false,
            ///     count: false,
            ///     files_with_matches: false,
            ///     quiet: false,
            /// };
            ///
            /// let searcher = StdinSearcher::new();
            /// searcher.search(options).await?;
            /// # Ok(())
            /// # }
            /// ```
            pub async fn search(&self, options: StdinSearchOptions) -> RfgrepResult<()> {
                let regex_pattern = if options.case_sensitive {
                    options.search_pattern.clone()
                } else {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("(?i){0}", options.search_pattern),
                        )
                    })
                };
                let regex = crate::processor::get_or_compile_regex(&regex_pattern)?;
                let stdin = std::io::stdin();
                let reader = BufReader::new(stdin.lock());
                let mut matches = Vec::new();
                let mut match_count = 0;
                for (line_number, line_result) in reader.lines().enumerate() {
                    let line = line_result.map_err(RfgrepError::Io)?;
                    let is_match = regex.is_match(&line);
                    let should_include = if options.invert_match {
                        !is_match
                    } else {
                        is_match
                    };
                    if should_include {
                        match_count += 1;
                        if !options.count && !options.files_with_matches {
                            let (matched_text, column_start, column_end) = if let Some(
                                mat,
                            ) = regex.find(&line)
                            {
                                (mat.as_str().to_string(), mat.start(), mat.end())
                            } else {
                                (String::default(), 0, line.len())
                            };
                            let search_match = SearchMatch {
                                path: PathBuf::from("<stdin>"),
                                line_number,
                                line: line.clone(),
                                context_before: Vec::new(),
                                context_after: Vec::new(),
                                matched_text,
                                column_start,
                                column_end,
                            };
                            matches.push(search_match);
                        }
                        if let Some(max) = options.max_matches {
                            if match_count >= max {
                                break;
                            }
                        }
                    }
                }
                self.output_results(matches, match_count, &options)
            }
            /// Output search results in the appropriate format
            fn output_results(
                &self,
                matches: Vec<SearchMatch>,
                match_count: usize,
                options: &StdinSearchOptions,
            ) -> RfgrepResult<()> {
                if options.count {
                    {
                        ::std::io::_print(format_args!("{0}\n", match_count));
                    };
                } else if options.files_with_matches {
                    if match_count > 0 {
                        {
                            ::std::io::_print(format_args!("<stdin>\n"));
                        };
                    }
                } else if matches.is_empty() {
                    self.output_no_matches(options);
                } else {
                    self.output_matches(&matches, options)?;
                }
                Ok(())
            }
            /// Handle output when no matches are found
            fn output_no_matches(&self, options: &StdinSearchOptions) {
                if options.output_format != CliOutputFormat::Json && !options.quiet {
                    {
                        ::std::io::_print(
                            format_args!("{0}\n", "No matches found".yellow()),
                        );
                    };
                }
            }
            /// Output the actual matches with formatting
            fn output_matches(
                &self,
                matches: &[SearchMatch],
                options: &StdinSearchOptions,
            ) -> RfgrepResult<()> {
                if !options.quiet && options.output_format != CliOutputFormat::Json
                    && !options.ndjson
                {
                    {
                        ::std::io::_print(
                            format_args!(
                                "\n{0} {1} {2}\n",
                                "Found".green(),
                                matches.len(),
                                "matches:".green(),
                            ),
                        );
                    };
                }
                let formatter = OutputFormatter::new(
                        if options.ndjson {
                            crate::output_formats::OutputFormat::Json
                        } else {
                            match options.output_format {
                                CliOutputFormat::Text => {
                                    crate::output_formats::OutputFormat::Text
                                }
                                CliOutputFormat::Json => {
                                    crate::output_formats::OutputFormat::Json
                                }
                                CliOutputFormat::Xml => {
                                    crate::output_formats::OutputFormat::Xml
                                }
                                CliOutputFormat::Html => {
                                    crate::output_formats::OutputFormat::Html
                                }
                                CliOutputFormat::Markdown => {
                                    crate::output_formats::OutputFormat::Markdown
                                }
                                CliOutputFormat::Csv => {
                                    crate::output_formats::OutputFormat::Csv
                                }
                                CliOutputFormat::Tsv => {
                                    crate::output_formats::OutputFormat::Tsv
                                }
                            }
                        },
                    )
                    .with_ndjson(options.ndjson);
                let output = formatter
                    .format_results(
                        matches,
                        &options.original_pattern,
                        Path::new("<stdin>"),
                    );
                if options.output_format == CliOutputFormat::Json || options.ndjson {
                    {
                        ::std::io::_print(format_args!("{0}", output));
                    };
                } else {
                    {
                        ::std::io::_print(format_args!("\n{0}\n", output));
                    };
                }
                Ok(())
            }
        }
    }
    pub use filters::{FileFilter, FileFilterOptions};
    pub use stdin::StdinSearcher;
}
/// Command-line interface definitions and argument parsing
pub mod cli {
    use clap::{Parser, Subcommand, ValueEnum};
    use clap_complete::Shell;
    use serde::{Deserialize, Serialize};
    use std::fmt;
    use std::path::PathBuf;
    #[clap(
        name = "rfgrep",
        author = "Khalid Hussein <kh3rld.hussein@gmail.com>",
        version,
        about = "Recursive file grep utility with advanced filtering - search, list, and analyze text files with regex support",
        long_about = r#"
rfgrep - A powerful command-line utility for recursively searching and listing files with advanced filtering capabilities.

FEATURES:
  â¢ Advanced Search: Regex, plain text, and whole-word matching
  â¢ File Listing: Detailed/simple output formats with extension statistics
  â¢ Performance: Parallel processing with memory mapping for large files
  â¢ Filtering: Extension, size, and binary file filtering
  â¢ Utilities: Clipboard copy, dry-run mode, and progress indicators

EXAMPLES:
  # Search for "HashMap" in Rust files
  rfgrep search "HashMap" --extensions rs

  # List all Markdown files under 1MB
  rfgrep list --extensions md --max-size 1

  # Search with regex and copy to clipboard
  rfgrep search "fn\s+\w+\s*\(" regex --copy

  # Recursive search with word boundaries
  rfgrep search "test" word --recursive --extensions rs

PERFORMANCE TIPS:
  â¢ Use --skip-binary to avoid unnecessary file checks
  â¢ Limit scope with --extensions and --max-size
  â¢ Use --dry-run first to preview files
  â¢ Enable --recursive for deep directory traversal
"#,
        after_help = r#"
For more information, visit: https://github.com/kh3rld/rfgrep
"#
    )]
    pub struct Cli {
        #[clap(default_value = ".")]
        pub path: PathBuf,
        #[clap(long, value_parser, default_value_t = false, global = true)]
        pub verbose: bool,
        /// Suppress all non-essential output (useful for piping)
        #[clap(long, short = 'q', value_parser, default_value_t = false, global = true)]
        pub quiet: bool,
        #[clap(long, value_enum, default_value_t = ColorChoice::Auto, global = true)]
        pub color: ColorChoice,
        #[clap(long, value_parser, global = true)]
        pub log: Option<PathBuf>,
        #[clap(long, value_parser, default_value_t = false, global = true)]
        pub dry_run: bool,
        /// Allow running as root (disabled by default for safety)
        #[clap(long, value_parser, default_value_t = false, global = true)]
        pub allow_root: bool,
        #[clap(long, value_parser, global = true)]
        pub max_size: Option<usize>,
        #[clap(long, value_parser, default_value_t = false, global = true)]
        pub skip_binary: bool,
        /// Safety policy for file processing
        #[clap(long, value_enum, default_value_t = SafetyPolicy::Default, global = true)]
        pub safety_policy: SafetyPolicy,
        /// Number of threads for parallel file processing
        #[clap(long, value_parser, global = true)]
        pub threads: Option<usize>,
        #[clap(subcommand)]
        pub command: Commands,
    }
    #[automatically_derived]
    #[allow(unused_qualifications, clippy::redundant_locals)]
    impl clap::Parser for Cli {}
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::CommandFactory for Cli {
        fn command<'b>() -> clap::Command {
            let __clap_app = clap::Command::new("rfgrep");
            <Self as clap::Args>::augment_args(__clap_app)
        }
        fn command_for_update<'b>() -> clap::Command {
            let __clap_app = clap::Command::new("rfgrep");
            <Self as clap::Args>::augment_args_for_update(__clap_app)
        }
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::FromArgMatches for Cli {
        fn from_arg_matches(
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn from_arg_matches_mut(
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            #![allow(deprecated)]
            let v = Cli {
                path: __clap_arg_matches
                    .remove_one::<PathBuf>("path")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: path",
                    ))?,
                verbose: __clap_arg_matches
                    .remove_one::<bool>("verbose")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: verbose",
                    ))?,
                quiet: __clap_arg_matches
                    .remove_one::<bool>("quiet")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: quiet",
                    ))?,
                color: __clap_arg_matches
                    .remove_one::<ColorChoice>("color")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: color",
                    ))?,
                log: __clap_arg_matches.remove_one::<PathBuf>("log"),
                dry_run: __clap_arg_matches
                    .remove_one::<bool>("dry_run")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: dry_run",
                    ))?,
                allow_root: __clap_arg_matches
                    .remove_one::<bool>("allow_root")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: allow_root",
                    ))?,
                max_size: __clap_arg_matches.remove_one::<usize>("max_size"),
                skip_binary: __clap_arg_matches
                    .remove_one::<bool>("skip_binary")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: skip_binary",
                    ))?,
                safety_policy: __clap_arg_matches
                    .remove_one::<SafetyPolicy>("safety_policy")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: safety_policy",
                    ))?,
                threads: __clap_arg_matches.remove_one::<usize>("threads"),
                command: {
                    <Commands as clap::FromArgMatches>::from_arg_matches_mut(
                        __clap_arg_matches,
                    )?
                },
            };
            ::std::result::Result::Ok(v)
        }
        fn update_from_arg_matches(
            &mut self,
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn update_from_arg_matches_mut(
            &mut self,
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            #![allow(deprecated)]
            if __clap_arg_matches.contains_id("path") {
                #[allow(non_snake_case)]
                let path = &mut self.path;
                *path = __clap_arg_matches
                    .remove_one::<PathBuf>("path")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: path",
                    ))?;
            }
            if __clap_arg_matches.contains_id("verbose") {
                #[allow(non_snake_case)]
                let verbose = &mut self.verbose;
                *verbose = __clap_arg_matches
                    .remove_one::<bool>("verbose")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: verbose",
                    ))?;
            }
            if __clap_arg_matches.contains_id("quiet") {
                #[allow(non_snake_case)]
                let quiet = &mut self.quiet;
                *quiet = __clap_arg_matches
                    .remove_one::<bool>("quiet")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: quiet",
                    ))?;
            }
            if __clap_arg_matches.contains_id("color") {
                #[allow(non_snake_case)]
                let color = &mut self.color;
                *color = __clap_arg_matches
                    .remove_one::<ColorChoice>("color")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: color",
                    ))?;
            }
            if __clap_arg_matches.contains_id("log") {
                #[allow(non_snake_case)]
                let log = &mut self.log;
                *log = __clap_arg_matches.remove_one::<PathBuf>("log");
            }
            if __clap_arg_matches.contains_id("dry_run") {
                #[allow(non_snake_case)]
                let dry_run = &mut self.dry_run;
                *dry_run = __clap_arg_matches
                    .remove_one::<bool>("dry_run")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: dry_run",
                    ))?;
            }
            if __clap_arg_matches.contains_id("allow_root") {
                #[allow(non_snake_case)]
                let allow_root = &mut self.allow_root;
                *allow_root = __clap_arg_matches
                    .remove_one::<bool>("allow_root")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: allow_root",
                    ))?;
            }
            if __clap_arg_matches.contains_id("max_size") {
                #[allow(non_snake_case)]
                let max_size = &mut self.max_size;
                *max_size = __clap_arg_matches.remove_one::<usize>("max_size");
            }
            if __clap_arg_matches.contains_id("skip_binary") {
                #[allow(non_snake_case)]
                let skip_binary = &mut self.skip_binary;
                *skip_binary = __clap_arg_matches
                    .remove_one::<bool>("skip_binary")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: skip_binary",
                    ))?;
            }
            if __clap_arg_matches.contains_id("safety_policy") {
                #[allow(non_snake_case)]
                let safety_policy = &mut self.safety_policy;
                *safety_policy = __clap_arg_matches
                    .remove_one::<SafetyPolicy>("safety_policy")
                    .ok_or_else(|| clap::Error::raw(
                        clap::error::ErrorKind::MissingRequiredArgument,
                        "the following required argument was not provided: safety_policy",
                    ))?;
            }
            if __clap_arg_matches.contains_id("threads") {
                #[allow(non_snake_case)]
                let threads = &mut self.threads;
                *threads = __clap_arg_matches.remove_one::<usize>("threads");
            }
            {
                #[allow(non_snake_case)]
                let command = &mut self.command;
                <Commands as clap::FromArgMatches>::update_from_arg_matches_mut(
                    command,
                    __clap_arg_matches,
                )?;
            }
            ::std::result::Result::Ok(())
        }
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::Args for Cli {
        fn group_id() -> Option<clap::Id> {
            Some(clap::Id::from("Cli"))
        }
        fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command {
            {
                let __clap_app = __clap_app
                    .group(
                        clap::ArgGroup::new("Cli")
                            .multiple(true)
                            .args({
                                let members: [clap::Id; 11usize] = [
                                    clap::Id::from("path"),
                                    clap::Id::from("verbose"),
                                    clap::Id::from("quiet"),
                                    clap::Id::from("color"),
                                    clap::Id::from("log"),
                                    clap::Id::from("dry_run"),
                                    clap::Id::from("allow_root"),
                                    clap::Id::from("max_size"),
                                    clap::Id::from("skip_binary"),
                                    clap::Id::from("safety_policy"),
                                    clap::Id::from("threads"),
                                ];
                                members
                            }),
                    );
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("path")
                            .value_name("PATH")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    PathBuf,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg.default_value(".");
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("verbose")
                            .value_name("VERBOSE")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .long("verbose")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("quiet")
                            .value_name("QUIET")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .help(
                                "Suppress all non-essential output (useful for piping)",
                            )
                            .long_help(None)
                            .long("quiet")
                            .short('q')
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("color")
                            .value_name("COLOR")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    ColorChoice,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .long("color")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: ColorChoice = ColorChoice::Auto;
                                        clap::ValueEnum::to_possible_value(&val)
                                            .unwrap()
                                            .get_name()
                                            .to_owned()
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("log")
                            .value_name("LOG")
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    PathBuf,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg.long("log").global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("dry_run")
                            .value_name("DRY_RUN")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .long("dry-run")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("allow_root")
                            .value_name("ALLOW_ROOT")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .help(
                                "Allow running as root (disabled by default for safety)",
                            )
                            .long_help(None)
                            .long("allow-root")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("max_size")
                            .value_name("MAX_SIZE")
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    usize,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg.long("max-size").global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("skip_binary")
                            .value_name("SKIP_BINARY")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .long("skip-binary")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("safety_policy")
                            .value_name("SAFETY_POLICY")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    SafetyPolicy,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Safety policy for file processing")
                            .long_help(None)
                            .long("safety-policy")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: SafetyPolicy = SafetyPolicy::Default;
                                        clap::ValueEnum::to_possible_value(&val)
                                            .unwrap()
                                            .get_name()
                                            .to_owned()
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("threads")
                            .value_name("THREADS")
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    usize,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Number of threads for parallel file processing")
                            .long_help(None)
                            .long("threads")
                            .global(true);
                        let arg = arg;
                        arg
                    });
                let __clap_app = <Commands as clap::Subcommand>::augment_subcommands(
                    __clap_app,
                );
                let __clap_app = __clap_app
                    .subcommand_required(true)
                    .arg_required_else_help(true);
                __clap_app
                    .author("Khalid Hussein <kh3rld.hussein@gmail.com>")
                    .version("0.5.0")
                    .about(
                        "Recursive file grep utility with advanced filtering - search, list, and analyze text files with regex support",
                    )
                    .long_about(
                        r#"
rfgrep - A powerful command-line utility for recursively searching and listing files with advanced filtering capabilities.

FEATURES:
  â¢ Advanced Search: Regex, plain text, and whole-word matching
  â¢ File Listing: Detailed/simple output formats with extension statistics
  â¢ Performance: Parallel processing with memory mapping for large files
  â¢ Filtering: Extension, size, and binary file filtering
  â¢ Utilities: Clipboard copy, dry-run mode, and progress indicators

EXAMPLES:
  # Search for "HashMap" in Rust files
  rfgrep search "HashMap" --extensions rs

  # List all Markdown files under 1MB
  rfgrep list --extensions md --max-size 1

  # Search with regex and copy to clipboard
  rfgrep search "fn\s+\w+\s*\(" regex --copy

  # Recursive search with word boundaries
  rfgrep search "test" word --recursive --extensions rs

PERFORMANCE TIPS:
  â¢ Use --skip-binary to avoid unnecessary file checks
  â¢ Limit scope with --extensions and --max-size
  â¢ Use --dry-run first to preview files
  â¢ Enable --recursive for deep directory traversal
"#,
                    )
                    .after_help(
                        r#"
For more information, visit: https://github.com/kh3rld/rfgrep
"#,
                    )
            }
        }
        fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
            {
                let __clap_app = __clap_app
                    .group(
                        clap::ArgGroup::new("Cli")
                            .multiple(true)
                            .args({
                                let members: [clap::Id; 11usize] = [
                                    clap::Id::from("path"),
                                    clap::Id::from("verbose"),
                                    clap::Id::from("quiet"),
                                    clap::Id::from("color"),
                                    clap::Id::from("log"),
                                    clap::Id::from("dry_run"),
                                    clap::Id::from("allow_root"),
                                    clap::Id::from("max_size"),
                                    clap::Id::from("skip_binary"),
                                    clap::Id::from("safety_policy"),
                                    clap::Id::from("threads"),
                                ];
                                members
                            }),
                    );
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("path")
                            .value_name("PATH")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    PathBuf,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg.default_value(".");
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("verbose")
                            .value_name("VERBOSE")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .long("verbose")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("quiet")
                            .value_name("QUIET")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .help(
                                "Suppress all non-essential output (useful for piping)",
                            )
                            .long_help(None)
                            .long("quiet")
                            .short('q')
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("color")
                            .value_name("COLOR")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    ColorChoice,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .long("color")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: ColorChoice = ColorChoice::Auto;
                                        clap::ValueEnum::to_possible_value(&val)
                                            .unwrap()
                                            .get_name()
                                            .to_owned()
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("log")
                            .value_name("LOG")
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    PathBuf,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg.long("log").global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("dry_run")
                            .value_name("DRY_RUN")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .long("dry-run")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("allow_root")
                            .value_name("ALLOW_ROOT")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .help(
                                "Allow running as root (disabled by default for safety)",
                            )
                            .long_help(None)
                            .long("allow-root")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("max_size")
                            .value_name("MAX_SIZE")
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    usize,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg.long("max-size").global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("skip_binary")
                            .value_name("SKIP_BINARY")
                            .required(false && clap::ArgAction::SetTrue.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    bool,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::SetTrue);
                        let arg = arg
                            .long("skip-binary")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: bool = false;
                                        ::std::string::ToString::to_string(&val)
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("safety_policy")
                            .value_name("SAFETY_POLICY")
                            .required(false && clap::ArgAction::Set.takes_values())
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    SafetyPolicy,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Safety policy for file processing")
                            .long_help(None)
                            .long("safety-policy")
                            .default_value({
                                static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                let s = DEFAULT_VALUE
                                    .get_or_init(|| {
                                        let val: SafetyPolicy = SafetyPolicy::Default;
                                        clap::ValueEnum::to_possible_value(&val)
                                            .unwrap()
                                            .get_name()
                                            .to_owned()
                                    });
                                let s: &'static str = &*s;
                                s
                            })
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = __clap_app
                    .arg({
                        #[allow(deprecated)]
                        let arg = clap::Arg::new("threads")
                            .value_name("THREADS")
                            .value_parser({
                                use ::clap_builder::builder::impl_prelude::*;
                                let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                    usize,
                                >::new();
                                (&&&&&&auto).value_parser()
                            })
                            .action(clap::ArgAction::Set);
                        let arg = arg
                            .help("Number of threads for parallel file processing")
                            .long_help(None)
                            .long("threads")
                            .global(true);
                        let arg = arg.required(false);
                        arg
                    });
                let __clap_app = <Commands as clap::Subcommand>::augment_subcommands(
                    __clap_app,
                );
                let __clap_app = __clap_app
                    .subcommand_required(true)
                    .arg_required_else_help(true)
                    .subcommand_required(false)
                    .arg_required_else_help(false);
                __clap_app
                    .author("Khalid Hussein <kh3rld.hussein@gmail.com>")
                    .version("0.5.0")
                    .about(
                        "Recursive file grep utility with advanced filtering - search, list, and analyze text files with regex support",
                    )
                    .long_about(
                        r#"
rfgrep - A powerful command-line utility for recursively searching and listing files with advanced filtering capabilities.

FEATURES:
  â¢ Advanced Search: Regex, plain text, and whole-word matching
  â¢ File Listing: Detailed/simple output formats with extension statistics
  â¢ Performance: Parallel processing with memory mapping for large files
  â¢ Filtering: Extension, size, and binary file filtering
  â¢ Utilities: Clipboard copy, dry-run mode, and progress indicators

EXAMPLES:
  # Search for "HashMap" in Rust files
  rfgrep search "HashMap" --extensions rs

  # List all Markdown files under 1MB
  rfgrep list --extensions md --max-size 1

  # Search with regex and copy to clipboard
  rfgrep search "fn\s+\w+\s*\(" regex --copy

  # Recursive search with word boundaries
  rfgrep search "test" word --recursive --extensions rs

PERFORMANCE TIPS:
  â¢ Use --skip-binary to avoid unnecessary file checks
  â¢ Limit scope with --extensions and --max-size
  â¢ Use --dry-run first to preview files
  â¢ Enable --recursive for deep directory traversal
"#,
                    )
                    .after_help(
                        r#"
For more information, visit: https://github.com/kh3rld/rfgrep
"#,
                    )
            }
        }
    }
    pub enum ColorChoice {
        Auto,
        Always,
        Never,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ColorChoice {}
    #[automatically_derived]
    #[doc(hidden)]
    unsafe impl ::core::clone::TrivialClone for ColorChoice {}
    #[automatically_derived]
    impl ::core::clone::Clone for ColorChoice {
        #[inline]
        fn clone(&self) -> ColorChoice {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ColorChoice {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ColorChoice {
        #[inline]
        fn eq(&self, other: &ColorChoice) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ColorChoice {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for ColorChoice {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Auto, Self::Always, Self::Never]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::Auto => Some({ clap::builder::PossibleValue::new("auto") }),
                Self::Always => Some({ clap::builder::PossibleValue::new("always") }),
                Self::Never => Some({ clap::builder::PossibleValue::new("never") }),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ColorChoice {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ColorChoice::Auto => "Auto",
                    ColorChoice::Always => "Always",
                    ColorChoice::Never => "Never",
                },
            )
        }
    }
    pub enum Commands {
        /// Run simulations and performance benchmarks to evaluate the current implementation
        #[clap(
            after_help = r#"
SIMULATIONS:
  Run built-in benchmark scenarios over a test corpus to evaluate performance and limitations.

EXAMPLES:
  # Run simulations in the current directory (uses bench_data if present)
  rfgrep simulate

  # Run simulations from a specific path
  rfgrep simulate --path .
"#
        )]
        Simulate {},
        #[clap(
            after_help = r#"
SEARCH MODES:
  text    - Plain text search (default)
  word    - Whole word matching with boundaries
  regex   - Regular expression search

EXAMPLES:
  # Basic text search
  rfgrep search "error" --extensions rs

  # Word boundary search
  rfgrep search "test" word --recursive

  # Regex search for function definitions
  rfgrep search "fn\s+\w+\s*\(" regex --extensions rs

  # Search and copy results to clipboard
  rfgrep search "TODO" --copy --extensions rs,md

  # Pipe input from another command
  cat file.log | rfgrep search "error"

  # Chain with other tools
  cat .zsh_history | rfgrep search "git" -c

  # Use with command substitution
  echo "test data" | rfgrep search "test"

PERFORMANCE TIPS:
  â¢ Use --skip-binary for faster processing
  â¢ Limit file size with --max-size
  â¢ Use --dry-run to preview files first
  â¢ Pipe data directly for faster processing
"#
        )]
        Search {
            pattern: String,
            #[clap(long, value_enum, default_value_t = SearchMode::Text)]
            mode: SearchMode,
            #[clap(long, value_parser, default_value_t = false)]
            copy: bool,
            #[clap(long, value_enum, default_value_t = OutputFormat::Text)]
            output_format: OutputFormat,
            /// Emit newline-delimited JSON (one JSON object per match)
            #[clap(long, value_parser, default_value_t = false)]
            ndjson: bool,
            #[clap(long, value_parser, use_value_delimiter = true)]
            extensions: Option<Vec<String>>,
            /// File type handling strategy
            #[clap(long, value_enum, default_value_t = FileTypeStrategy::Default)]
            file_types: FileTypeStrategy,
            /// Include specific file types (overrides default strategy)
            #[clap(long, value_parser, use_value_delimiter = true)]
            include_extensions: Option<Vec<String>>,
            /// Exclude specific file types (overrides default strategy)
            #[clap(long, value_parser, use_value_delimiter = true)]
            exclude_extensions: Option<Vec<String>>,
            /// Search all file types (comprehensive mode)
            #[clap(long, value_parser, default_value_t = false)]
            search_all_files: bool,
            /// Only search text files (conservative mode)
            #[clap(long, value_parser, default_value_t = false)]
            text_only: bool,
            #[clap(short, long, value_parser, default_value_t = true)]
            recursive: bool,
            #[clap(long, value_parser, default_value_t = 0)]
            context_lines: usize,
            #[clap(long, value_parser, default_value_t = false)]
            case_sensitive: bool,
            #[clap(long, value_parser, default_value_t = false)]
            invert_match: bool,
            /// Per-file timeout in seconds (abort scanning a file after this many seconds)
            #[clap(long, value_parser)]
            timeout_per_file: Option<u64>,
            #[clap(long, value_parser)]
            max_matches: Option<usize>,
            #[clap(long, value_enum, default_value_t = SearchAlgorithm::BoyerMoore)]
            algorithm: SearchAlgorithm,
            /// Only show count of matches, not the matches themselves
            #[clap(long, short = 'c', value_parser, default_value_t = false)]
            count: bool,
            /// Only show filenames with matches, not the matches themselves
            #[clap(long, short = 'l', value_parser, default_value_t = false)]
            files_with_matches: bool,
            #[clap(value_parser, last = true)]
            path: Option<PathBuf>,
            /// Alternative explicit path flag (useful for scripts)
            #[clap(long, value_parser, alias = "path-flag")]
            path_flag: Option<PathBuf>,
        },
        #[clap(
            after_help = r#"
INTERACTIVE FEATURES:
  â¢ Real-time search with live filtering
  â¢ Keyboard navigation and commands
  â¢ Result highlighting and selection
  â¢ Save results to file
  â¢ Memory-optimized processing

COMMANDS:
  n/new   - Start a new search
  f/filter - Filter current results
  c/clear - Clear all filters
  s/save  - Save results to file
  q/quit  - Exit interactive mode

EXAMPLES:
  # Start interactive search
  rfgrep interactive "error" --extensions rs

  # Interactive search with specific algorithm
  rfgrep interactive "test" --algorithm boyer-moore --recursive
"#
        )]
        Interactive {
            pattern: String,
            #[clap(long, value_enum, default_value_t = InteractiveAlgorithm::BoyerMoore)]
            algorithm: InteractiveAlgorithm,
            #[clap(long, value_parser, use_value_delimiter = true)]
            extensions: Option<Vec<String>>,
            #[clap(short, long, value_parser, default_value_t = false)]
            recursive: bool,
            #[clap(value_parser, last = true)]
            path: Option<PathBuf>,
            /// Alternative explicit path flag (useful for scripts)
            #[clap(long, value_parser, alias = "path-flag")]
            path_flag: Option<PathBuf>,
        },
        #[clap(
            after_help = r#"
OUTPUT FORMATS:
  Simple  - Just file paths (default)
  Long    - Detailed table with size, type, and binary info

EXAMPLES:
  # Simple file listing
  rfgrep list --extensions rs

  # Detailed listing with size info
  rfgrep list --long --extensions rs,md

  # Recursive listing with hidden files
  rfgrep list --recursive --show-hidden --extensions rs

  # List files under 1MB
  rfgrep list --max-size 1 --extensions rs

FEATURES:
  â¢ Extension statistics and file counts
  â¢ Binary file detection
  â¢ Size filtering and formatting
  â¢ Hidden file handling
  â¢ Recursive directory traversal
"#
        )]
        List {
            #[clap(long, value_parser, use_value_delimiter = true)]
            extensions: Option<Vec<String>>,
            #[clap(short, long, value_parser, default_value_t = false)]
            long: bool,
            #[clap(short, long, value_parser, default_value_t = false)]
            recursive: bool,
            #[clap(long, value_parser, default_value_t = false)]
            show_hidden: bool,
            #[clap(long, value_parser)]
            max_size: Option<usize>,
            #[clap(long, value_parser)]
            min_size: Option<usize>,
            #[clap(long, value_parser, default_value_t = false)]
            detailed: bool,
            #[clap(long, value_parser, default_value_t = false)]
            simple: bool,
            #[clap(long, value_parser, default_value_t = false)]
            stats: bool,
            #[clap(long, value_enum, default_value_t = SortCriteria::Name)]
            sort: SortCriteria,
            #[clap(long, value_parser, default_value_t = false)]
            reverse: bool,
            #[clap(long, value_parser)]
            limit: Option<usize>,
            #[clap(long, value_parser, default_value_t = false)]
            copy: bool,
            #[clap(long, value_enum, default_value_t = OutputFormat::Text)]
            output_format: OutputFormat,
            #[clap(value_parser, last = true)]
            path: Option<PathBuf>,
            /// Alternative explicit path flag (useful for scripts)
            #[clap(long, value_parser, alias = "path-flag")]
            path_flag: Option<PathBuf>,
        },
        #[clap(
            after_help = r#"
SUPPORTED SHELLS:
  bash     - Bash shell completions
  zsh      - Zsh shell completions
  fish     - Fish shell completions
  powershell - PowerShell completions
  elvish   - Elvish shell completions

EXAMPLES:
  # Generate bash completions
  rfgrep completions bash > ~/.local/share/bash-completion/completions/rfgrep

  # Generate zsh completions
  rfgrep completions zsh > ~/.zsh/completions/_rfgrep

  # Generate fish completions
  rfgrep completions fish > ~/.config/fish/completions/rfgrep.fish

SETUP:
  Add the generated completion script to your shell's completion directory
  and restart your shell or source the completion file.
"#
        )]
        Completions { #[clap(value_enum)] shell: Shell },
        #[clap(
            after_help = r#"
PLUGIN MANAGEMENT:
  list     - List all available plugins
  stats    - Show plugin statistics
  info     - Show detailed plugin information
  enable   - Enable a plugin
  disable  - Disable a plugin
  priority - Set plugin priority
  config   - Show plugin configuration options
  test     - Test plugin with specific file

EXAMPLES:
  # List all plugins
  rfgrep plugins list

  # Show plugin statistics
  rfgrep plugins stats

  # Get info about text plugin
  rfgrep plugins info enhanced_text

  # Enable binary plugin
  rfgrep plugins enable enhanced_binary

  # Test text plugin on a file
  rfgrep plugins test enhanced_text README.md "example"
"#
        )]
        Plugins { #[clap(subcommand)] command: PluginCommands },
        /// Interactive TUI mode
        #[clap(
            after_help = r#"
INTERACTIVE TUI MODE:
  Launch an interactive terminal user interface for searching files.

EXAMPLES:
  # Start TUI with a pattern
  rfgrep tui "search pattern"

  # Start TUI and enter pattern interactively
  rfgrep tui

  # Start TUI with specific algorithm
  rfgrep tui "pattern" --algorithm boyer-moore

  # Start TUI with case-sensitive search
  rfgrep tui "pattern" --case-sensitive

CONTROLS:
  h         - Toggle help
  q         - Quit
  â/â, j/k  - Navigate matches
  â/â, h/l  - Navigate files
  n/N       - Next/Previous match
  c         - Toggle case sensitivity
  m         - Cycle search mode
  a         - Cycle algorithm
  r         - Refresh search
  Enter     - Open file in editor
"#
        )]
        Tui {
            /// Search pattern
            pattern: Option<String>,
            /// Search algorithm to use
            #[clap(long, value_enum, default_value = "boyer-moore")]
            algorithm: SearchAlgorithm,
            /// Enable case-sensitive search
            #[clap(long)]
            case_sensitive: bool,
            /// Search mode
            #[clap(long, value_enum, default_value = "text")]
            mode: SearchMode,
            /// Number of context lines to show
            #[clap(long, default_value = "0")]
            context_lines: usize,
            /// Search path
            #[clap(long, default_value = ".")]
            path: String,
        },
        #[clap(hide = true)]
        Worker { path: std::path::PathBuf, pattern: String },
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::FromArgMatches for Commands {
        fn from_arg_matches(
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn from_arg_matches_mut(
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            #![allow(deprecated)]
            if let Some((__clap_name, mut __clap_arg_sub_matches)) = __clap_arg_matches
                .remove_subcommand()
            {
                let __clap_arg_matches = &mut __clap_arg_sub_matches;
                if __clap_name == "simulate" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Simulate {});
                }
                if __clap_name == "search" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Search {
                        pattern: __clap_arg_matches
                            .remove_one::<String>("pattern")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: pattern",
                            ))?,
                        mode: __clap_arg_matches
                            .remove_one::<SearchMode>("mode")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: mode",
                            ))?,
                        copy: __clap_arg_matches
                            .remove_one::<bool>("copy")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: copy",
                            ))?,
                        output_format: __clap_arg_matches
                            .remove_one::<OutputFormat>("output_format")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: output_format",
                            ))?,
                        ndjson: __clap_arg_matches
                            .remove_one::<bool>("ndjson")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: ndjson",
                            ))?,
                        extensions: if __clap_arg_matches.contains_id("extensions") {
                            Some(
                                __clap_arg_matches
                                    .remove_many::<String>("extensions")
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new),
                            )
                        } else {
                            None
                        },
                        file_types: __clap_arg_matches
                            .remove_one::<FileTypeStrategy>("file_types")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: file_types",
                            ))?,
                        include_extensions: if __clap_arg_matches
                            .contains_id("include_extensions")
                        {
                            Some(
                                __clap_arg_matches
                                    .remove_many::<String>("include_extensions")
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new),
                            )
                        } else {
                            None
                        },
                        exclude_extensions: if __clap_arg_matches
                            .contains_id("exclude_extensions")
                        {
                            Some(
                                __clap_arg_matches
                                    .remove_many::<String>("exclude_extensions")
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new),
                            )
                        } else {
                            None
                        },
                        search_all_files: __clap_arg_matches
                            .remove_one::<bool>("search_all_files")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: search_all_files",
                            ))?,
                        text_only: __clap_arg_matches
                            .remove_one::<bool>("text_only")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: text_only",
                            ))?,
                        recursive: __clap_arg_matches
                            .remove_one::<bool>("recursive")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: recursive",
                            ))?,
                        context_lines: __clap_arg_matches
                            .remove_one::<usize>("context_lines")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: context_lines",
                            ))?,
                        case_sensitive: __clap_arg_matches
                            .remove_one::<bool>("case_sensitive")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: case_sensitive",
                            ))?,
                        invert_match: __clap_arg_matches
                            .remove_one::<bool>("invert_match")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: invert_match",
                            ))?,
                        timeout_per_file: __clap_arg_matches
                            .remove_one::<u64>("timeout_per_file"),
                        max_matches: __clap_arg_matches
                            .remove_one::<usize>("max_matches"),
                        algorithm: __clap_arg_matches
                            .remove_one::<SearchAlgorithm>("algorithm")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: algorithm",
                            ))?,
                        count: __clap_arg_matches
                            .remove_one::<bool>("count")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: count",
                            ))?,
                        files_with_matches: __clap_arg_matches
                            .remove_one::<bool>("files_with_matches")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: files_with_matches",
                            ))?,
                        path: __clap_arg_matches.remove_one::<PathBuf>("path"),
                        path_flag: __clap_arg_matches.remove_one::<PathBuf>("path_flag"),
                    });
                }
                if __clap_name == "interactive" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Interactive {
                        pattern: __clap_arg_matches
                            .remove_one::<String>("pattern")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: pattern",
                            ))?,
                        algorithm: __clap_arg_matches
                            .remove_one::<InteractiveAlgorithm>("algorithm")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: algorithm",
                            ))?,
                        extensions: if __clap_arg_matches.contains_id("extensions") {
                            Some(
                                __clap_arg_matches
                                    .remove_many::<String>("extensions")
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new),
                            )
                        } else {
                            None
                        },
                        recursive: __clap_arg_matches
                            .remove_one::<bool>("recursive")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: recursive",
                            ))?,
                        path: __clap_arg_matches.remove_one::<PathBuf>("path"),
                        path_flag: __clap_arg_matches.remove_one::<PathBuf>("path_flag"),
                    });
                }
                if __clap_name == "list" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::List {
                        extensions: if __clap_arg_matches.contains_id("extensions") {
                            Some(
                                __clap_arg_matches
                                    .remove_many::<String>("extensions")
                                    .map(|v| v.collect::<Vec<_>>())
                                    .unwrap_or_else(Vec::new),
                            )
                        } else {
                            None
                        },
                        long: __clap_arg_matches
                            .remove_one::<bool>("long")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: long",
                            ))?,
                        recursive: __clap_arg_matches
                            .remove_one::<bool>("recursive")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: recursive",
                            ))?,
                        show_hidden: __clap_arg_matches
                            .remove_one::<bool>("show_hidden")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: show_hidden",
                            ))?,
                        max_size: __clap_arg_matches.remove_one::<usize>("max_size"),
                        min_size: __clap_arg_matches.remove_one::<usize>("min_size"),
                        detailed: __clap_arg_matches
                            .remove_one::<bool>("detailed")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: detailed",
                            ))?,
                        simple: __clap_arg_matches
                            .remove_one::<bool>("simple")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: simple",
                            ))?,
                        stats: __clap_arg_matches
                            .remove_one::<bool>("stats")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: stats",
                            ))?,
                        sort: __clap_arg_matches
                            .remove_one::<SortCriteria>("sort")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: sort",
                            ))?,
                        reverse: __clap_arg_matches
                            .remove_one::<bool>("reverse")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: reverse",
                            ))?,
                        limit: __clap_arg_matches.remove_one::<usize>("limit"),
                        copy: __clap_arg_matches
                            .remove_one::<bool>("copy")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: copy",
                            ))?,
                        output_format: __clap_arg_matches
                            .remove_one::<OutputFormat>("output_format")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: output_format",
                            ))?,
                        path: __clap_arg_matches.remove_one::<PathBuf>("path"),
                        path_flag: __clap_arg_matches.remove_one::<PathBuf>("path_flag"),
                    });
                }
                if __clap_name == "completions" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Completions {
                        shell: __clap_arg_matches
                            .remove_one::<Shell>("shell")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: shell",
                            ))?,
                    });
                }
                if __clap_name == "plugins" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Plugins {
                        command: {
                            <PluginCommands as clap::FromArgMatches>::from_arg_matches_mut(
                                __clap_arg_matches,
                            )?
                        },
                    });
                }
                if __clap_name == "tui" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Tui {
                        pattern: __clap_arg_matches.remove_one::<String>("pattern"),
                        algorithm: __clap_arg_matches
                            .remove_one::<SearchAlgorithm>("algorithm")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: algorithm",
                            ))?,
                        case_sensitive: __clap_arg_matches
                            .remove_one::<bool>("case_sensitive")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: case_sensitive",
                            ))?,
                        mode: __clap_arg_matches
                            .remove_one::<SearchMode>("mode")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: mode",
                            ))?,
                        context_lines: __clap_arg_matches
                            .remove_one::<usize>("context_lines")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: context_lines",
                            ))?,
                        path: __clap_arg_matches
                            .remove_one::<String>("path")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: path",
                            ))?,
                    });
                }
                if __clap_name == "worker" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Worker {
                        path: __clap_arg_matches
                            .remove_one::<std::path::PathBuf>("path")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: path",
                            ))?,
                        pattern: __clap_arg_matches
                            .remove_one::<String>("pattern")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: pattern",
                            ))?,
                    });
                }
                ::std::result::Result::Err(
                    clap::Error::raw(
                        clap::error::ErrorKind::InvalidSubcommand,
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "the subcommand \'{0}\' wasn\'t recognized",
                                    __clap_name,
                                ),
                            )
                        }),
                    ),
                )
            } else {
                ::std::result::Result::Err(
                    clap::Error::raw(
                        clap::error::ErrorKind::MissingSubcommand,
                        "a subcommand is required but one was not provided",
                    ),
                )
            }
        }
        fn update_from_arg_matches(
            &mut self,
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn update_from_arg_matches_mut<'b>(
            &mut self,
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            #![allow(deprecated)]
            if let Some(__clap_name) = __clap_arg_matches.subcommand_name() {
                match self {
                    Self::Simulate {} if "simulate" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {}
                    }
                    Self::Search {
                        pattern,
                        mode,
                        copy,
                        output_format,
                        ndjson,
                        extensions,
                        file_types,
                        include_extensions,
                        exclude_extensions,
                        search_all_files,
                        text_only,
                        recursive,
                        context_lines,
                        case_sensitive,
                        invert_match,
                        timeout_per_file,
                        max_matches,
                        algorithm,
                        count,
                        files_with_matches,
                        path,
                        path_flag,
                    } if "search" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("pattern") {
                                *pattern = __clap_arg_matches
                                    .remove_one::<String>("pattern")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: pattern",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("mode") {
                                *mode = __clap_arg_matches
                                    .remove_one::<SearchMode>("mode")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: mode",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("copy") {
                                *copy = __clap_arg_matches
                                    .remove_one::<bool>("copy")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: copy",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("output_format") {
                                *output_format = __clap_arg_matches
                                    .remove_one::<OutputFormat>("output_format")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: output_format",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("ndjson") {
                                *ndjson = __clap_arg_matches
                                    .remove_one::<bool>("ndjson")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: ndjson",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("extensions") {
                                *extensions = if __clap_arg_matches
                                    .contains_id("extensions")
                                {
                                    Some(
                                        __clap_arg_matches
                                            .remove_many::<String>("extensions")
                                            .map(|v| v.collect::<Vec<_>>())
                                            .unwrap_or_else(Vec::new),
                                    )
                                } else {
                                    None
                                };
                            }
                            if __clap_arg_matches.contains_id("file_types") {
                                *file_types = __clap_arg_matches
                                    .remove_one::<FileTypeStrategy>("file_types")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: file_types",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("include_extensions") {
                                *include_extensions = if __clap_arg_matches
                                    .contains_id("include_extensions")
                                {
                                    Some(
                                        __clap_arg_matches
                                            .remove_many::<String>("include_extensions")
                                            .map(|v| v.collect::<Vec<_>>())
                                            .unwrap_or_else(Vec::new),
                                    )
                                } else {
                                    None
                                };
                            }
                            if __clap_arg_matches.contains_id("exclude_extensions") {
                                *exclude_extensions = if __clap_arg_matches
                                    .contains_id("exclude_extensions")
                                {
                                    Some(
                                        __clap_arg_matches
                                            .remove_many::<String>("exclude_extensions")
                                            .map(|v| v.collect::<Vec<_>>())
                                            .unwrap_or_else(Vec::new),
                                    )
                                } else {
                                    None
                                };
                            }
                            if __clap_arg_matches.contains_id("search_all_files") {
                                *search_all_files = __clap_arg_matches
                                    .remove_one::<bool>("search_all_files")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: search_all_files",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("text_only") {
                                *text_only = __clap_arg_matches
                                    .remove_one::<bool>("text_only")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: text_only",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("recursive") {
                                *recursive = __clap_arg_matches
                                    .remove_one::<bool>("recursive")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: recursive",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("context_lines") {
                                *context_lines = __clap_arg_matches
                                    .remove_one::<usize>("context_lines")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: context_lines",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("case_sensitive") {
                                *case_sensitive = __clap_arg_matches
                                    .remove_one::<bool>("case_sensitive")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: case_sensitive",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("invert_match") {
                                *invert_match = __clap_arg_matches
                                    .remove_one::<bool>("invert_match")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: invert_match",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("timeout_per_file") {
                                *timeout_per_file = __clap_arg_matches
                                    .remove_one::<u64>("timeout_per_file");
                            }
                            if __clap_arg_matches.contains_id("max_matches") {
                                *max_matches = __clap_arg_matches
                                    .remove_one::<usize>("max_matches");
                            }
                            if __clap_arg_matches.contains_id("algorithm") {
                                *algorithm = __clap_arg_matches
                                    .remove_one::<SearchAlgorithm>("algorithm")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: algorithm",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("count") {
                                *count = __clap_arg_matches
                                    .remove_one::<bool>("count")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: count",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("files_with_matches") {
                                *files_with_matches = __clap_arg_matches
                                    .remove_one::<bool>("files_with_matches")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: files_with_matches",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("path") {
                                *path = __clap_arg_matches.remove_one::<PathBuf>("path");
                            }
                            if __clap_arg_matches.contains_id("path_flag") {
                                *path_flag = __clap_arg_matches
                                    .remove_one::<PathBuf>("path_flag");
                            }
                        }
                    }
                    Self::Interactive {
                        pattern,
                        algorithm,
                        extensions,
                        recursive,
                        path,
                        path_flag,
                    } if "interactive" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("pattern") {
                                *pattern = __clap_arg_matches
                                    .remove_one::<String>("pattern")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: pattern",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("algorithm") {
                                *algorithm = __clap_arg_matches
                                    .remove_one::<InteractiveAlgorithm>("algorithm")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: algorithm",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("extensions") {
                                *extensions = if __clap_arg_matches
                                    .contains_id("extensions")
                                {
                                    Some(
                                        __clap_arg_matches
                                            .remove_many::<String>("extensions")
                                            .map(|v| v.collect::<Vec<_>>())
                                            .unwrap_or_else(Vec::new),
                                    )
                                } else {
                                    None
                                };
                            }
                            if __clap_arg_matches.contains_id("recursive") {
                                *recursive = __clap_arg_matches
                                    .remove_one::<bool>("recursive")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: recursive",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("path") {
                                *path = __clap_arg_matches.remove_one::<PathBuf>("path");
                            }
                            if __clap_arg_matches.contains_id("path_flag") {
                                *path_flag = __clap_arg_matches
                                    .remove_one::<PathBuf>("path_flag");
                            }
                        }
                    }
                    Self::List {
                        extensions,
                        long,
                        recursive,
                        show_hidden,
                        max_size,
                        min_size,
                        detailed,
                        simple,
                        stats,
                        sort,
                        reverse,
                        limit,
                        copy,
                        output_format,
                        path,
                        path_flag,
                    } if "list" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("extensions") {
                                *extensions = if __clap_arg_matches
                                    .contains_id("extensions")
                                {
                                    Some(
                                        __clap_arg_matches
                                            .remove_many::<String>("extensions")
                                            .map(|v| v.collect::<Vec<_>>())
                                            .unwrap_or_else(Vec::new),
                                    )
                                } else {
                                    None
                                };
                            }
                            if __clap_arg_matches.contains_id("long") {
                                *long = __clap_arg_matches
                                    .remove_one::<bool>("long")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: long",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("recursive") {
                                *recursive = __clap_arg_matches
                                    .remove_one::<bool>("recursive")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: recursive",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("show_hidden") {
                                *show_hidden = __clap_arg_matches
                                    .remove_one::<bool>("show_hidden")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: show_hidden",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("max_size") {
                                *max_size = __clap_arg_matches
                                    .remove_one::<usize>("max_size");
                            }
                            if __clap_arg_matches.contains_id("min_size") {
                                *min_size = __clap_arg_matches
                                    .remove_one::<usize>("min_size");
                            }
                            if __clap_arg_matches.contains_id("detailed") {
                                *detailed = __clap_arg_matches
                                    .remove_one::<bool>("detailed")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: detailed",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("simple") {
                                *simple = __clap_arg_matches
                                    .remove_one::<bool>("simple")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: simple",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("stats") {
                                *stats = __clap_arg_matches
                                    .remove_one::<bool>("stats")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: stats",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("sort") {
                                *sort = __clap_arg_matches
                                    .remove_one::<SortCriteria>("sort")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: sort",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("reverse") {
                                *reverse = __clap_arg_matches
                                    .remove_one::<bool>("reverse")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: reverse",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("limit") {
                                *limit = __clap_arg_matches.remove_one::<usize>("limit");
                            }
                            if __clap_arg_matches.contains_id("copy") {
                                *copy = __clap_arg_matches
                                    .remove_one::<bool>("copy")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: copy",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("output_format") {
                                *output_format = __clap_arg_matches
                                    .remove_one::<OutputFormat>("output_format")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: output_format",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("path") {
                                *path = __clap_arg_matches.remove_one::<PathBuf>("path");
                            }
                            if __clap_arg_matches.contains_id("path_flag") {
                                *path_flag = __clap_arg_matches
                                    .remove_one::<PathBuf>("path_flag");
                            }
                        }
                    }
                    Self::Completions { shell } if "completions" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("shell") {
                                *shell = __clap_arg_matches
                                    .remove_one::<Shell>("shell")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: shell",
                                    ))?;
                            }
                        }
                    }
                    Self::Plugins { command } if "plugins" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            {
                                <PluginCommands as clap::FromArgMatches>::update_from_arg_matches_mut(
                                    command,
                                    __clap_arg_matches,
                                )?;
                            }
                        }
                    }
                    Self::Tui {
                        pattern,
                        algorithm,
                        case_sensitive,
                        mode,
                        context_lines,
                        path,
                    } if "tui" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("pattern") {
                                *pattern = __clap_arg_matches
                                    .remove_one::<String>("pattern");
                            }
                            if __clap_arg_matches.contains_id("algorithm") {
                                *algorithm = __clap_arg_matches
                                    .remove_one::<SearchAlgorithm>("algorithm")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: algorithm",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("case_sensitive") {
                                *case_sensitive = __clap_arg_matches
                                    .remove_one::<bool>("case_sensitive")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: case_sensitive",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("mode") {
                                *mode = __clap_arg_matches
                                    .remove_one::<SearchMode>("mode")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: mode",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("context_lines") {
                                *context_lines = __clap_arg_matches
                                    .remove_one::<usize>("context_lines")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: context_lines",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("path") {
                                *path = __clap_arg_matches
                                    .remove_one::<String>("path")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: path",
                                    ))?;
                            }
                        }
                    }
                    Self::Worker { path, pattern } if "worker" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("path") {
                                *path = __clap_arg_matches
                                    .remove_one::<std::path::PathBuf>("path")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: path",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("pattern") {
                                *pattern = __clap_arg_matches
                                    .remove_one::<String>("pattern")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: pattern",
                                    ))?;
                            }
                        }
                    }
                    s => {
                        *s = <Self as clap::FromArgMatches>::from_arg_matches_mut(
                            __clap_arg_matches,
                        )?;
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::Subcommand for Commands {
        fn augment_subcommands<'b>(__clap_app: clap::Command) -> clap::Command {
            let __clap_app = __clap_app;
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("simulate");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Simulate")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 0usize] = [];
                                        members
                                    }),
                            );
                        __clap_subcommand
                            .about(
                                "Run simulations and performance benchmarks to evaluate the current implementation",
                            )
                            .long_about(None)
                            .after_help(
                                r#"
SIMULATIONS:
  Run built-in benchmark scenarios over a test corpus to evaluate performance and limitations.

EXAMPLES:
  # Run simulations in the current directory (uses bench_data if present)
  rfgrep simulate

  # Run simulations from a specific path
  rfgrep simulate --path .
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("search");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Search")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 22usize] = [
                                            clap::Id::from("pattern"),
                                            clap::Id::from("mode"),
                                            clap::Id::from("copy"),
                                            clap::Id::from("output_format"),
                                            clap::Id::from("ndjson"),
                                            clap::Id::from("extensions"),
                                            clap::Id::from("file_types"),
                                            clap::Id::from("include_extensions"),
                                            clap::Id::from("exclude_extensions"),
                                            clap::Id::from("search_all_files"),
                                            clap::Id::from("text_only"),
                                            clap::Id::from("recursive"),
                                            clap::Id::from("context_lines"),
                                            clap::Id::from("case_sensitive"),
                                            clap::Id::from("invert_match"),
                                            clap::Id::from("timeout_per_file"),
                                            clap::Id::from("max_matches"),
                                            clap::Id::from("algorithm"),
                                            clap::Id::from("count"),
                                            clap::Id::from("files_with_matches"),
                                            clap::Id::from("path"),
                                            clap::Id::from("path_flag"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("mode")
                                    .value_name("MODE")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchMode,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("mode")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: SearchMode = SearchMode::Text;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("copy")
                                    .value_name("COPY")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("copy")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("output_format")
                                    .value_name("OUTPUT_FORMAT")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            OutputFormat,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("output-format")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: OutputFormat = OutputFormat::Text;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("ndjson")
                                    .value_name("NDJSON")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help(
                                        "Emit newline-delimited JSON (one JSON object per match)",
                                    )
                                    .long_help(None)
                                    .long("ndjson")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("extensions")
                                    .value_name("EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg.long("extensions").use_value_delimiter(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("file_types")
                                    .value_name("FILE_TYPES")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            FileTypeStrategy,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("File type handling strategy")
                                    .long_help(None)
                                    .long("file-types")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: FileTypeStrategy = FileTypeStrategy::Default;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("include_extensions")
                                    .value_name("INCLUDE_EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg
                                    .help(
                                        "Include specific file types (overrides default strategy)",
                                    )
                                    .long_help(None)
                                    .long("include-extensions")
                                    .use_value_delimiter(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("exclude_extensions")
                                    .value_name("EXCLUDE_EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg
                                    .help(
                                        "Exclude specific file types (overrides default strategy)",
                                    )
                                    .long_help(None)
                                    .long("exclude-extensions")
                                    .use_value_delimiter(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("search_all_files")
                                    .value_name("SEARCH_ALL_FILES")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help("Search all file types (comprehensive mode)")
                                    .long_help(None)
                                    .long("search-all-files")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("text_only")
                                    .value_name("TEXT_ONLY")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help("Only search text files (conservative mode)")
                                    .long_help(None)
                                    .long("text-only")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("recursive")
                                    .value_name("RECURSIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('r')
                                    .long("recursive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = true;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("context_lines")
                                    .value_name("CONTEXT_LINES")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("context-lines")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: usize = 0;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("case_sensitive")
                                    .value_name("CASE_SENSITIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("case-sensitive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("invert_match")
                                    .value_name("INVERT_MATCH")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("invert-match")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("timeout_per_file")
                                    .value_name("TIMEOUT_PER_FILE")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            u64,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help(
                                        "Per-file timeout in seconds (abort scanning a file after this many seconds)",
                                    )
                                    .long_help(None)
                                    .long("timeout-per-file");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("max_matches")
                                    .value_name("MAX_MATCHES")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("max-matches");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("algorithm")
                                    .value_name("ALGORITHM")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchAlgorithm,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("algorithm")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: SearchAlgorithm = SearchAlgorithm::BoyerMoore;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("count")
                                    .value_name("COUNT")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help(
                                        "Only show count of matches, not the matches themselves",
                                    )
                                    .long_help(None)
                                    .long("count")
                                    .short('c')
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("files_with_matches")
                                    .value_name("FILES_WITH_MATCHES")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help(
                                        "Only show filenames with matches, not the matches themselves",
                                    )
                                    .long_help(None)
                                    .long("files-with-matches")
                                    .short('l')
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.last(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path_flag")
                                    .value_name("PATH_FLAG")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Alternative explicit path flag (useful for scripts)")
                                    .long_help(None)
                                    .long("path-flag")
                                    .alias("path-flag");
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
SEARCH MODES:
  text    - Plain text search (default)
  word    - Whole word matching with boundaries
  regex   - Regular expression search

EXAMPLES:
  # Basic text search
  rfgrep search "error" --extensions rs

  # Word boundary search
  rfgrep search "test" word --recursive

  # Regex search for function definitions
  rfgrep search "fn\s+\w+\s*\(" regex --extensions rs

  # Search and copy results to clipboard
  rfgrep search "TODO" --copy --extensions rs,md

  # Pipe input from another command
  cat file.log | rfgrep search "error"

  # Chain with other tools
  cat .zsh_history | rfgrep search "git" -c

  # Use with command substitution
  echo "test data" | rfgrep search "test"

PERFORMANCE TIPS:
  â¢ Use --skip-binary for faster processing
  â¢ Limit file size with --max-size
  â¢ Use --dry-run to preview files first
  â¢ Pipe data directly for faster processing
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("interactive");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Interactive")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 6usize] = [
                                            clap::Id::from("pattern"),
                                            clap::Id::from("algorithm"),
                                            clap::Id::from("extensions"),
                                            clap::Id::from("recursive"),
                                            clap::Id::from("path"),
                                            clap::Id::from("path_flag"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("algorithm")
                                    .value_name("ALGORITHM")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            InteractiveAlgorithm,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("algorithm")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: InteractiveAlgorithm = InteractiveAlgorithm::BoyerMoore;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("extensions")
                                    .value_name("EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg.long("extensions").use_value_delimiter(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("recursive")
                                    .value_name("RECURSIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('r')
                                    .long("recursive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.last(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path_flag")
                                    .value_name("PATH_FLAG")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Alternative explicit path flag (useful for scripts)")
                                    .long_help(None)
                                    .long("path-flag")
                                    .alias("path-flag");
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
INTERACTIVE FEATURES:
  â¢ Real-time search with live filtering
  â¢ Keyboard navigation and commands
  â¢ Result highlighting and selection
  â¢ Save results to file
  â¢ Memory-optimized processing

COMMANDS:
  n/new   - Start a new search
  f/filter - Filter current results
  c/clear - Clear all filters
  s/save  - Save results to file
  q/quit  - Exit interactive mode

EXAMPLES:
  # Start interactive search
  rfgrep interactive "error" --extensions rs

  # Interactive search with specific algorithm
  rfgrep interactive "test" --algorithm boyer-moore --recursive
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("list");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("List")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 16usize] = [
                                            clap::Id::from("extensions"),
                                            clap::Id::from("long"),
                                            clap::Id::from("recursive"),
                                            clap::Id::from("show_hidden"),
                                            clap::Id::from("max_size"),
                                            clap::Id::from("min_size"),
                                            clap::Id::from("detailed"),
                                            clap::Id::from("simple"),
                                            clap::Id::from("stats"),
                                            clap::Id::from("sort"),
                                            clap::Id::from("reverse"),
                                            clap::Id::from("limit"),
                                            clap::Id::from("copy"),
                                            clap::Id::from("output_format"),
                                            clap::Id::from("path"),
                                            clap::Id::from("path_flag"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("extensions")
                                    .value_name("EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg.long("extensions").use_value_delimiter(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("long")
                                    .value_name("LONG")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('l')
                                    .long("long")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("recursive")
                                    .value_name("RECURSIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('r')
                                    .long("recursive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("show_hidden")
                                    .value_name("SHOW_HIDDEN")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("show-hidden")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("max_size")
                                    .value_name("MAX_SIZE")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("max-size");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("min_size")
                                    .value_name("MIN_SIZE")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("min-size");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("detailed")
                                    .value_name("DETAILED")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("detailed")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("simple")
                                    .value_name("SIMPLE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("simple")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("stats")
                                    .value_name("STATS")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("stats")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("sort")
                                    .value_name("SORT")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SortCriteria,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("sort")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: SortCriteria = SortCriteria::Name;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("reverse")
                                    .value_name("REVERSE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("reverse")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("limit")
                                    .value_name("LIMIT")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("limit");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("copy")
                                    .value_name("COPY")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("copy")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("output_format")
                                    .value_name("OUTPUT_FORMAT")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            OutputFormat,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("output-format")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: OutputFormat = OutputFormat::Text;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.last(true);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path_flag")
                                    .value_name("PATH_FLAG")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Alternative explicit path flag (useful for scripts)")
                                    .long_help(None)
                                    .long("path-flag")
                                    .alias("path-flag");
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
OUTPUT FORMATS:
  Simple  - Just file paths (default)
  Long    - Detailed table with size, type, and binary info

EXAMPLES:
  # Simple file listing
  rfgrep list --extensions rs

  # Detailed listing with size info
  rfgrep list --long --extensions rs,md

  # Recursive listing with hidden files
  rfgrep list --recursive --show-hidden --extensions rs

  # List files under 1MB
  rfgrep list --max-size 1 --extensions rs

FEATURES:
  â¢ Extension statistics and file counts
  â¢ Binary file detection
  â¢ Size filtering and formatting
  â¢ Hidden file handling
  â¢ Recursive directory traversal
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("completions");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Completions")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("shell")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("shell")
                                    .value_name("SHELL")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            Shell,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
SUPPORTED SHELLS:
  bash     - Bash shell completions
  zsh      - Zsh shell completions
  fish     - Fish shell completions
  powershell - PowerShell completions
  elvish   - Elvish shell completions

EXAMPLES:
  # Generate bash completions
  rfgrep completions bash > ~/.local/share/bash-completion/completions/rfgrep

  # Generate zsh completions
  rfgrep completions zsh > ~/.zsh/completions/_rfgrep

  # Generate fish completions
  rfgrep completions fish > ~/.config/fish/completions/rfgrep.fish

SETUP:
  Add the generated completion script to your shell's completion directory
  and restart your shell or source the completion file.
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("plugins");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Plugins")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 0usize] = [];
                                        members
                                    }),
                            );
                        let __clap_subcommand = <PluginCommands as clap::Subcommand>::augment_subcommands(
                            __clap_subcommand,
                        );
                        let __clap_subcommand = __clap_subcommand
                            .subcommand_required(true)
                            .arg_required_else_help(true);
                        __clap_subcommand
                            .after_help(
                                r#"
PLUGIN MANAGEMENT:
  list     - List all available plugins
  stats    - Show plugin statistics
  info     - Show detailed plugin information
  enable   - Enable a plugin
  disable  - Disable a plugin
  priority - Set plugin priority
  config   - Show plugin configuration options
  test     - Test plugin with specific file

EXAMPLES:
  # List all plugins
  rfgrep plugins list

  # Show plugin statistics
  rfgrep plugins stats

  # Get info about text plugin
  rfgrep plugins info enhanced_text

  # Enable binary plugin
  rfgrep plugins enable enhanced_binary

  # Test text plugin on a file
  rfgrep plugins test enhanced_text README.md "example"
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("tui");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Tui")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 6usize] = [
                                            clap::Id::from("pattern"),
                                            clap::Id::from("algorithm"),
                                            clap::Id::from("case_sensitive"),
                                            clap::Id::from("mode"),
                                            clap::Id::from("context_lines"),
                                            clap::Id::from("path"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Search pattern").long_help(None);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("algorithm")
                                    .value_name("ALGORITHM")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchAlgorithm,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Search algorithm to use")
                                    .long_help(None)
                                    .long("algorithm")
                                    .default_value("boyer-moore");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("case_sensitive")
                                    .value_name("CASE_SENSITIVE")
                                    .required(true && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help("Enable case-sensitive search")
                                    .long_help(None)
                                    .long("case-sensitive");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("mode")
                                    .value_name("MODE")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchMode,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Search mode")
                                    .long_help(None)
                                    .long("mode")
                                    .default_value("text");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("context_lines")
                                    .value_name("CONTEXT_LINES")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Number of context lines to show")
                                    .long_help(None)
                                    .long("context-lines")
                                    .default_value("0");
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Search path")
                                    .long_help(None)
                                    .long("path")
                                    .default_value(".");
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .about("Interactive TUI mode")
                            .long_about(None)
                            .after_help(
                                r#"
INTERACTIVE TUI MODE:
  Launch an interactive terminal user interface for searching files.

EXAMPLES:
  # Start TUI with a pattern
  rfgrep tui "search pattern"

  # Start TUI and enter pattern interactively
  rfgrep tui

  # Start TUI with specific algorithm
  rfgrep tui "pattern" --algorithm boyer-moore

  # Start TUI with case-sensitive search
  rfgrep tui "pattern" --case-sensitive

CONTROLS:
  h         - Toggle help
  q         - Quit
  â/â, j/k  - Navigate matches
  â/â, h/l  - Navigate files
  n/N       - Next/Previous match
  c         - Toggle case sensitivity
  m         - Cycle search mode
  a         - Cycle algorithm
  r         - Refresh search
  Enter     - Open file in editor
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("worker");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Worker")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 2usize] = [
                                            clap::Id::from("path"),
                                            clap::Id::from("pattern"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            std::path::PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand.hide(true)
                    }
                });
            __clap_app
        }
        fn augment_subcommands_for_update<'b>(
            __clap_app: clap::Command,
        ) -> clap::Command {
            let __clap_app = __clap_app;
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("simulate");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Simulate")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 0usize] = [];
                                        members
                                    }),
                            );
                        __clap_subcommand
                            .about(
                                "Run simulations and performance benchmarks to evaluate the current implementation",
                            )
                            .long_about(None)
                            .after_help(
                                r#"
SIMULATIONS:
  Run built-in benchmark scenarios over a test corpus to evaluate performance and limitations.

EXAMPLES:
  # Run simulations in the current directory (uses bench_data if present)
  rfgrep simulate

  # Run simulations from a specific path
  rfgrep simulate --path .
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("search");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Search")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 22usize] = [
                                            clap::Id::from("pattern"),
                                            clap::Id::from("mode"),
                                            clap::Id::from("copy"),
                                            clap::Id::from("output_format"),
                                            clap::Id::from("ndjson"),
                                            clap::Id::from("extensions"),
                                            clap::Id::from("file_types"),
                                            clap::Id::from("include_extensions"),
                                            clap::Id::from("exclude_extensions"),
                                            clap::Id::from("search_all_files"),
                                            clap::Id::from("text_only"),
                                            clap::Id::from("recursive"),
                                            clap::Id::from("context_lines"),
                                            clap::Id::from("case_sensitive"),
                                            clap::Id::from("invert_match"),
                                            clap::Id::from("timeout_per_file"),
                                            clap::Id::from("max_matches"),
                                            clap::Id::from("algorithm"),
                                            clap::Id::from("count"),
                                            clap::Id::from("files_with_matches"),
                                            clap::Id::from("path"),
                                            clap::Id::from("path_flag"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("mode")
                                    .value_name("MODE")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchMode,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("mode")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: SearchMode = SearchMode::Text;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("copy")
                                    .value_name("COPY")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("copy")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("output_format")
                                    .value_name("OUTPUT_FORMAT")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            OutputFormat,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("output-format")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: OutputFormat = OutputFormat::Text;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("ndjson")
                                    .value_name("NDJSON")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help(
                                        "Emit newline-delimited JSON (one JSON object per match)",
                                    )
                                    .long_help(None)
                                    .long("ndjson")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("extensions")
                                    .value_name("EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg.long("extensions").use_value_delimiter(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("file_types")
                                    .value_name("FILE_TYPES")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            FileTypeStrategy,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("File type handling strategy")
                                    .long_help(None)
                                    .long("file-types")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: FileTypeStrategy = FileTypeStrategy::Default;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("include_extensions")
                                    .value_name("INCLUDE_EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg
                                    .help(
                                        "Include specific file types (overrides default strategy)",
                                    )
                                    .long_help(None)
                                    .long("include-extensions")
                                    .use_value_delimiter(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("exclude_extensions")
                                    .value_name("EXCLUDE_EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg
                                    .help(
                                        "Exclude specific file types (overrides default strategy)",
                                    )
                                    .long_help(None)
                                    .long("exclude-extensions")
                                    .use_value_delimiter(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("search_all_files")
                                    .value_name("SEARCH_ALL_FILES")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help("Search all file types (comprehensive mode)")
                                    .long_help(None)
                                    .long("search-all-files")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("text_only")
                                    .value_name("TEXT_ONLY")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help("Only search text files (conservative mode)")
                                    .long_help(None)
                                    .long("text-only")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("recursive")
                                    .value_name("RECURSIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('r')
                                    .long("recursive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = true;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("context_lines")
                                    .value_name("CONTEXT_LINES")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("context-lines")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: usize = 0;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("case_sensitive")
                                    .value_name("CASE_SENSITIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("case-sensitive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("invert_match")
                                    .value_name("INVERT_MATCH")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("invert-match")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("timeout_per_file")
                                    .value_name("TIMEOUT_PER_FILE")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            u64,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help(
                                        "Per-file timeout in seconds (abort scanning a file after this many seconds)",
                                    )
                                    .long_help(None)
                                    .long("timeout-per-file");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("max_matches")
                                    .value_name("MAX_MATCHES")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("max-matches");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("algorithm")
                                    .value_name("ALGORITHM")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchAlgorithm,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("algorithm")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: SearchAlgorithm = SearchAlgorithm::BoyerMoore;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("count")
                                    .value_name("COUNT")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help(
                                        "Only show count of matches, not the matches themselves",
                                    )
                                    .long_help(None)
                                    .long("count")
                                    .short('c')
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("files_with_matches")
                                    .value_name("FILES_WITH_MATCHES")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help(
                                        "Only show filenames with matches, not the matches themselves",
                                    )
                                    .long_help(None)
                                    .long("files-with-matches")
                                    .short('l')
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.last(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path_flag")
                                    .value_name("PATH_FLAG")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Alternative explicit path flag (useful for scripts)")
                                    .long_help(None)
                                    .long("path-flag")
                                    .alias("path-flag");
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
SEARCH MODES:
  text    - Plain text search (default)
  word    - Whole word matching with boundaries
  regex   - Regular expression search

EXAMPLES:
  # Basic text search
  rfgrep search "error" --extensions rs

  # Word boundary search
  rfgrep search "test" word --recursive

  # Regex search for function definitions
  rfgrep search "fn\s+\w+\s*\(" regex --extensions rs

  # Search and copy results to clipboard
  rfgrep search "TODO" --copy --extensions rs,md

  # Pipe input from another command
  cat file.log | rfgrep search "error"

  # Chain with other tools
  cat .zsh_history | rfgrep search "git" -c

  # Use with command substitution
  echo "test data" | rfgrep search "test"

PERFORMANCE TIPS:
  â¢ Use --skip-binary for faster processing
  â¢ Limit file size with --max-size
  â¢ Use --dry-run to preview files first
  â¢ Pipe data directly for faster processing
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("interactive");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Interactive")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 6usize] = [
                                            clap::Id::from("pattern"),
                                            clap::Id::from("algorithm"),
                                            clap::Id::from("extensions"),
                                            clap::Id::from("recursive"),
                                            clap::Id::from("path"),
                                            clap::Id::from("path_flag"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("algorithm")
                                    .value_name("ALGORITHM")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            InteractiveAlgorithm,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("algorithm")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: InteractiveAlgorithm = InteractiveAlgorithm::BoyerMoore;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("extensions")
                                    .value_name("EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg.long("extensions").use_value_delimiter(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("recursive")
                                    .value_name("RECURSIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('r')
                                    .long("recursive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.last(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path_flag")
                                    .value_name("PATH_FLAG")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Alternative explicit path flag (useful for scripts)")
                                    .long_help(None)
                                    .long("path-flag")
                                    .alias("path-flag");
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
INTERACTIVE FEATURES:
  â¢ Real-time search with live filtering
  â¢ Keyboard navigation and commands
  â¢ Result highlighting and selection
  â¢ Save results to file
  â¢ Memory-optimized processing

COMMANDS:
  n/new   - Start a new search
  f/filter - Filter current results
  c/clear - Clear all filters
  s/save  - Save results to file
  q/quit  - Exit interactive mode

EXAMPLES:
  # Start interactive search
  rfgrep interactive "error" --extensions rs

  # Interactive search with specific algorithm
  rfgrep interactive "test" --algorithm boyer-moore --recursive
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("list");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("List")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 16usize] = [
                                            clap::Id::from("extensions"),
                                            clap::Id::from("long"),
                                            clap::Id::from("recursive"),
                                            clap::Id::from("show_hidden"),
                                            clap::Id::from("max_size"),
                                            clap::Id::from("min_size"),
                                            clap::Id::from("detailed"),
                                            clap::Id::from("simple"),
                                            clap::Id::from("stats"),
                                            clap::Id::from("sort"),
                                            clap::Id::from("reverse"),
                                            clap::Id::from("limit"),
                                            clap::Id::from("copy"),
                                            clap::Id::from("output_format"),
                                            clap::Id::from("path"),
                                            clap::Id::from("path_flag"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("extensions")
                                    .value_name("EXTENSIONS")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Append);
                                let arg = arg.long("extensions").use_value_delimiter(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("long")
                                    .value_name("LONG")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('l')
                                    .long("long")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("recursive")
                                    .value_name("RECURSIVE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .short('r')
                                    .long("recursive")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("show_hidden")
                                    .value_name("SHOW_HIDDEN")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("show-hidden")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("max_size")
                                    .value_name("MAX_SIZE")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("max-size");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("min_size")
                                    .value_name("MIN_SIZE")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("min-size");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("detailed")
                                    .value_name("DETAILED")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("detailed")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("simple")
                                    .value_name("SIMPLE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("simple")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("stats")
                                    .value_name("STATS")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("stats")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("sort")
                                    .value_name("SORT")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SortCriteria,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("sort")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: SortCriteria = SortCriteria::Name;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("reverse")
                                    .value_name("REVERSE")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("reverse")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("limit")
                                    .value_name("LIMIT")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.long("limit");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("copy")
                                    .value_name("COPY")
                                    .required(false && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .long("copy")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: bool = false;
                                                ::std::string::ToString::to_string(&val)
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("output_format")
                                    .value_name("OUTPUT_FORMAT")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            OutputFormat,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .long("output-format")
                                    .default_value({
                                        static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                                        let s = DEFAULT_VALUE
                                            .get_or_init(|| {
                                                let val: OutputFormat = OutputFormat::Text;
                                                clap::ValueEnum::to_possible_value(&val)
                                                    .unwrap()
                                                    .get_name()
                                                    .to_owned()
                                            });
                                        let s: &'static str = &*s;
                                        s
                                    });
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.last(true);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path_flag")
                                    .value_name("PATH_FLAG")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Alternative explicit path flag (useful for scripts)")
                                    .long_help(None)
                                    .long("path-flag")
                                    .alias("path-flag");
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
OUTPUT FORMATS:
  Simple  - Just file paths (default)
  Long    - Detailed table with size, type, and binary info

EXAMPLES:
  # Simple file listing
  rfgrep list --extensions rs

  # Detailed listing with size info
  rfgrep list --long --extensions rs,md

  # Recursive listing with hidden files
  rfgrep list --recursive --show-hidden --extensions rs

  # List files under 1MB
  rfgrep list --max-size 1 --extensions rs

FEATURES:
  â¢ Extension statistics and file counts
  â¢ Binary file detection
  â¢ Size filtering and formatting
  â¢ Hidden file handling
  â¢ Recursive directory traversal
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("completions");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Completions")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("shell")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("shell")
                                    .value_name("SHELL")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            Shell,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .after_help(
                                r#"
SUPPORTED SHELLS:
  bash     - Bash shell completions
  zsh      - Zsh shell completions
  fish     - Fish shell completions
  powershell - PowerShell completions
  elvish   - Elvish shell completions

EXAMPLES:
  # Generate bash completions
  rfgrep completions bash > ~/.local/share/bash-completion/completions/rfgrep

  # Generate zsh completions
  rfgrep completions zsh > ~/.zsh/completions/_rfgrep

  # Generate fish completions
  rfgrep completions fish > ~/.config/fish/completions/rfgrep.fish

SETUP:
  Add the generated completion script to your shell's completion directory
  and restart your shell or source the completion file.
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("plugins");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Plugins")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 0usize] = [];
                                        members
                                    }),
                            );
                        let __clap_subcommand = <PluginCommands as clap::Subcommand>::augment_subcommands(
                            __clap_subcommand,
                        );
                        let __clap_subcommand = __clap_subcommand
                            .subcommand_required(true)
                            .arg_required_else_help(true)
                            .subcommand_required(false)
                            .arg_required_else_help(false);
                        __clap_subcommand
                            .after_help(
                                r#"
PLUGIN MANAGEMENT:
  list     - List all available plugins
  stats    - Show plugin statistics
  info     - Show detailed plugin information
  enable   - Enable a plugin
  disable  - Disable a plugin
  priority - Set plugin priority
  config   - Show plugin configuration options
  test     - Test plugin with specific file

EXAMPLES:
  # List all plugins
  rfgrep plugins list

  # Show plugin statistics
  rfgrep plugins stats

  # Get info about text plugin
  rfgrep plugins info enhanced_text

  # Enable binary plugin
  rfgrep plugins enable enhanced_binary

  # Test text plugin on a file
  rfgrep plugins test enhanced_text README.md "example"
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("tui");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Tui")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 6usize] = [
                                            clap::Id::from("pattern"),
                                            clap::Id::from("algorithm"),
                                            clap::Id::from("case_sensitive"),
                                            clap::Id::from("mode"),
                                            clap::Id::from("context_lines"),
                                            clap::Id::from("path"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Search pattern").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("algorithm")
                                    .value_name("ALGORITHM")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchAlgorithm,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Search algorithm to use")
                                    .long_help(None)
                                    .long("algorithm")
                                    .default_value("boyer-moore");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("case_sensitive")
                                    .value_name("CASE_SENSITIVE")
                                    .required(true && clap::ArgAction::SetTrue.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            bool,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::SetTrue);
                                let arg = arg
                                    .help("Enable case-sensitive search")
                                    .long_help(None)
                                    .long("case-sensitive");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("mode")
                                    .value_name("MODE")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            SearchMode,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Search mode")
                                    .long_help(None)
                                    .long("mode")
                                    .default_value("text");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("context_lines")
                                    .value_name("CONTEXT_LINES")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            usize,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Number of context lines to show")
                                    .long_help(None)
                                    .long("context-lines")
                                    .default_value("0");
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .required(false && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Search path")
                                    .long_help(None)
                                    .long("path")
                                    .default_value(".");
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .about("Interactive TUI mode")
                            .long_about(None)
                            .after_help(
                                r#"
INTERACTIVE TUI MODE:
  Launch an interactive terminal user interface for searching files.

EXAMPLES:
  # Start TUI with a pattern
  rfgrep tui "search pattern"

  # Start TUI and enter pattern interactively
  rfgrep tui

  # Start TUI with specific algorithm
  rfgrep tui "pattern" --algorithm boyer-moore

  # Start TUI with case-sensitive search
  rfgrep tui "pattern" --case-sensitive

CONTROLS:
  h         - Toggle help
  q         - Quit
  â/â, j/k  - Navigate matches
  â/â, h/l  - Navigate files
  n/N       - Next/Previous match
  c         - Toggle case sensitivity
  m         - Cycle search mode
  a         - Cycle algorithm
  r         - Refresh search
  Enter     - Open file in editor
"#,
                            )
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("worker");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Worker")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 2usize] = [
                                            clap::Id::from("path"),
                                            clap::Id::from("pattern"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("path")
                                    .value_name("PATH")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            std::path::PathBuf,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg;
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand.hide(true)
                    }
                });
            __clap_app
        }
        fn has_subcommand(__clap_name: &str) -> bool {
            if "simulate" == __clap_name {
                return true;
            }
            if "search" == __clap_name {
                return true;
            }
            if "interactive" == __clap_name {
                return true;
            }
            if "list" == __clap_name {
                return true;
            }
            if "completions" == __clap_name {
                return true;
            }
            if "plugins" == __clap_name {
                return true;
            }
            if "tui" == __clap_name {
                return true;
            }
            if "worker" == __clap_name {
                return true;
            }
            false
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Commands {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Commands::Simulate {} => ::core::fmt::Formatter::write_str(f, "Simulate"),
                Commands::Search {
                    pattern: __self_0,
                    mode: __self_1,
                    copy: __self_2,
                    output_format: __self_3,
                    ndjson: __self_4,
                    extensions: __self_5,
                    file_types: __self_6,
                    include_extensions: __self_7,
                    exclude_extensions: __self_8,
                    search_all_files: __self_9,
                    text_only: __self_10,
                    recursive: __self_11,
                    context_lines: __self_12,
                    case_sensitive: __self_13,
                    invert_match: __self_14,
                    timeout_per_file: __self_15,
                    max_matches: __self_16,
                    algorithm: __self_17,
                    count: __self_18,
                    files_with_matches: __self_19,
                    path: __self_20,
                    path_flag: __self_21,
                } => {
                    let names: &'static _ = &[
                        "pattern",
                        "mode",
                        "copy",
                        "output_format",
                        "ndjson",
                        "extensions",
                        "file_types",
                        "include_extensions",
                        "exclude_extensions",
                        "search_all_files",
                        "text_only",
                        "recursive",
                        "context_lines",
                        "case_sensitive",
                        "invert_match",
                        "timeout_per_file",
                        "max_matches",
                        "algorithm",
                        "count",
                        "files_with_matches",
                        "path",
                        "path_flag",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        __self_0,
                        __self_1,
                        __self_2,
                        __self_3,
                        __self_4,
                        __self_5,
                        __self_6,
                        __self_7,
                        __self_8,
                        __self_9,
                        __self_10,
                        __self_11,
                        __self_12,
                        __self_13,
                        __self_14,
                        __self_15,
                        __self_16,
                        __self_17,
                        __self_18,
                        __self_19,
                        __self_20,
                        &__self_21,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Search",
                        names,
                        values,
                    )
                }
                Commands::Interactive {
                    pattern: __self_0,
                    algorithm: __self_1,
                    extensions: __self_2,
                    recursive: __self_3,
                    path: __self_4,
                    path_flag: __self_5,
                } => {
                    let names: &'static _ = &[
                        "pattern",
                        "algorithm",
                        "extensions",
                        "recursive",
                        "path",
                        "path_flag",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        __self_0,
                        __self_1,
                        __self_2,
                        __self_3,
                        __self_4,
                        &__self_5,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Interactive",
                        names,
                        values,
                    )
                }
                Commands::List {
                    extensions: __self_0,
                    long: __self_1,
                    recursive: __self_2,
                    show_hidden: __self_3,
                    max_size: __self_4,
                    min_size: __self_5,
                    detailed: __self_6,
                    simple: __self_7,
                    stats: __self_8,
                    sort: __self_9,
                    reverse: __self_10,
                    limit: __self_11,
                    copy: __self_12,
                    output_format: __self_13,
                    path: __self_14,
                    path_flag: __self_15,
                } => {
                    let names: &'static _ = &[
                        "extensions",
                        "long",
                        "recursive",
                        "show_hidden",
                        "max_size",
                        "min_size",
                        "detailed",
                        "simple",
                        "stats",
                        "sort",
                        "reverse",
                        "limit",
                        "copy",
                        "output_format",
                        "path",
                        "path_flag",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        __self_0,
                        __self_1,
                        __self_2,
                        __self_3,
                        __self_4,
                        __self_5,
                        __self_6,
                        __self_7,
                        __self_8,
                        __self_9,
                        __self_10,
                        __self_11,
                        __self_12,
                        __self_13,
                        __self_14,
                        &__self_15,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "List",
                        names,
                        values,
                    )
                }
                Commands::Completions { shell: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Completions",
                        "shell",
                        &__self_0,
                    )
                }
                Commands::Plugins { command: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Plugins",
                        "command",
                        &__self_0,
                    )
                }
                Commands::Tui {
                    pattern: __self_0,
                    algorithm: __self_1,
                    case_sensitive: __self_2,
                    mode: __self_3,
                    context_lines: __self_4,
                    path: __self_5,
                } => {
                    let names: &'static _ = &[
                        "pattern",
                        "algorithm",
                        "case_sensitive",
                        "mode",
                        "context_lines",
                        "path",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        __self_0,
                        __self_1,
                        __self_2,
                        __self_3,
                        __self_4,
                        &__self_5,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Tui",
                        names,
                        values,
                    )
                }
                Commands::Worker { path: __self_0, pattern: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Worker",
                        "path",
                        __self_0,
                        "pattern",
                        &__self_1,
                    )
                }
            }
        }
    }
    pub enum PluginCommands {
        /// List all available plugins
        List,
        /// Show plugin statistics
        Stats,
        /// Show detailed plugin information
        Info {
            /// Plugin name
            name: String,
        },
        /// Enable a plugin
        Enable {
            /// Plugin name
            name: String,
        },
        /// Disable a plugin
        Disable {
            /// Plugin name
            name: String,
        },
        /// Set plugin priority
        Priority {
            /// Plugin name
            name: String,
            /// Priority value (lower = higher priority)
            priority: u32,
        },
        /// Show plugin configuration options
        Config {
            /// Plugin name
            name: String,
        },
        /// Test plugin with specific file
        Test {
            /// Plugin name
            name: String,
            /// File path to test
            file: String,
            /// Search pattern
            pattern: String,
        },
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::FromArgMatches for PluginCommands {
        fn from_arg_matches(
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn from_arg_matches_mut(
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<Self, clap::Error> {
            #![allow(deprecated)]
            if let Some((__clap_name, mut __clap_arg_sub_matches)) = __clap_arg_matches
                .remove_subcommand()
            {
                let __clap_arg_matches = &mut __clap_arg_sub_matches;
                if __clap_name == "list" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::List);
                }
                if __clap_name == "stats" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Stats);
                }
                if __clap_name == "info" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Info {
                        name: __clap_arg_matches
                            .remove_one::<String>("name")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: name",
                            ))?,
                    });
                }
                if __clap_name == "enable" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Enable {
                        name: __clap_arg_matches
                            .remove_one::<String>("name")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: name",
                            ))?,
                    });
                }
                if __clap_name == "disable" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Disable {
                        name: __clap_arg_matches
                            .remove_one::<String>("name")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: name",
                            ))?,
                    });
                }
                if __clap_name == "priority" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Priority {
                        name: __clap_arg_matches
                            .remove_one::<String>("name")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: name",
                            ))?,
                        priority: __clap_arg_matches
                            .remove_one::<u32>("priority")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: priority",
                            ))?,
                    });
                }
                if __clap_name == "config" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Config {
                        name: __clap_arg_matches
                            .remove_one::<String>("name")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: name",
                            ))?,
                    });
                }
                if __clap_name == "test" && !__clap_arg_matches.contains_id("") {
                    return ::std::result::Result::Ok(Self::Test {
                        name: __clap_arg_matches
                            .remove_one::<String>("name")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: name",
                            ))?,
                        file: __clap_arg_matches
                            .remove_one::<String>("file")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: file",
                            ))?,
                        pattern: __clap_arg_matches
                            .remove_one::<String>("pattern")
                            .ok_or_else(|| clap::Error::raw(
                                clap::error::ErrorKind::MissingRequiredArgument,
                                "the following required argument was not provided: pattern",
                            ))?,
                    });
                }
                ::std::result::Result::Err(
                    clap::Error::raw(
                        clap::error::ErrorKind::InvalidSubcommand,
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "the subcommand \'{0}\' wasn\'t recognized",
                                    __clap_name,
                                ),
                            )
                        }),
                    ),
                )
            } else {
                ::std::result::Result::Err(
                    clap::Error::raw(
                        clap::error::ErrorKind::MissingSubcommand,
                        "a subcommand is required but one was not provided",
                    ),
                )
            }
        }
        fn update_from_arg_matches(
            &mut self,
            __clap_arg_matches: &clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn update_from_arg_matches_mut<'b>(
            &mut self,
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            #![allow(deprecated)]
            if let Some(__clap_name) = __clap_arg_matches.subcommand_name() {
                match self {
                    Self::List if "list" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {}
                    }
                    Self::Stats if "stats" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {}
                    }
                    Self::Info { name } if "info" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("name") {
                                *name = __clap_arg_matches
                                    .remove_one::<String>("name")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: name",
                                    ))?;
                            }
                        }
                    }
                    Self::Enable { name } if "enable" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("name") {
                                *name = __clap_arg_matches
                                    .remove_one::<String>("name")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: name",
                                    ))?;
                            }
                        }
                    }
                    Self::Disable { name } if "disable" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("name") {
                                *name = __clap_arg_matches
                                    .remove_one::<String>("name")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: name",
                                    ))?;
                            }
                        }
                    }
                    Self::Priority { name, priority } if "priority" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("name") {
                                *name = __clap_arg_matches
                                    .remove_one::<String>("name")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: name",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("priority") {
                                *priority = __clap_arg_matches
                                    .remove_one::<u32>("priority")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: priority",
                                    ))?;
                            }
                        }
                    }
                    Self::Config { name } if "config" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("name") {
                                *name = __clap_arg_matches
                                    .remove_one::<String>("name")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: name",
                                    ))?;
                            }
                        }
                    }
                    Self::Test { name, file, pattern } if "test" == __clap_name => {
                        let (_, mut __clap_arg_sub_matches) = __clap_arg_matches
                            .remove_subcommand()
                            .unwrap();
                        let __clap_arg_matches = &mut __clap_arg_sub_matches;
                        {
                            if __clap_arg_matches.contains_id("name") {
                                *name = __clap_arg_matches
                                    .remove_one::<String>("name")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: name",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("file") {
                                *file = __clap_arg_matches
                                    .remove_one::<String>("file")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: file",
                                    ))?;
                            }
                            if __clap_arg_matches.contains_id("pattern") {
                                *pattern = __clap_arg_matches
                                    .remove_one::<String>("pattern")
                                    .ok_or_else(|| clap::Error::raw(
                                        clap::error::ErrorKind::MissingRequiredArgument,
                                        "the following required argument was not provided: pattern",
                                    ))?;
                            }
                        }
                    }
                    s => {
                        *s = <Self as clap::FromArgMatches>::from_arg_matches_mut(
                            __clap_arg_matches,
                        )?;
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::Subcommand for PluginCommands {
        fn augment_subcommands<'b>(__clap_app: clap::Command) -> clap::Command {
            let __clap_app = __clap_app;
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("list");
                    let __clap_subcommand = __clap_subcommand;
                    let __clap_subcommand = __clap_subcommand;
                    __clap_subcommand
                        .about("List all available plugins")
                        .long_about(None)
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("stats");
                    let __clap_subcommand = __clap_subcommand;
                    let __clap_subcommand = __clap_subcommand;
                    __clap_subcommand.about("Show plugin statistics").long_about(None)
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("info");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Info")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .about("Show detailed plugin information")
                            .long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("enable");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Enable")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand.about("Enable a plugin").long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("disable");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Disable")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand.about("Disable a plugin").long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("priority");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Priority")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 2usize] = [
                                            clap::Id::from("name"),
                                            clap::Id::from("priority"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("priority")
                                    .value_name("PRIORITY")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            u32,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Priority value (lower = higher priority)")
                                    .long_help(None);
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand.about("Set plugin priority").long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("config");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Config")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .about("Show plugin configuration options")
                            .long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("test");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Test")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 3usize] = [
                                            clap::Id::from("name"),
                                            clap::Id::from("file"),
                                            clap::Id::from("pattern"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("file")
                                    .value_name("FILE")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("File path to test").long_help(None);
                                let arg = arg;
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Search pattern").long_help(None);
                                let arg = arg;
                                arg
                            });
                        __clap_subcommand
                            .about("Test plugin with specific file")
                            .long_about(None)
                    }
                });
            __clap_app
        }
        fn augment_subcommands_for_update<'b>(
            __clap_app: clap::Command,
        ) -> clap::Command {
            let __clap_app = __clap_app;
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("list");
                    let __clap_subcommand = __clap_subcommand;
                    let __clap_subcommand = __clap_subcommand;
                    __clap_subcommand
                        .about("List all available plugins")
                        .long_about(None)
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("stats");
                    let __clap_subcommand = __clap_subcommand;
                    let __clap_subcommand = __clap_subcommand;
                    __clap_subcommand.about("Show plugin statistics").long_about(None)
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("info");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Info")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .about("Show detailed plugin information")
                            .long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("enable");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Enable")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand.about("Enable a plugin").long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("disable");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Disable")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand.about("Disable a plugin").long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("priority");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Priority")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 2usize] = [
                                            clap::Id::from("name"),
                                            clap::Id::from("priority"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("priority")
                                    .value_name("PRIORITY")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            u32,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg
                                    .help("Priority value (lower = higher priority)")
                                    .long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand.about("Set plugin priority").long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("config");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Config")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 1usize] = [clap::Id::from("name")];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .about("Show plugin configuration options")
                            .long_about(None)
                    }
                });
            let __clap_app = __clap_app
                .subcommand({
                    let __clap_subcommand = clap::Command::new("test");
                    {
                        let __clap_subcommand = __clap_subcommand
                            .group(
                                clap::ArgGroup::new("Test")
                                    .multiple(true)
                                    .args({
                                        let members: [clap::Id; 3usize] = [
                                            clap::Id::from("name"),
                                            clap::Id::from("file"),
                                            clap::Id::from("pattern"),
                                        ];
                                        members
                                    }),
                            );
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("name")
                                    .value_name("NAME")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Plugin name").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("file")
                                    .value_name("FILE")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("File path to test").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        let __clap_subcommand = __clap_subcommand
                            .arg({
                                #[allow(deprecated)]
                                let arg = clap::Arg::new("pattern")
                                    .value_name("PATTERN")
                                    .required(true && clap::ArgAction::Set.takes_values())
                                    .value_parser({
                                        use ::clap_builder::builder::impl_prelude::*;
                                        let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                            String,
                                        >::new();
                                        (&&&&&&auto).value_parser()
                                    })
                                    .action(clap::ArgAction::Set);
                                let arg = arg.help("Search pattern").long_help(None);
                                let arg = arg.required(false);
                                arg
                            });
                        __clap_subcommand
                            .about("Test plugin with specific file")
                            .long_about(None)
                    }
                });
            __clap_app
        }
        fn has_subcommand(__clap_name: &str) -> bool {
            if "list" == __clap_name {
                return true;
            }
            if "stats" == __clap_name {
                return true;
            }
            if "info" == __clap_name {
                return true;
            }
            if "enable" == __clap_name {
                return true;
            }
            if "disable" == __clap_name {
                return true;
            }
            if "priority" == __clap_name {
                return true;
            }
            if "config" == __clap_name {
                return true;
            }
            if "test" == __clap_name {
                return true;
            }
            false
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PluginCommands {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                PluginCommands::List => ::core::fmt::Formatter::write_str(f, "List"),
                PluginCommands::Stats => ::core::fmt::Formatter::write_str(f, "Stats"),
                PluginCommands::Info { name: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Info",
                        "name",
                        &__self_0,
                    )
                }
                PluginCommands::Enable { name: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Enable",
                        "name",
                        &__self_0,
                    )
                }
                PluginCommands::Disable { name: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Disable",
                        "name",
                        &__self_0,
                    )
                }
                PluginCommands::Priority { name: __self_0, priority: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Priority",
                        "name",
                        __self_0,
                        "priority",
                        &__self_1,
                    )
                }
                PluginCommands::Config { name: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Config",
                        "name",
                        &__self_0,
                    )
                }
                PluginCommands::Test {
                    name: __self_0,
                    file: __self_1,
                    pattern: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Test",
                        "name",
                        __self_0,
                        "file",
                        __self_1,
                        "pattern",
                        &__self_2,
                    )
                }
            }
        }
    }
    pub enum SearchMode {
        #[default]
        Text,
        Word,
        Regex,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for SearchMode {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Text, Self::Word, Self::Regex]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::Text => Some({ clap::builder::PossibleValue::new("text") }),
                Self::Word => Some({ clap::builder::PossibleValue::new("word") }),
                Self::Regex => Some({ clap::builder::PossibleValue::new("regex") }),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchMode {
        #[inline]
        fn clone(&self) -> SearchMode {
            match self {
                SearchMode::Text => SearchMode::Text,
                SearchMode::Word => SearchMode::Word,
                SearchMode::Regex => SearchMode::Regex,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SearchMode::Text => "Text",
                    SearchMode::Word => "Word",
                    SearchMode::Regex => "Regex",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for SearchMode {
        #[inline]
        fn default() -> SearchMode {
            Self::Text
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SearchMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SearchMode {
        #[inline]
        fn eq(&self, other: &SearchMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for SearchMode {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SearchMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SearchMode::Text => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchMode",
                            0u32,
                            "Text",
                        )
                    }
                    SearchMode::Word => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchMode",
                            1u32,
                            "Word",
                        )
                    }
                    SearchMode::Regex => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchMode",
                            2u32,
                            "Regex",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SearchMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Text" => _serde::__private228::Ok(__Field::__field0),
                            "Word" => _serde::__private228::Ok(__Field::__field1),
                            "Regex" => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Text" => _serde::__private228::Ok(__Field::__field0),
                            b"Word" => _serde::__private228::Ok(__Field::__field1),
                            b"Regex" => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<SearchMode>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SearchMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum SearchMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchMode::Text)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchMode::Word)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchMode::Regex)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Text", "Word", "Regex"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SearchMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<SearchMode>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    pub enum FileTypeStrategy {
        #[default]
        /// Default behavior - smart classification (recommended)
        Default,
        /// Search everything possible (comprehensive)
        Comprehensive,
        /// Only search safe text files (conservative)
        Conservative,
        /// Performance-first - skip potentially problematic files
        Performance,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for FileTypeStrategy {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Default, Self::Comprehensive, Self::Conservative, Self::Performance]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::Default => {
                    Some({
                        clap::builder::PossibleValue::new("default")
                            .help(
                                "Default behavior - smart classification (recommended)",
                            )
                    })
                }
                Self::Comprehensive => {
                    Some({
                        clap::builder::PossibleValue::new("comprehensive")
                            .help("Search everything possible (comprehensive)")
                    })
                }
                Self::Conservative => {
                    Some({
                        clap::builder::PossibleValue::new("conservative")
                            .help("Only search safe text files (conservative)")
                    })
                }
                Self::Performance => {
                    Some({
                        clap::builder::PossibleValue::new("performance")
                            .help(
                                "Performance-first - skip potentially problematic files",
                            )
                    })
                }
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FileTypeStrategy {
        #[inline]
        fn clone(&self) -> FileTypeStrategy {
            match self {
                FileTypeStrategy::Default => FileTypeStrategy::Default,
                FileTypeStrategy::Comprehensive => FileTypeStrategy::Comprehensive,
                FileTypeStrategy::Conservative => FileTypeStrategy::Conservative,
                FileTypeStrategy::Performance => FileTypeStrategy::Performance,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FileTypeStrategy {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FileTypeStrategy::Default => "Default",
                    FileTypeStrategy::Comprehensive => "Comprehensive",
                    FileTypeStrategy::Conservative => "Conservative",
                    FileTypeStrategy::Performance => "Performance",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FileTypeStrategy {
        #[inline]
        fn default() -> FileTypeStrategy {
            Self::Default
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FileTypeStrategy {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FileTypeStrategy {
        #[inline]
        fn eq(&self, other: &FileTypeStrategy) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for FileTypeStrategy {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FileTypeStrategy {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FileTypeStrategy::Default => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileTypeStrategy",
                            0u32,
                            "Default",
                        )
                    }
                    FileTypeStrategy::Comprehensive => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileTypeStrategy",
                            1u32,
                            "Comprehensive",
                        )
                    }
                    FileTypeStrategy::Conservative => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileTypeStrategy",
                            2u32,
                            "Conservative",
                        )
                    }
                    FileTypeStrategy::Performance => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileTypeStrategy",
                            3u32,
                            "Performance",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FileTypeStrategy {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Default" => _serde::__private228::Ok(__Field::__field0),
                            "Comprehensive" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            "Conservative" => _serde::__private228::Ok(__Field::__field2),
                            "Performance" => _serde::__private228::Ok(__Field::__field3),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Default" => _serde::__private228::Ok(__Field::__field0),
                            b"Comprehensive" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            b"Conservative" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            b"Performance" => _serde::__private228::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<FileTypeStrategy>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FileTypeStrategy;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum FileTypeStrategy",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(FileTypeStrategy::Default)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(FileTypeStrategy::Comprehensive)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(FileTypeStrategy::Conservative)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(FileTypeStrategy::Performance)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Default",
                    "Comprehensive",
                    "Conservative",
                    "Performance",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FileTypeStrategy",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<FileTypeStrategy>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    pub enum SafetyPolicy {
        #[default]
        /// Default safety policy - balanced approach
        Default,
        /// Conservative safety - strict file type checking and size limits
        Conservative,
        /// Performance mode - relaxed safety for speed
        Performance,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for SafetyPolicy {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Default, Self::Conservative, Self::Performance]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::Default => {
                    Some({
                        clap::builder::PossibleValue::new("default")
                            .help("Default safety policy - balanced approach")
                    })
                }
                Self::Conservative => {
                    Some({
                        clap::builder::PossibleValue::new("conservative")
                            .help(
                                "Conservative safety - strict file type checking and size limits",
                            )
                    })
                }
                Self::Performance => {
                    Some({
                        clap::builder::PossibleValue::new("performance")
                            .help("Performance mode - relaxed safety for speed")
                    })
                }
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SafetyPolicy {
        #[inline]
        fn clone(&self) -> SafetyPolicy {
            match self {
                SafetyPolicy::Default => SafetyPolicy::Default,
                SafetyPolicy::Conservative => SafetyPolicy::Conservative,
                SafetyPolicy::Performance => SafetyPolicy::Performance,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SafetyPolicy {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SafetyPolicy::Default => "Default",
                    SafetyPolicy::Conservative => "Conservative",
                    SafetyPolicy::Performance => "Performance",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for SafetyPolicy {
        #[inline]
        fn default() -> SafetyPolicy {
            Self::Default
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SafetyPolicy {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SafetyPolicy {
        #[inline]
        fn eq(&self, other: &SafetyPolicy) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for SafetyPolicy {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SafetyPolicy {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SafetyPolicy::Default => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SafetyPolicy",
                            0u32,
                            "Default",
                        )
                    }
                    SafetyPolicy::Conservative => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SafetyPolicy",
                            1u32,
                            "Conservative",
                        )
                    }
                    SafetyPolicy::Performance => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SafetyPolicy",
                            2u32,
                            "Performance",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SafetyPolicy {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Default" => _serde::__private228::Ok(__Field::__field0),
                            "Conservative" => _serde::__private228::Ok(__Field::__field1),
                            "Performance" => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Default" => _serde::__private228::Ok(__Field::__field0),
                            b"Conservative" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            b"Performance" => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<SafetyPolicy>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SafetyPolicy;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum SafetyPolicy",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SafetyPolicy::Default)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SafetyPolicy::Conservative)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SafetyPolicy::Performance)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Default",
                    "Conservative",
                    "Performance",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SafetyPolicy",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<SafetyPolicy>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    pub enum InteractiveAlgorithm {
        #[default]
        BoyerMoore,
        Regex,
        Simple,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for InteractiveAlgorithm {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::BoyerMoore, Self::Regex, Self::Simple]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::BoyerMoore => {
                    Some({ clap::builder::PossibleValue::new("boyer-moore") })
                }
                Self::Regex => Some({ clap::builder::PossibleValue::new("regex") }),
                Self::Simple => Some({ clap::builder::PossibleValue::new("simple") }),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InteractiveAlgorithm {
        #[inline]
        fn clone(&self) -> InteractiveAlgorithm {
            match self {
                InteractiveAlgorithm::BoyerMoore => InteractiveAlgorithm::BoyerMoore,
                InteractiveAlgorithm::Regex => InteractiveAlgorithm::Regex,
                InteractiveAlgorithm::Simple => InteractiveAlgorithm::Simple,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InteractiveAlgorithm {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    InteractiveAlgorithm::BoyerMoore => "BoyerMoore",
                    InteractiveAlgorithm::Regex => "Regex",
                    InteractiveAlgorithm::Simple => "Simple",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for InteractiveAlgorithm {
        #[inline]
        fn default() -> InteractiveAlgorithm {
            Self::BoyerMoore
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InteractiveAlgorithm {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InteractiveAlgorithm {
        #[inline]
        fn eq(&self, other: &InteractiveAlgorithm) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for InteractiveAlgorithm {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InteractiveAlgorithm {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    InteractiveAlgorithm::BoyerMoore => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InteractiveAlgorithm",
                            0u32,
                            "BoyerMoore",
                        )
                    }
                    InteractiveAlgorithm::Regex => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InteractiveAlgorithm",
                            1u32,
                            "Regex",
                        )
                    }
                    InteractiveAlgorithm::Simple => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InteractiveAlgorithm",
                            2u32,
                            "Simple",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InteractiveAlgorithm {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "BoyerMoore" => _serde::__private228::Ok(__Field::__field0),
                            "Regex" => _serde::__private228::Ok(__Field::__field1),
                            "Simple" => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"BoyerMoore" => _serde::__private228::Ok(__Field::__field0),
                            b"Regex" => _serde::__private228::Ok(__Field::__field1),
                            b"Simple" => _serde::__private228::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<InteractiveAlgorithm>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InteractiveAlgorithm;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum InteractiveAlgorithm",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(InteractiveAlgorithm::BoyerMoore)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(InteractiveAlgorithm::Regex)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(InteractiveAlgorithm::Simple)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "BoyerMoore",
                    "Regex",
                    "Simple",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "InteractiveAlgorithm",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<
                            InteractiveAlgorithm,
                        >,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    pub enum SearchAlgorithm {
        BoyerMoore,
        Regex,
        Simple,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for SearchAlgorithm {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::BoyerMoore, Self::Regex, Self::Simple]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::BoyerMoore => {
                    Some({ clap::builder::PossibleValue::new("boyer-moore") })
                }
                Self::Regex => Some({ clap::builder::PossibleValue::new("regex") }),
                Self::Simple => Some({ clap::builder::PossibleValue::new("simple") }),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchAlgorithm {
        #[inline]
        fn clone(&self) -> SearchAlgorithm {
            match self {
                SearchAlgorithm::BoyerMoore => SearchAlgorithm::BoyerMoore,
                SearchAlgorithm::Regex => SearchAlgorithm::Regex,
                SearchAlgorithm::Simple => SearchAlgorithm::Simple,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchAlgorithm {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SearchAlgorithm::BoyerMoore => "BoyerMoore",
                    SearchAlgorithm::Regex => "Regex",
                    SearchAlgorithm::Simple => "Simple",
                },
            )
        }
    }
    pub enum SortCriteria {
        Name,
        Size,
        Date,
        Type,
        Path,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for SortCriteria {
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Name, Self::Size, Self::Date, Self::Type, Self::Path]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::Name => Some({ clap::builder::PossibleValue::new("name") }),
                Self::Size => Some({ clap::builder::PossibleValue::new("size") }),
                Self::Date => Some({ clap::builder::PossibleValue::new("date") }),
                Self::Type => Some({ clap::builder::PossibleValue::new("type") }),
                Self::Path => Some({ clap::builder::PossibleValue::new("path") }),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SortCriteria {
        #[inline]
        fn clone(&self) -> SortCriteria {
            match self {
                SortCriteria::Name => SortCriteria::Name,
                SortCriteria::Size => SortCriteria::Size,
                SortCriteria::Date => SortCriteria::Date,
                SortCriteria::Type => SortCriteria::Type,
                SortCriteria::Path => SortCriteria::Path,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SortCriteria {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SortCriteria::Name => "Name",
                    SortCriteria::Size => "Size",
                    SortCriteria::Date => "Date",
                    SortCriteria::Type => "Type",
                    SortCriteria::Path => "Path",
                },
            )
        }
    }
    pub enum OutputFormat {
        #[default]
        Text,
        Json,
        Xml,
        Html,
        Markdown,
        Csv,
        Tsv,
    }
    #[allow(
        dead_code,
        unreachable_code,
        unused_variables,
        unused_braces,
        unused_qualifications,
    )]
    #[allow(
        clippy::style,
        clippy::complexity,
        clippy::pedantic,
        clippy::restriction,
        clippy::perf,
        clippy::deprecated,
        clippy::nursery,
        clippy::cargo,
        clippy::suspicious_else_formatting,
        clippy::almost_swapped,
        clippy::redundant_locals,
    )]
    #[automatically_derived]
    impl clap::ValueEnum for OutputFormat {
        fn value_variants<'a>() -> &'a [Self] {
            &[
                Self::Text,
                Self::Json,
                Self::Xml,
                Self::Html,
                Self::Markdown,
                Self::Csv,
                Self::Tsv,
            ]
        }
        fn to_possible_value<'a>(
            &self,
        ) -> ::std::option::Option<clap::builder::PossibleValue> {
            match self {
                Self::Text => Some({ clap::builder::PossibleValue::new("text") }),
                Self::Json => Some({ clap::builder::PossibleValue::new("json") }),
                Self::Xml => Some({ clap::builder::PossibleValue::new("xml") }),
                Self::Html => Some({ clap::builder::PossibleValue::new("html") }),
                Self::Markdown => Some({ clap::builder::PossibleValue::new("markdown") }),
                Self::Csv => Some({ clap::builder::PossibleValue::new("csv") }),
                Self::Tsv => Some({ clap::builder::PossibleValue::new("tsv") }),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OutputFormat {
        #[inline]
        fn clone(&self) -> OutputFormat {
            match self {
                OutputFormat::Text => OutputFormat::Text,
                OutputFormat::Json => OutputFormat::Json,
                OutputFormat::Xml => OutputFormat::Xml,
                OutputFormat::Html => OutputFormat::Html,
                OutputFormat::Markdown => OutputFormat::Markdown,
                OutputFormat::Csv => OutputFormat::Csv,
                OutputFormat::Tsv => OutputFormat::Tsv,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OutputFormat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    OutputFormat::Text => "Text",
                    OutputFormat::Json => "Json",
                    OutputFormat::Xml => "Xml",
                    OutputFormat::Html => "Html",
                    OutputFormat::Markdown => "Markdown",
                    OutputFormat::Csv => "Csv",
                    OutputFormat::Tsv => "Tsv",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for OutputFormat {
        #[inline]
        fn default() -> OutputFormat {
            Self::Text
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OutputFormat {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OutputFormat {
        #[inline]
        fn eq(&self, other: &OutputFormat) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for OutputFormat {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for OutputFormat {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    OutputFormat::Text => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            0u32,
                            "Text",
                        )
                    }
                    OutputFormat::Json => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            1u32,
                            "Json",
                        )
                    }
                    OutputFormat::Xml => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            2u32,
                            "Xml",
                        )
                    }
                    OutputFormat::Html => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            3u32,
                            "Html",
                        )
                    }
                    OutputFormat::Markdown => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            4u32,
                            "Markdown",
                        )
                    }
                    OutputFormat::Csv => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            5u32,
                            "Csv",
                        )
                    }
                    OutputFormat::Tsv => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "OutputFormat",
                            6u32,
                            "Tsv",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for OutputFormat {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            4u64 => _serde::__private228::Ok(__Field::__field4),
                            5u64 => _serde::__private228::Ok(__Field::__field5),
                            6u64 => _serde::__private228::Ok(__Field::__field6),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 7",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Text" => _serde::__private228::Ok(__Field::__field0),
                            "Json" => _serde::__private228::Ok(__Field::__field1),
                            "Xml" => _serde::__private228::Ok(__Field::__field2),
                            "Html" => _serde::__private228::Ok(__Field::__field3),
                            "Markdown" => _serde::__private228::Ok(__Field::__field4),
                            "Csv" => _serde::__private228::Ok(__Field::__field5),
                            "Tsv" => _serde::__private228::Ok(__Field::__field6),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Text" => _serde::__private228::Ok(__Field::__field0),
                            b"Json" => _serde::__private228::Ok(__Field::__field1),
                            b"Xml" => _serde::__private228::Ok(__Field::__field2),
                            b"Html" => _serde::__private228::Ok(__Field::__field3),
                            b"Markdown" => _serde::__private228::Ok(__Field::__field4),
                            b"Csv" => _serde::__private228::Ok(__Field::__field5),
                            b"Tsv" => _serde::__private228::Ok(__Field::__field6),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<OutputFormat>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = OutputFormat;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum OutputFormat",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Text)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Json)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Xml)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Html)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Markdown)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Csv)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(OutputFormat::Tsv)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Text",
                    "Json",
                    "Xml",
                    "Html",
                    "Markdown",
                    "Csv",
                    "Tsv",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "OutputFormat",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<OutputFormat>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    impl fmt::Display for SearchMode {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                SearchMode::Text => f.write_fmt(format_args!("text")),
                SearchMode::Word => f.write_fmt(format_args!("word")),
                SearchMode::Regex => f.write_fmt(format_args!("regex")),
            }
        }
    }
}
/// Internal configuration management
mod config {
    use crate::cli::SearchMode;
    use crate::error::{Result as RfgrepResult, RfgrepError};
    use serde::{Deserialize, Serialize};
    use std::fmt;
    use std::fs;
    use std::path::{Path, PathBuf};
    #[serde(default)]
    pub struct Config {
        #[serde(default)]
        pub search: SearchConfig,
        #[serde(default)]
        pub display: DisplayConfig,
        #[serde(default)]
        pub ignore: IgnoreConfig,
        #[serde(default)]
        pub performance: PerformanceConfig,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Config {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Config",
                "search",
                &self.search,
                "display",
                &self.display,
                "ignore",
                &self.ignore,
                "performance",
                &&self.performance,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Config {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Config",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "search",
                    &self.search,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display",
                    &self.display,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ignore",
                    &self.ignore,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "performance",
                    &self.performance,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Config
        where
            Config: _serde::__private228::Default,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "search" => _serde::__private228::Ok(__Field::__field0),
                            "display" => _serde::__private228::Ok(__Field::__field1),
                            "ignore" => _serde::__private228::Ok(__Field::__field2),
                            "performance" => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"search" => _serde::__private228::Ok(__Field::__field0),
                            b"display" => _serde::__private228::Ok(__Field::__field1),
                            b"ignore" => _serde::__private228::Ok(__Field::__field2),
                            b"performance" => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de>
                where
                    Config: _serde::__private228::Default,
                {
                    marker: _serde::__private228::PhantomData<Config>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de>
                where
                    Config: _serde::__private228::Default,
                {
                    type Value = Config;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct Config",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __default: Self::Value = _serde::__private228::Default::default();
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            SearchConfig,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            DisplayConfig,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            IgnoreConfig,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            PerformanceConfig,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        _serde::__private228::Ok(Config {
                            search: __field0,
                            display: __field1,
                            ignore: __field2,
                            performance: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<SearchConfig> = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<DisplayConfig> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<IgnoreConfig> = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<
                            PerformanceConfig,
                        > = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("search"),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SearchConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            DisplayConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("ignore"),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            IgnoreConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "performance",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PerformanceConfig,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __default: Self::Value = _serde::__private228::Default::default();
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => {
                                _serde::__private228::Default::default()
                            }
                        };
                        _serde::__private228::Ok(Config {
                            search: __field0,
                            display: __field1,
                            ignore: __field2,
                            performance: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "search",
                    "display",
                    "ignore",
                    "performance",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Config",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<Config>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    pub struct SearchConfig {
        pub default_mode: SearchMode,
        pub context_lines: usize,
        pub max_file_size: Option<u64>,
        pub chunk_size: usize,
        pub parallel_jobs: Option<usize>,
        pub default_extensions: Vec<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "default_mode",
                "context_lines",
                "max_file_size",
                "chunk_size",
                "parallel_jobs",
                "default_extensions",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.default_mode,
                &self.context_lines,
                &self.max_file_size,
                &self.chunk_size,
                &self.parallel_jobs,
                &&self.default_extensions,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SearchConfig",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for SearchConfig {
        #[inline]
        fn default() -> SearchConfig {
            SearchConfig {
                default_mode: ::core::default::Default::default(),
                context_lines: ::core::default::Default::default(),
                max_file_size: ::core::default::Default::default(),
                chunk_size: ::core::default::Default::default(),
                parallel_jobs: ::core::default::Default::default(),
                default_extensions: ::core::default::Default::default(),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SearchConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SearchConfig",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "default_mode",
                    &self.default_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "context_lines",
                    &self.context_lines,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "max_file_size",
                    &self.max_file_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chunk_size",
                    &self.chunk_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parallel_jobs",
                    &self.parallel_jobs,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "default_extensions",
                    &self.default_extensions,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SearchConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            4u64 => _serde::__private228::Ok(__Field::__field4),
                            5u64 => _serde::__private228::Ok(__Field::__field5),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "default_mode" => _serde::__private228::Ok(__Field::__field0),
                            "context_lines" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            "max_file_size" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            "chunk_size" => _serde::__private228::Ok(__Field::__field3),
                            "parallel_jobs" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            "default_extensions" => {
                                _serde::__private228::Ok(__Field::__field5)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"default_mode" => {
                                _serde::__private228::Ok(__Field::__field0)
                            }
                            b"context_lines" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            b"max_file_size" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            b"chunk_size" => _serde::__private228::Ok(__Field::__field3),
                            b"parallel_jobs" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            b"default_extensions" => {
                                _serde::__private228::Ok(__Field::__field5)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<SearchConfig>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SearchConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct SearchConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            SearchMode,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SearchConfig with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct SearchConfig with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<u64>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct SearchConfig with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct SearchConfig with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<usize>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct SearchConfig with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct SearchConfig with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private228::Ok(SearchConfig {
                            default_mode: __field0,
                            context_lines: __field1,
                            max_file_size: __field2,
                            chunk_size: __field3,
                            parallel_jobs: __field4,
                            default_extensions: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<SearchMode> = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<usize> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<Option<u64>> = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<usize> = _serde::__private228::None;
                        let mut __field4: _serde::__private228::Option<Option<usize>> = _serde::__private228::None;
                        let mut __field5: _serde::__private228::Option<Vec<String>> = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "default_mode",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<SearchMode>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "context_lines",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_file_size",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u64>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chunk_size",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private228::Option::is_some(&__field4) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parallel_jobs",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<usize>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private228::Option::is_some(&__field5) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "default_extensions",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("default_mode")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("context_lines")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("max_file_size")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("chunk_size")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private228::Some(__field4) => __field4,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("parallel_jobs")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private228::Some(__field5) => __field5,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field(
                                    "default_extensions",
                                )?
                            }
                        };
                        _serde::__private228::Ok(SearchConfig {
                            default_mode: __field0,
                            context_lines: __field1,
                            max_file_size: __field2,
                            chunk_size: __field3,
                            parallel_jobs: __field4,
                            default_extensions: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "default_mode",
                    "context_lines",
                    "max_file_size",
                    "chunk_size",
                    "parallel_jobs",
                    "default_extensions",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SearchConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<SearchConfig>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    pub struct DisplayConfig {
        #[serde(skip)]
        pub progress_style: Option<indicatif::ProgressStyle>,
        pub show_timing: bool,
        pub show_summary: bool,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DisplayConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DisplayConfig",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_timing",
                    &self.show_timing,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_summary",
                    &self.show_summary,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DisplayConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field1),
                            1u64 => _serde::__private228::Ok(__Field::__field2),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "show_timing" => _serde::__private228::Ok(__Field::__field1),
                            "show_summary" => _serde::__private228::Ok(__Field::__field2),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"show_timing" => _serde::__private228::Ok(__Field::__field1),
                            b"show_summary" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<DisplayConfig>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DisplayConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct DisplayConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = _serde::__private228::Default::default();
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DisplayConfig with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DisplayConfig with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private228::Ok(DisplayConfig {
                            progress_style: __field0,
                            show_timing: __field1,
                            show_summary: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field1: _serde::__private228::Option<bool> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<bool> = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_timing",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_summary",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("show_timing")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("show_summary")?
                            }
                        };
                        _serde::__private228::Ok(DisplayConfig {
                            progress_style: _serde::__private228::Default::default(),
                            show_timing: __field1,
                            show_summary: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["show_timing", "show_summary"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DisplayConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<DisplayConfig>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    impl fmt::Debug for DisplayConfig {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("DisplayConfig")
                .field("progress_style", &self.progress_style.is_some())
                .field("show_timing", &self.show_timing)
                .field("show_summary", &self.show_summary)
                .finish()
        }
    }
    impl Default for DisplayConfig {
        fn default() -> Self {
            Self {
                progress_style: None,
                show_timing: true,
                show_summary: true,
            }
        }
    }
    pub struct IgnoreConfig {
        pub patterns: Vec<String>,
        pub binary_files: bool,
        pub hidden_files: bool,
        pub min_file_size: Option<u64>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IgnoreConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "IgnoreConfig",
                "patterns",
                &self.patterns,
                "binary_files",
                &self.binary_files,
                "hidden_files",
                &self.hidden_files,
                "min_file_size",
                &&self.min_file_size,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for IgnoreConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "IgnoreConfig",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "patterns",
                    &self.patterns,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "binary_files",
                    &self.binary_files,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hidden_files",
                    &self.hidden_files,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "min_file_size",
                    &self.min_file_size,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for IgnoreConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "patterns" => _serde::__private228::Ok(__Field::__field0),
                            "binary_files" => _serde::__private228::Ok(__Field::__field1),
                            "hidden_files" => _serde::__private228::Ok(__Field::__field2),
                            "min_file_size" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"patterns" => _serde::__private228::Ok(__Field::__field0),
                            b"binary_files" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            b"hidden_files" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            b"min_file_size" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<IgnoreConfig>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = IgnoreConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct IgnoreConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct IgnoreConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct IgnoreConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct IgnoreConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<u64>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct IgnoreConfig with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private228::Ok(IgnoreConfig {
                            patterns: __field0,
                            binary_files: __field1,
                            hidden_files: __field2,
                            min_file_size: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<Vec<String>> = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<bool> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<bool> = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<Option<u64>> = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "patterns",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "binary_files",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hidden_files",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "min_file_size",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u64>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("patterns")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("binary_files")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("hidden_files")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("min_file_size")?
                            }
                        };
                        _serde::__private228::Ok(IgnoreConfig {
                            patterns: __field0,
                            binary_files: __field1,
                            hidden_files: __field2,
                            min_file_size: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "patterns",
                    "binary_files",
                    "hidden_files",
                    "min_file_size",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "IgnoreConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<IgnoreConfig>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    impl Default for IgnoreConfig {
        fn default() -> Self {
            Self {
                patterns: <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        "node_modules".to_string(),
                        ".git".to_string(),
                    ]),
                ),
                binary_files: true,
                hidden_files: true,
                min_file_size: None,
            }
        }
    }
    pub struct PerformanceConfig {
        #[serde(default = "default_mmap_threshold")]
        pub mmap_threshold_mb: u64,
        #[serde(default = "default_max_memory")]
        pub max_memory_usage_mb: u64,
        #[serde(default = "default_chunk_multiplier")]
        pub chunk_size_multiplier: f64,
        #[serde(default = "default_adaptive_memory")]
        pub adaptive_memory: bool,
        #[serde(default = "default_regex_cache_size")]
        pub regex_cache_size: usize,
        #[serde(default = "default_metadata_cache_size")]
        pub metadata_cache_size: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PerformanceConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "mmap_threshold_mb",
                "max_memory_usage_mb",
                "chunk_size_multiplier",
                "adaptive_memory",
                "regex_cache_size",
                "metadata_cache_size",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.mmap_threshold_mb,
                &self.max_memory_usage_mb,
                &self.chunk_size_multiplier,
                &self.adaptive_memory,
                &self.regex_cache_size,
                &&self.metadata_cache_size,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "PerformanceConfig",
                names,
                values,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PerformanceConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PerformanceConfig",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mmap_threshold_mb",
                    &self.mmap_threshold_mb,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "max_memory_usage_mb",
                    &self.max_memory_usage_mb,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "chunk_size_multiplier",
                    &self.chunk_size_multiplier,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "adaptive_memory",
                    &self.adaptive_memory,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "regex_cache_size",
                    &self.regex_cache_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "metadata_cache_size",
                    &self.metadata_cache_size,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PerformanceConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            4u64 => _serde::__private228::Ok(__Field::__field4),
                            5u64 => _serde::__private228::Ok(__Field::__field5),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "mmap_threshold_mb" => {
                                _serde::__private228::Ok(__Field::__field0)
                            }
                            "max_memory_usage_mb" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            "chunk_size_multiplier" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            "adaptive_memory" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            "regex_cache_size" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            "metadata_cache_size" => {
                                _serde::__private228::Ok(__Field::__field5)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"mmap_threshold_mb" => {
                                _serde::__private228::Ok(__Field::__field0)
                            }
                            b"max_memory_usage_mb" => {
                                _serde::__private228::Ok(__Field::__field1)
                            }
                            b"chunk_size_multiplier" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            b"adaptive_memory" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            b"regex_cache_size" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            b"metadata_cache_size" => {
                                _serde::__private228::Ok(__Field::__field5)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<PerformanceConfig>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PerformanceConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct PerformanceConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => default_mmap_threshold(),
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => default_max_memory(),
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            f64,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => default_chunk_multiplier(),
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => default_adaptive_memory(),
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => default_regex_cache_size(),
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => default_metadata_cache_size(),
                        };
                        _serde::__private228::Ok(PerformanceConfig {
                            mmap_threshold_mb: __field0,
                            max_memory_usage_mb: __field1,
                            chunk_size_multiplier: __field2,
                            adaptive_memory: __field3,
                            regex_cache_size: __field4,
                            metadata_cache_size: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<u64> = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<u64> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<f64> = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<bool> = _serde::__private228::None;
                        let mut __field4: _serde::__private228::Option<usize> = _serde::__private228::None;
                        let mut __field5: _serde::__private228::Option<usize> = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "mmap_threshold_mb",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_memory_usage_mb",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "chunk_size_multiplier",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "adaptive_memory",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private228::Option::is_some(&__field4) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "regex_cache_size",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private228::Option::is_some(&__field5) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "metadata_cache_size",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => default_mmap_threshold(),
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => default_max_memory(),
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => default_chunk_multiplier(),
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => default_adaptive_memory(),
                        };
                        let __field4 = match __field4 {
                            _serde::__private228::Some(__field4) => __field4,
                            _serde::__private228::None => default_regex_cache_size(),
                        };
                        let __field5 = match __field5 {
                            _serde::__private228::Some(__field5) => __field5,
                            _serde::__private228::None => default_metadata_cache_size(),
                        };
                        _serde::__private228::Ok(PerformanceConfig {
                            mmap_threshold_mb: __field0,
                            max_memory_usage_mb: __field1,
                            chunk_size_multiplier: __field2,
                            adaptive_memory: __field3,
                            regex_cache_size: __field4,
                            metadata_cache_size: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "mmap_threshold_mb",
                    "max_memory_usage_mb",
                    "chunk_size_multiplier",
                    "adaptive_memory",
                    "regex_cache_size",
                    "metadata_cache_size",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PerformanceConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<PerformanceConfig>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    fn default_mmap_threshold() -> u64 {
        16
    }
    fn default_max_memory() -> u64 {
        512
    }
    fn default_chunk_multiplier() -> f64 {
        1.0
    }
    fn default_adaptive_memory() -> bool {
        true
    }
    fn default_regex_cache_size() -> usize {
        100
    }
    fn default_metadata_cache_size() -> usize {
        1000
    }
    impl Default for PerformanceConfig {
        fn default() -> Self {
            Self {
                mmap_threshold_mb: default_mmap_threshold(),
                max_memory_usage_mb: default_max_memory(),
                chunk_size_multiplier: default_chunk_multiplier(),
                adaptive_memory: default_adaptive_memory(),
                regex_cache_size: default_regex_cache_size(),
                metadata_cache_size: default_metadata_cache_size(),
            }
        }
    }
    impl Config {
        #[allow(dead_code)]
        pub fn load() -> RfgrepResult<Self> {
            let config_path = Self::find_config_path()
                .map_err(|e| RfgrepError::Other(e.to_string()))?;
            if let Some(path) = config_path {
                let content = fs::read_to_string(&path)
                    .map_err(RfgrepError::Io)
                    .map_err(|e| {
                        RfgrepError::Other(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to read config file: {0}: {1}",
                                        path.display(),
                                        e,
                                    ),
                                )
                            }),
                        )
                    })?;
                toml::from_str(&content)
                    .map_err(|e| RfgrepError::Other(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Failed to parse config file: {0}", e),
                            )
                        }),
                    ))
            } else {
                Ok(Self::default())
            }
        }
        #[allow(dead_code)]
        fn find_config_path() -> RfgrepResult<Option<PathBuf>> {
            if let Some(xdg_config) = dirs::config_dir() {
                let xdg_path = xdg_config.join("rfgrep/config.toml");
                if xdg_path.exists() {
                    return Ok(Some(xdg_path));
                }
            }
            if let Some(home) = dirs::home_dir() {
                let home_path = home.join(".rfgrep.toml");
                if home_path.exists() {
                    return Ok(Some(home_path));
                }
            }
            let current_path = Path::new(".rfgrep.toml");
            if current_path.exists() {
                return Ok(Some(current_path.to_path_buf()));
            }
            Ok(None)
        }
        #[allow(dead_code)]
        pub fn save(&self, path: &Path) -> RfgrepResult<()> {
            let content = toml::to_string_pretty(self)
                .map_err(|e| RfgrepError::Other(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("Failed to serialize config: {0}", e),
                        )
                    }),
                ))?;
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).map_err(RfgrepError::Io)?;
            }
            fs::write(path, content).map_err(RfgrepError::Io)?;
            Ok(())
        }
    }
    impl Default for Config {
        fn default() -> Self {
            Self {
                search: SearchConfig {
                    default_mode: SearchMode::Regex,
                    context_lines: 2,
                    max_file_size: Some(100),
                    chunk_size: 100,
                    parallel_jobs: None,
                    default_extensions: ::alloc::vec::Vec::new(),
                },
                display: DisplayConfig::default(),
                ignore: IgnoreConfig::default(),
                performance: PerformanceConfig::default(),
            }
        }
    }
}
/// Error types and result handling
pub mod error {
    use std::io;
    use std::path::PathBuf;
    use thiserror::Error;
    pub enum RfgrepError {
        #[error("I/O error: {0}")]
        Io(#[from] io::Error),
        #[error("Regex error: {0}")]
        Regex(#[from] regex::Error),
        #[error("Clipboard error: {0}")]
        Clipboard(#[from] arboard::Error),
        #[error("Walkdir error: {0}")]
        Walkdir(#[from] walkdir::Error),
        #[error("Plugin loading error: {0}")]
        PluginLoading(#[from] libloading::Error),
        #[error("Memory map error: {0}")]
        #[allow(dead_code)]
        Mmap(io::Error),
        #[error("Configuration error: {0}")]
        #[allow(dead_code)]
        Config(String),
        #[error("Failed to process file '{path}': {source}")]
        #[allow(dead_code)]
        FileProcessing {
            path: PathBuf,
            #[source]
            source: Box<dyn std::error::Error + Send + Sync>,
        },
        #[error("Invalid file extension: {0}")]
        #[allow(dead_code)]
        InvalidExtension(String),
        #[error("Binary file detected: {0}")]
        #[allow(dead_code)]
        BinaryFile(String),
        #[error("File too large: {path} ({size} MB)")]
        #[allow(dead_code)]
        FileTooLarge { path: String, size: f64 },
        #[error("An unexpected error occurred: {0}")]
        Other(String),
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private18::Error for RfgrepError {
        fn source(
            &self,
        ) -> ::core::option::Option<&(dyn ::thiserror::__private18::Error + 'static)> {
            use ::thiserror::__private18::AsDynError as _;
            #[allow(deprecated)]
            match self {
                RfgrepError::Io { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                RfgrepError::Regex { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                RfgrepError::Clipboard { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                RfgrepError::Walkdir { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                RfgrepError::PluginLoading { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                RfgrepError::Mmap { .. } => ::core::option::Option::None,
                RfgrepError::Config { .. } => ::core::option::Option::None,
                RfgrepError::FileProcessing { source: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                RfgrepError::InvalidExtension { .. } => ::core::option::Option::None,
                RfgrepError::BinaryFile { .. } => ::core::option::Option::None,
                RfgrepError::FileTooLarge { .. } => ::core::option::Option::None,
                RfgrepError::Other { .. } => ::core::option::Option::None,
            }
        }
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for RfgrepError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private18::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                RfgrepError::Io(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("I/O error: {0}", __display0))
                        }
                    }
                }
                RfgrepError::Regex(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("Regex error: {0}", __display0))
                        }
                    }
                }
                RfgrepError::Clipboard(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("Clipboard error: {0}", __display0))
                        }
                    }
                }
                RfgrepError::Walkdir(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("Walkdir error: {0}", __display0))
                        }
                    }
                }
                RfgrepError::PluginLoading(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("Plugin loading error: {0}", __display0),
                                )
                        }
                    }
                }
                RfgrepError::Mmap(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("Memory map error: {0}", __display0),
                                )
                        }
                    }
                }
                RfgrepError::Config(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("Configuration error: {0}", __display0),
                                )
                        }
                    }
                }
                RfgrepError::FileProcessing { path, source } => {
                    match (path.as_display(), source.as_display()) {
                        (__display_path, __display_source) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "Failed to process file \'{0}\': {1}",
                                        __display_path,
                                        __display_source,
                                    ),
                                )
                        }
                    }
                }
                RfgrepError::InvalidExtension(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("Invalid file extension: {0}", __display0),
                                )
                        }
                    }
                }
                RfgrepError::BinaryFile(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("Binary file detected: {0}", __display0),
                                )
                        }
                    }
                }
                RfgrepError::FileTooLarge { path, size } => {
                    match (path.as_display(), size.as_display()) {
                        (__display_path, __display_size) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "File too large: {0} ({1} MB)",
                                        __display_path,
                                        __display_size,
                                    ),
                                )
                        }
                    }
                }
                RfgrepError::Other(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "An unexpected error occurred: {0}",
                                        __display0,
                                    ),
                                )
                        }
                    }
                }
            }
        }
    }
    #[allow(deprecated, unused_qualifications)]
    #[automatically_derived]
    impl ::core::convert::From<io::Error> for RfgrepError {
        fn from(source: io::Error) -> Self {
            RfgrepError::Io { 0: source }
        }
    }
    #[allow(deprecated, unused_qualifications)]
    #[automatically_derived]
    impl ::core::convert::From<regex::Error> for RfgrepError {
        fn from(source: regex::Error) -> Self {
            RfgrepError::Regex { 0: source }
        }
    }
    #[allow(deprecated, unused_qualifications)]
    #[automatically_derived]
    impl ::core::convert::From<arboard::Error> for RfgrepError {
        fn from(source: arboard::Error) -> Self {
            RfgrepError::Clipboard {
                0: source,
            }
        }
    }
    #[allow(deprecated, unused_qualifications)]
    #[automatically_derived]
    impl ::core::convert::From<walkdir::Error> for RfgrepError {
        fn from(source: walkdir::Error) -> Self {
            RfgrepError::Walkdir { 0: source }
        }
    }
    #[allow(deprecated, unused_qualifications)]
    #[automatically_derived]
    impl ::core::convert::From<libloading::Error> for RfgrepError {
        fn from(source: libloading::Error) -> Self {
            RfgrepError::PluginLoading {
                0: source,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RfgrepError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RfgrepError::Io(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Io", &__self_0)
                }
                RfgrepError::Regex(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Regex",
                        &__self_0,
                    )
                }
                RfgrepError::Clipboard(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Clipboard",
                        &__self_0,
                    )
                }
                RfgrepError::Walkdir(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Walkdir",
                        &__self_0,
                    )
                }
                RfgrepError::PluginLoading(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PluginLoading",
                        &__self_0,
                    )
                }
                RfgrepError::Mmap(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mmap",
                        &__self_0,
                    )
                }
                RfgrepError::Config(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Config",
                        &__self_0,
                    )
                }
                RfgrepError::FileProcessing { path: __self_0, source: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FileProcessing",
                        "path",
                        __self_0,
                        "source",
                        &__self_1,
                    )
                }
                RfgrepError::InvalidExtension(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "InvalidExtension",
                        &__self_0,
                    )
                }
                RfgrepError::BinaryFile(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BinaryFile",
                        &__self_0,
                    )
                }
                RfgrepError::FileTooLarge { path: __self_0, size: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FileTooLarge",
                        "path",
                        __self_0,
                        "size",
                        &__self_1,
                    )
                }
                RfgrepError::Other(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Other",
                        &__self_0,
                    )
                }
            }
        }
    }
    pub type Result<T> = std::result::Result<T, RfgrepError>;
}
/// File type classification system supporting 153+ formats
pub mod file_types {
    use std::collections::{HashMap, HashSet};
    use std::fs::Metadata;
    use std::path::Path;
    /// Search decision for a file
    pub enum SearchDecision {
        Search(SearchMode),
        Skip(String),
        Conditional(SearchMode, String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchDecision {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                SearchDecision::Search(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Search",
                        &__self_0,
                    )
                }
                SearchDecision::Skip(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Skip",
                        &__self_0,
                    )
                }
                SearchDecision::Conditional(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "Conditional",
                        __self_0,
                        &__self_1,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchDecision {
        #[inline]
        fn clone(&self) -> SearchDecision {
            match self {
                SearchDecision::Search(__self_0) => {
                    SearchDecision::Search(::core::clone::Clone::clone(__self_0))
                }
                SearchDecision::Skip(__self_0) => {
                    SearchDecision::Skip(::core::clone::Clone::clone(__self_0))
                }
                SearchDecision::Conditional(__self_0, __self_1) => {
                    SearchDecision::Conditional(
                        ::core::clone::Clone::clone(__self_0),
                        ::core::clone::Clone::clone(__self_1),
                    )
                }
            }
        }
    }
    /// Different search modes for different file types
    pub enum SearchMode {
        FullText,
        Metadata,
        Filename,
        Structured,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SearchMode::FullText => "FullText",
                    SearchMode::Metadata => "Metadata",
                    SearchMode::Filename => "Filename",
                    SearchMode::Structured => "Structured",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchMode {
        #[inline]
        fn clone(&self) -> SearchMode {
            match self {
                SearchMode::FullText => SearchMode::FullText,
                SearchMode::Metadata => SearchMode::Metadata,
                SearchMode::Filename => SearchMode::Filename,
                SearchMode::Structured => SearchMode::Structured,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SearchMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SearchMode {
        #[inline]
        fn eq(&self, other: &SearchMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    /// File type classifier that determines how to handle different file types
    pub struct FileTypeClassifier {
        always_search: HashSet<String>,
        conditional_search: HashSet<String>,
        skip_by_default: HashSet<String>,
        never_search: HashSet<String>,
        size_limits: HashMap<String, u64>,
        search_modes: HashMap<String, SearchMode>,
    }
    impl FileTypeClassifier {
        pub fn new() -> Self {
            Self {
                always_search: [
                    "txt",
                    "md",
                    "rst",
                    "org",
                    "tex",
                    "log",
                    "readme",
                    "changelog",
                    "rs",
                    "py",
                    "js",
                    "ts",
                    "go",
                    "java",
                    "cpp",
                    "c",
                    "h",
                    "hpp",
                    "cs",
                    "php",
                    "rb",
                    "swift",
                    "kt",
                    "scala",
                    "dart",
                    "r",
                    "lua",
                    "sh",
                    "bash",
                    "zsh",
                    "fish",
                    "ps1",
                    "bat",
                    "cmd",
                    "html",
                    "htm",
                    "css",
                    "scss",
                    "sass",
                    "less",
                    "vue",
                    "jsx",
                    "tsx",
                    "json",
                    "yaml",
                    "yml",
                    "toml",
                    "ini",
                    "cfg",
                    "conf",
                    "config",
                    "xml",
                    "svg",
                    "env",
                    "properties",
                    "dockerfile",
                    "makefile",
                    "csv",
                    "tsv",
                    "sql",
                    "graphql",
                    "gql",
                    "adoc",
                    "asciidoc",
                    "tex",
                    "latex",
                    "pod",
                ]
                    .iter()
                    .map(|s| s.to_string())
                    .collect::<HashSet<String>>(),
                conditional_search: [
                    "pdf",
                    "docx",
                    "xlsx",
                    "pptx",
                    "odt",
                    "ods",
                    "odp",
                    "zip",
                    "tar",
                    "gz",
                    "bz2",
                    "xz",
                    "7z",
                    "rar",
                    "cab",
                    "db",
                    "sqlite",
                    "mdb",
                    "accdb",
                    "mp3",
                    "flac",
                    "wav",
                    "aac",
                    "ogg",
                    "wma",
                    "mp4",
                    "mkv",
                    "mov",
                    "avi",
                    "flv",
                    "wmv",
                    "webm",
                    "m4v",
                    "jpg",
                    "jpeg",
                    "png",
                    "gif",
                    "bmp",
                    "webp",
                    "ico",
                    "tiff",
                ]
                    .iter()
                    .map(|s| s.to_string())
                    .collect::<HashSet<String>>(),
                skip_by_default: [
                    "exe",
                    "dll",
                    "so",
                    "dylib",
                    "appimage",
                    "bin",
                    "class",
                    "jar",
                    "msi",
                    "deb",
                    "rpm",
                    "snap",
                    "apk",
                    "ipa",
                    "iso",
                    "img",
                    "vdi",
                    "vmdk",
                    "qcow2",
                    "raw",
                    "tmp",
                    "temp",
                    "swp",
                    "bak",
                    "backup",
                    "lock",
                    "pid",
                ]
                    .iter()
                    .map(|s| s.to_string())
                    .collect::<HashSet<String>>(),
                never_search: [
                    "enc",
                    "gpg",
                    "asc",
                    "sig",
                    "key",
                    "pem",
                    "p12",
                    "pfx",
                    "core",
                    "dump",
                    "crash",
                    "hs_err",
                ]
                    .iter()
                    .map(|s| s.to_string())
                    .collect::<HashSet<String>>(),
                size_limits: HashMap::from([
                    ("txt".to_string(), 100 * 1024 * 1024),
                    ("md".to_string(), 50 * 1024 * 1024),
                    ("rs".to_string(), 50 * 1024 * 1024),
                    ("py".to_string(), 50 * 1024 * 1024),
                    ("js".to_string(), 50 * 1024 * 1024),
                    ("json".to_string(), 50 * 1024 * 1024),
                    ("xml".to_string(), 50 * 1024 * 1024),
                    ("html".to_string(), 50 * 1024 * 1024),
                    ("css".to_string(), 50 * 1024 * 1024),
                    ("log".to_string(), 200 * 1024 * 1024),
                    ("pdf".to_string(), 10 * 1024 * 1024),
                    ("docx".to_string(), 10 * 1024 * 1024),
                    ("xlsx".to_string(), 10 * 1024 * 1024),
                    ("pptx".to_string(), 10 * 1024 * 1024),
                    ("zip".to_string(), 20 * 1024 * 1024),
                    ("tar".to_string(), 20 * 1024 * 1024),
                    ("gz".to_string(), 20 * 1024 * 1024),
                    ("7z".to_string(), 20 * 1024 * 1024),
                    ("mp4".to_string(), 5 * 1024 * 1024),
                    ("mp3".to_string(), 5 * 1024 * 1024),
                    ("jpg".to_string(), 2 * 1024 * 1024),
                    ("png".to_string(), 2 * 1024 * 1024),
                ]),
                search_modes: HashMap::from([
                    ("pdf".to_string(), SearchMode::Metadata),
                    ("docx".to_string(), SearchMode::Metadata),
                    ("xlsx".to_string(), SearchMode::Metadata),
                    ("pptx".to_string(), SearchMode::Metadata),
                    ("odt".to_string(), SearchMode::Metadata),
                    ("ods".to_string(), SearchMode::Metadata),
                    ("odp".to_string(), SearchMode::Metadata),
                    ("zip".to_string(), SearchMode::Filename),
                    ("tar".to_string(), SearchMode::Filename),
                    ("gz".to_string(), SearchMode::Filename),
                    ("bz2".to_string(), SearchMode::Filename),
                    ("xz".to_string(), SearchMode::Filename),
                    ("7z".to_string(), SearchMode::Filename),
                    ("rar".to_string(), SearchMode::Filename),
                    ("cab".to_string(), SearchMode::Filename),
                    ("json".to_string(), SearchMode::Structured),
                    ("xml".to_string(), SearchMode::Structured),
                    ("yaml".to_string(), SearchMode::Structured),
                    ("yml".to_string(), SearchMode::Structured),
                    ("toml".to_string(), SearchMode::Structured),
                    ("mp3".to_string(), SearchMode::Metadata),
                    ("flac".to_string(), SearchMode::Metadata),
                    ("wav".to_string(), SearchMode::Metadata),
                    ("mp4".to_string(), SearchMode::Metadata),
                    ("mkv".to_string(), SearchMode::Metadata),
                    ("jpg".to_string(), SearchMode::Metadata),
                    ("png".to_string(), SearchMode::Metadata),
                ]),
            }
        }
        /// Determine if a file should be searched and how
        pub fn should_search(&self, path: &Path, metadata: &Metadata) -> SearchDecision {
            let ext = path
                .extension()
                .and_then(|e| e.to_str())
                .map(|s| s.to_ascii_lowercase())
                .unwrap_or_default();
            if self.never_search.contains(&ext) {
                return SearchDecision::Skip(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("Never search file type: {0}", ext),
                        )
                    }),
                );
            }
            if self.always_search.contains(&ext) {
                return self.check_size_limits(&ext, metadata, SearchMode::FullText);
            }
            if self.conditional_search.contains(&ext) {
                let search_mode = self
                    .search_modes
                    .get(&ext)
                    .cloned()
                    .unwrap_or(SearchMode::Metadata);
                return self.check_conditional_search(&ext, metadata, search_mode);
            }
            if self.skip_by_default.contains(&ext) {
                return SearchDecision::Skip(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("Skip by default: {0}", ext))
                    }),
                );
            }
            self.classify_by_mime(path, metadata)
        }
        fn check_size_limits(
            &self,
            ext: &str,
            metadata: &Metadata,
            default_mode: SearchMode,
        ) -> SearchDecision {
            let file_size = metadata.len();
            let limit = self.size_limits.get(ext).unwrap_or(&(50 * 1024 * 1024));
            if file_size > *limit {
                SearchDecision::Skip(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "File too large: {0} bytes > {1} bytes (limit for .{2})",
                                file_size,
                                limit,
                                ext,
                            ),
                        )
                    }),
                )
            } else {
                SearchDecision::Search(default_mode)
            }
        }
        fn check_conditional_search(
            &self,
            ext: &str,
            metadata: &Metadata,
            search_mode: SearchMode,
        ) -> SearchDecision {
            let file_size = metadata.len();
            let limit = self.size_limits.get(ext).unwrap_or(&(10 * 1024 * 1024));
            if file_size > *limit {
                SearchDecision::Skip(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Conditional file too large: {0} bytes > {1} bytes (limit for .{2})",
                                file_size,
                                limit,
                                ext,
                            ),
                        )
                    }),
                )
            } else {
                SearchDecision::Conditional(
                    search_mode,
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("Conditional search for .{0}", ext),
                        )
                    }),
                )
            }
        }
        fn classify_by_mime(&self, path: &Path, metadata: &Metadata) -> SearchDecision {
            if let Ok(Some(kind)) = infer::get_from_path(path) {
                let mime = kind.mime_type();
                return self.classify_by_mime_type(mime, metadata);
            }
            if self.is_likely_text_file(path) {
                SearchDecision::Search(SearchMode::FullText)
            } else {
                SearchDecision::Skip("Unknown file type, not text-like".to_string())
            }
        }
        fn classify_by_mime_type(
            &self,
            mime: &str,
            metadata: &Metadata,
        ) -> SearchDecision {
            match mime {
                m if m.starts_with("text/") => {
                    SearchDecision::Search(SearchMode::FullText)
                }
                m if m.starts_with("application/json")
                    || m.starts_with("application/xml") => {
                    SearchDecision::Search(SearchMode::Structured)
                }
                m if m.starts_with("application/pdf") => {
                    self.check_conditional_search("pdf", metadata, SearchMode::Metadata)
                }
                m if m.starts_with("application/zip")
                    || m.starts_with("application/x-tar") => {
                    self.check_conditional_search("zip", metadata, SearchMode::Filename)
                }
                m if m.starts_with("image/") || m.starts_with("video/")
                    || m.starts_with("audio/") => {
                    self.check_conditional_search(
                        "media",
                        metadata,
                        SearchMode::Metadata,
                    )
                }
                m if m.starts_with("application/octet-stream") => {
                    SearchDecision::Skip("Binary file detected".to_string())
                }
                _ => {
                    SearchDecision::Skip(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Unknown MIME type: {0}", mime),
                            )
                        }),
                    )
                }
            }
        }
        fn is_likely_text_file(&self, path: &Path) -> bool {
            if let Ok(content) = std::fs::read(path) {
                let sample_size = content.len().min(1024);
                if sample_size == 0 {
                    return false;
                }
                let sample = &content[..sample_size];
                let null_bytes = sample.iter().filter(|&&b| b == 0).count();
                let text_ratio = (sample_size - null_bytes) as f64 / sample_size as f64;
                text_ratio > 0.9
            } else {
                false
            }
        }
        /// Get search mode for a specific file type
        pub fn get_search_mode(&self, ext: &str) -> Option<SearchMode> {
            self.search_modes.get(ext).cloned()
        }
        /// Check if a file type is always searched
        pub fn is_always_search(&self, ext: &str) -> bool {
            self.always_search.contains(ext)
        }
        /// Check if a file type is conditionally searched
        pub fn is_conditional_search(&self, ext: &str) -> bool {
            self.conditional_search.contains(ext)
        }
        /// Check if a file type is skipped by default
        pub fn is_skip_by_default(&self, ext: &str) -> bool {
            self.skip_by_default.contains(ext)
        }
        /// Check if a file type is never searched
        pub fn is_never_search(&self, ext: &str) -> bool {
            self.never_search.contains(ext)
        }
        /// Get size limit for a file type
        pub fn get_size_limit(&self, ext: &str) -> Option<u64> {
            self.size_limits.get(ext).cloned()
        }
        /// Add custom file type rules
        pub fn add_custom_rule(&mut self, ext: String, decision: SearchDecision) {
            match decision {
                SearchDecision::Search(mode) => {
                    self.always_search.insert(ext.clone());
                    self.search_modes.insert(ext, mode);
                }
                SearchDecision::Skip(_) => {
                    self.never_search.insert(ext);
                }
                SearchDecision::Conditional(mode, _) => {
                    self.conditional_search.insert(ext.clone());
                    self.search_modes.insert(ext, mode);
                }
            }
        }
    }
    impl Default for FileTypeClassifier {
        fn default() -> Self {
            Self::new()
        }
    }
}
/// Interactive search mode implementation
mod interactive {
    //! Interactive search engine with TUI interface
    use crate::cli::InteractiveAlgorithm;
    use crate::error::{Result as RfgrepResult, RfgrepError};
    use crate::metrics::Metrics;
    use crate::search::algorithms::*;
    use crate::search::SearchEngine;
    use colored::Colorize;
    use std::collections::VecDeque;
    use std::path::Path;
    use std::sync::Arc;
    /// Interactive search engine
    pub struct InteractiveEngine {
        metrics: Arc<Metrics>,
        search_engine: SearchEngine,
        history: VecDeque<String>,
        max_history: usize,
    }
    /// Interactive search state
    pub struct SearchState {
        pub pattern: String,
        pub files: Vec<std::path::PathBuf>,
        pub matches: Vec<crate::processor::SearchMatch>,
        pub current_file_index: usize,
        pub current_match_index: usize,
        pub filter: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchState {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "pattern",
                "files",
                "matches",
                "current_file_index",
                "current_match_index",
                "filter",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.pattern,
                &self.files,
                &self.matches,
                &self.current_file_index,
                &self.current_match_index,
                &&self.filter,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SearchState",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchState {
        #[inline]
        fn clone(&self) -> SearchState {
            SearchState {
                pattern: ::core::clone::Clone::clone(&self.pattern),
                files: ::core::clone::Clone::clone(&self.files),
                matches: ::core::clone::Clone::clone(&self.matches),
                current_file_index: ::core::clone::Clone::clone(
                    &self.current_file_index,
                ),
                current_match_index: ::core::clone::Clone::clone(
                    &self.current_match_index,
                ),
                filter: ::core::clone::Clone::clone(&self.filter),
            }
        }
    }
    impl InteractiveEngine {
        /// Create a new interactive engine
        pub fn new(metrics: Arc<Metrics>) -> RfgrepResult<Self> {
            let search_engine = SearchEngine::new(metrics.clone())?;
            Ok(Self {
                metrics,
                search_engine,
                history: VecDeque::new(),
                max_history: 100,
            })
        }
        /// Run interactive search
        pub async fn run(
            &mut self,
            root_path: &Path,
            initial_pattern: &str,
            algorithm: InteractiveAlgorithm,
            recursive: bool,
            extensions: Option<&[String]>,
        ) -> RfgrepResult<()> {
            {
                ::std::io::_print(
                    format_args!(
                        "{0}\n",
                        "Starting interactive search mode...".green().bold(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!("Pattern: {0}\n", initial_pattern.yellow()),
                );
            };
            {
                ::std::io::_print(format_args!("Algorithm: {0:?}\n", algorithm));
            };
            {
                ::std::io::_print(
                    format_args!("{0}\n", "Press 'q' to quit, 'h' for help".dimmed()),
                );
            };
            let files = self.discover_files(root_path, recursive, extensions).await?;
            {
                ::std::io::_print(format_args!("Files to search: {0}\n", files.len()));
            };
            let mut state = SearchState {
                pattern: initial_pattern.to_string(),
                files,
                matches: Vec::new(),
                current_file_index: 0,
                current_match_index: 0,
                filter: None,
            };
            self.perform_search(&mut state, &algorithm).await?;
            self.interactive_loop(&mut state, &algorithm).await?;
            Ok(())
        }
        /// Discover files to search
        async fn discover_files(
            &self,
            root_path: &Path,
            recursive: bool,
            extensions: Option<&[String]>,
        ) -> RfgrepResult<Vec<std::path::PathBuf>> {
            use crate::walker::walk_dir;
            let files: Vec<_> = walk_dir(root_path, recursive, true)
                .filter(|entry| entry.path().is_file())
                .map(|entry| entry.path().to_path_buf())
                .collect();
            let filtered_files: Vec<_> = if let Some(extensions) = extensions {
                files
                    .into_iter()
                    .filter(|path| {
                        if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                            extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
                        } else {
                            false
                        }
                    })
                    .collect()
            } else {
                files
            };
            Ok(filtered_files)
        }
        /// Perform search with current state
        async fn perform_search(
            &self,
            state: &mut SearchState,
            algorithm: &InteractiveAlgorithm,
        ) -> RfgrepResult<()> {
            if state.pattern.is_empty() {
                state.matches.clear();
                return Ok(());
            }
            let search_algorithm: Box<dyn SearchAlgorithmTrait> = match algorithm {
                InteractiveAlgorithm::BoyerMoore => {
                    Box::new(SimdSearch::new(&state.pattern))
                }
                InteractiveAlgorithm::Regex => {
                    Box::new(RegexSearch::new(&state.pattern)?)
                }
                InteractiveAlgorithm::Simple => Box::new(SimdSearch::new(&state.pattern)),
            };
            let mut all_matches = Vec::new();
            for file in &state.files {
                if let Ok(content) = std::fs::read_to_string(file) {
                    let file_matches = search_algorithm
                        .search_with_context(&content, &state.pattern, 2);
                    for mut m in file_matches {
                        m.path = file.clone();
                        all_matches.push(m);
                    }
                }
            }
            if let Some(filter) = &state.filter {
                state.matches = all_matches
                    .into_iter()
                    .filter(|m| m.line.to_lowercase().contains(&filter.to_lowercase()))
                    .collect();
            } else {
                state.matches = all_matches;
            }
            state.matches.sort();
            self.metrics.matches_found.inc_by(state.matches.len() as u64);
            Ok(())
        }
        /// Main interactive loop
        async fn interactive_loop(
            &mut self,
            state: &mut SearchState,
            algorithm: &InteractiveAlgorithm,
        ) -> RfgrepResult<()> {
            use std::io::{self, Write};
            loop {
                self.display_state(state);
                {
                    ::std::io::_print(format_args!("\n> "));
                };
                io::stdout().flush()?;
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                let input = input.trim();
                if input.is_empty() {
                    continue;
                }
                self.add_to_history(input.to_string());
                match self.process_command(input, state, algorithm).await? {
                    CommandResult::Continue => continue,
                    CommandResult::Quit => break,
                    CommandResult::Search => {
                        self.perform_search(state, algorithm).await?;
                    }
                }
            }
            Ok(())
        }
        /// Display current search state
        fn display_state(&self, state: &SearchState) {
            {
                ::std::io::_print(format_args!("\n{0}\n", "=".repeat(60).cyan()));
            };
            {
                ::std::io::_print(
                    format_args!("Pattern: {0}\n", state.pattern.yellow()),
                );
            };
            {
                ::std::io::_print(format_args!("Files: {0}\n", state.files.len()));
            };
            {
                ::std::io::_print(format_args!("Matches: {0}\n", state.matches.len()));
            };
            if let Some(filter) = &state.filter {
                {
                    ::std::io::_print(format_args!("Filter: {0}\n", filter.blue()));
                };
            }
            if !state.matches.is_empty() {
                {
                    ::std::io::_print(
                        format_args!("\n{0}\n", "Recent matches:".green().bold()),
                    );
                };
                let start = state.current_match_index.saturating_sub(5);
                let end = (state.current_match_index + 5).min(state.matches.len());
                for (i, m) in state.matches[start..end].iter().enumerate() {
                    let actual_index = start + i;
                    let marker = if actual_index == state.current_match_index {
                        "â"
                    } else {
                        " "
                    };
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0} {1}:{2}:{3}: {4}\n",
                                marker.yellow(),
                                m.path.display(),
                                m.line_number,
                                m.column_start + 1,
                                m.line,
                            ),
                        );
                    };
                }
            }
        }
        /// Process user command
        async fn process_command(
            &self,
            input: &str,
            state: &mut SearchState,
            _algorithm: &InteractiveAlgorithm,
        ) -> RfgrepResult<CommandResult> {
            let parts: Vec<&str> = input.split_whitespace().collect();
            if parts.is_empty() {
                return Ok(CommandResult::Continue);
            }
            match parts[0] {
                "q" | "quit" | "exit" => Ok(CommandResult::Quit),
                "h" | "help" => {
                    self.show_help();
                    Ok(CommandResult::Continue)
                }
                "s" | "search" => {
                    if parts.len() > 1 {
                        state.pattern = parts[1..].join(" ");
                        Ok(CommandResult::Search)
                    } else {
                        {
                            ::std::io::_print(format_args!("Usage: search <pattern>\n"));
                        };
                        Ok(CommandResult::Continue)
                    }
                }
                "f" | "filter" => {
                    if parts.len() > 1 {
                        state.filter = Some(parts[1..].join(" "));
                        Ok(CommandResult::Search)
                    } else {
                        state.filter = None;
                        Ok(CommandResult::Search)
                    }
                }
                "c" | "clear" => {
                    state.filter = None;
                    state.pattern.clear();
                    Ok(CommandResult::Search)
                }
                "n" | "next" => {
                    if state.current_match_index < state.matches.len().saturating_sub(1)
                    {
                        state.current_match_index += 1;
                    }
                    Ok(CommandResult::Continue)
                }
                "p" | "prev" | "previous" => {
                    if state.current_match_index > 0 {
                        state.current_match_index -= 1;
                    }
                    Ok(CommandResult::Continue)
                }
                "g" | "goto" => {
                    if parts.len() > 1 {
                        if let Ok(index) = parts[1].parse::<usize>() {
                            if index < state.matches.len() {
                                state.current_match_index = index;
                            }
                        }
                    }
                    Ok(CommandResult::Continue)
                }
                "o" | "open" => {
                    if !state.matches.is_empty() {
                        let current_match = &state.matches[state.current_match_index];
                        self.open_file(current_match)?;
                    }
                    Ok(CommandResult::Continue)
                }
                "save" => {
                    if parts.len() > 1 {
                        self.save_results(&state.matches, parts[1])?;
                    } else {
                        self.save_results(&state.matches, "results.txt")?;
                    }
                    Ok(CommandResult::Continue)
                }
                "stats" => {
                    self.show_statistics(state);
                    Ok(CommandResult::Continue)
                }
                "history" => {
                    self.show_history();
                    Ok(CommandResult::Continue)
                }
                _ => {
                    state.pattern = input.to_string();
                    Ok(CommandResult::Search)
                }
            }
        }
        /// Show help information
        fn show_help(&self) {
            {
                ::std::io::_print(
                    format_args!("\n{0}\n", "Available commands:".green().bold()),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "  {0} - Search for pattern\n",
                        "search <pattern>".yellow(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "  {0} - Filter current results\n",
                        "filter <text>".yellow(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!("  {0} - Clear filters\n", "clear".yellow()),
                );
            };
            {
                ::std::io::_print(format_args!("  {0} - Next match\n", "next".yellow()));
            };
            {
                ::std::io::_print(
                    format_args!("  {0} - Previous match\n", "prev".yellow()),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "  {0} - Go to match number\n",
                        "goto <number>".yellow(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "  {0} - Open current match in editor\n",
                        "open".yellow(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "  {0} - Save results to file\n",
                        "save [filename]".yellow(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!("  {0} - Show statistics\n", "stats".yellow()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("  {0} - Show command history\n", "history".yellow()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("  {0} - Show this help\n", "help".yellow()),
                );
            };
            {
                ::std::io::_print(format_args!("  {0} - Quit\n", "quit".yellow()));
            };
        }
        /// Open file in editor
        fn open_file(&self, match_: &crate::processor::SearchMatch) -> RfgrepResult<()> {
            let editor = std::env::var("EDITOR").unwrap_or_else(|_| "nano".to_string());
            let status = std::process::Command::new(&editor).arg(&match_.path).status()?;
            if !status.success() {
                {
                    ::std::io::_eprint(
                        format_args!("Failed to open file in editor: {0}\n", editor),
                    );
                };
            }
            Ok(())
        }
        /// Save results to file
        fn save_results(
            &self,
            matches: &[crate::processor::SearchMatch],
            filename: &str,
        ) -> RfgrepResult<()> {
            let mut content = String::new();
            for m in matches {
                content
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}:{1}:{2}: {3}\n",
                                    m.path.display(),
                                    m.line_number,
                                    m.column_start + 1,
                                    m.line,
                                ),
                            )
                        }),
                    );
            }
            std::fs::write(filename, content)?;
            {
                ::std::io::_print(
                    format_args!("Results saved to {0}\n", filename.green()),
                );
            };
            Ok(())
        }
        /// Show search statistics
        fn show_statistics(&self, state: &SearchState) {
            {
                ::std::io::_print(
                    format_args!("\n{0}\n", "Search Statistics:".green().bold()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("Pattern: {0}\n", state.pattern.yellow()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("Files searched: {0}\n", state.files.len()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("Total matches: {0}\n", state.matches.len()),
                );
            };
            if !state.matches.is_empty() {
                let files_with_matches: std::collections::HashSet<_> = state
                    .matches
                    .iter()
                    .map(|m| &m.path)
                    .collect();
                {
                    ::std::io::_print(
                        format_args!(
                            "Files with matches: {0}\n",
                            files_with_matches.len(),
                        ),
                    );
                };
                let mut ext_counts = std::collections::HashMap::new();
                for m in &state.matches {
                    if let Some(ext) = m.path.extension().and_then(|e| e.to_str()) {
                        *ext_counts.entry(ext).or_insert(0) += 1;
                    }
                }
                let mut ext_vec: Vec<_> = ext_counts.into_iter().collect();
                ext_vec.sort_by(|a, b| b.1.cmp(&a.1));
                if !ext_vec.is_empty() {
                    {
                        ::std::io::_print(format_args!("\nMatches by file type:\n"));
                    };
                    for (ext, count) in ext_vec.iter().take(5) {
                        {
                            ::std::io::_print(format_args!("  .{0}: {1}\n", ext, count));
                        };
                    }
                }
            }
        }
        /// Add command to history
        fn add_to_history(&mut self, command: String) {
            if self.history.len() >= self.max_history {
                self.history.pop_front();
            }
            self.history.push_back(command);
        }
        /// Show command history
        fn show_history(&self) {
            {
                ::std::io::_print(
                    format_args!("\n{0}\n", "Command History:".green().bold()),
                );
            };
            for (i, cmd) in self.history.iter().enumerate() {
                {
                    ::std::io::_print(format_args!("  {0}: {1}\n", i + 1, cmd));
                };
            }
        }
    }
    /// Command processing result
    enum CommandResult {
        Continue,
        Quit,
        Search,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CommandResult {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    CommandResult::Continue => "Continue",
                    CommandResult::Quit => "Quit",
                    CommandResult::Search => "Search",
                },
            )
        }
    }
    /// Regex search implementation for interactive mode
    pub struct RegexSearch {
        pattern: String,
        regex: regex::Regex,
    }
    impl RegexSearch {
        pub fn new(pattern: &str) -> RfgrepResult<Self> {
            let regex = regex::Regex::new(pattern)
                .map_err(|e| RfgrepError::Other(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("Invalid regex: {0}", e))
                    }),
                ))?;
            Ok(Self {
                pattern: pattern.to_string(),
                regex,
            })
        }
    }
    impl SearchAlgorithmTrait for RegexSearch {
        fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
            self.regex.find_iter(text).map(|m| m.start()).collect()
        }
        fn search_with_context(
            &self,
            text: &str,
            _pattern: &str,
            context_lines: usize,
        ) -> Vec<crate::processor::SearchMatch> {
            let matches = self.search(text, _pattern);
            let lines: Vec<&str> = text.lines().collect();
            let mut results = Vec::new();
            for &match_pos in &matches {
                let pre_lines = text[..match_pos].lines().count();
                let line_number = pre_lines.max(1);
                let line_index = line_number - 1;
                if line_index < lines.len() {
                    let line = lines[line_index];
                    let context_before = self
                        .get_context_before(&lines, line_index, context_lines);
                    let context_after = self
                        .get_context_after(&lines, line_index, context_lines);
                    let matched_text = self
                        .regex
                        .find(&text[match_pos..])
                        .map(|m| m.as_str().to_string())
                        .unwrap_or_default();
                    results
                        .push(crate::processor::SearchMatch {
                            path: std::path::PathBuf::new(),
                            line_number,
                            line: line.to_string(),
                            context_before,
                            context_after,
                            matched_text: matched_text.clone(),
                            column_start: match_pos
                                - text[..match_pos].rfind('\n').unwrap_or(0),
                            column_end: match_pos
                                - text[..match_pos].rfind('\n').unwrap_or(0)
                                + matched_text.len(),
                        });
                }
            }
            results
        }
        fn name(&self) -> &'static str {
            "Regex"
        }
    }
    impl RegexSearch {
        fn get_context_before(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let start = current_line.saturating_sub(context_lines);
            (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
        }
        fn get_context_after(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let end = (current_line + context_lines + 1).min(lines.len());
            ((current_line + 1)..end).map(|i| (i + 1, lines[i].to_string())).collect()
        }
    }
}
/// File listing and information utilities
pub mod list {
    //! File listing engine with advanced filtering and statistics
    use crate::error::{Result as RfgrepResult, RfgrepError};
    use crate::metrics::Metrics;
    use crate::walker::walk_dir;
    use colored::*;
    use std::path::Path;
    use std::sync::Arc;
    /// File information for listing
    pub struct FileInfo {
        pub path: std::path::PathBuf,
        pub size: u64,
        pub extension: String,
        pub is_binary: bool,
        pub modified: Option<std::time::SystemTime>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FileInfo {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "FileInfo",
                "path",
                &self.path,
                "size",
                &self.size,
                "extension",
                &self.extension,
                "is_binary",
                &self.is_binary,
                "modified",
                &&self.modified,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FileInfo {
        #[inline]
        fn clone(&self) -> FileInfo {
            FileInfo {
                path: ::core::clone::Clone::clone(&self.path),
                size: ::core::clone::Clone::clone(&self.size),
                extension: ::core::clone::Clone::clone(&self.extension),
                is_binary: ::core::clone::Clone::clone(&self.is_binary),
                modified: ::core::clone::Clone::clone(&self.modified),
            }
        }
    }
    /// List engine for file operations
    pub struct ListEngine {
        metrics: Arc<Metrics>,
    }
    impl ListEngine {
        /// Create a new list engine
        pub fn new(metrics: Arc<Metrics>) -> RfgrepResult<Self> {
            Ok(Self { metrics })
        }
        /// List files with various filters and options
        pub async fn list_files(
            &self,
            root_path: &Path,
            recursive: bool,
            show_hidden: bool,
            extensions: Option<&[String]>,
            max_size: Option<usize>,
            min_size: Option<usize>,
            sort: crate::cli::SortCriteria,
            reverse: bool,
            limit: Option<usize>,
        ) -> RfgrepResult<Vec<FileInfo>> {
            let entries: Vec<_> = walk_dir(root_path, recursive, show_hidden).collect();
            use rayon::prelude::*;
            use std::sync::Mutex;
            let file_results = Mutex::new(Vec::new());
            let errors = Mutex::new(Vec::new());
            entries
                .par_iter()
                .for_each(|entry| {
                    let path = entry.path();
                    if path.is_dir() {
                        return;
                    }
                    if !self.should_include_file(path, extensions, max_size, min_size) {
                        return;
                    }
                    match self.get_file_info(path) {
                        Ok(file_info) => {
                            file_results.lock().unwrap().push(file_info);
                        }
                        Err(e) => {
                            errors.lock().unwrap().push(e);
                        }
                    }
                });
            let collected_errors = errors.into_inner().unwrap();
            if !collected_errors.is_empty() {
                {
                    ::std::io::_eprint(
                        format_args!("Errors encountered during file listing:\n"),
                    );
                };
                for err in collected_errors {
                    {
                        ::std::io::_eprint(format_args!("  {0}\n", err));
                    };
                }
            }
            let mut files = file_results.into_inner().unwrap();
            self.sort_files(&mut files, sort, reverse);
            if let Some(limit) = limit {
                files.truncate(limit);
            }
            self.metrics.files_scanned.inc_by(files.len() as u64);
            Ok(files)
        }
        /// Check if a file should be included based on filters
        fn should_include_file(
            &self,
            path: &Path,
            extensions: Option<&[String]>,
            max_size: Option<usize>,
            min_size: Option<usize>,
        ) -> bool {
            if let Some(extensions) = extensions {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    if !extensions.iter().any(|e| e.eq_ignore_ascii_case(ext)) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            if let Ok(metadata) = path.metadata() {
                let size_mb = metadata.len() as f64 / (1024.0 * 1024.0);
                if let Some(max) = max_size {
                    if size_mb > max as f64 {
                        return false;
                    }
                }
                if let Some(min) = min_size {
                    if size_mb < min as f64 {
                        return false;
                    }
                }
            }
            true
        }
        /// Get file information
        fn get_file_info(&self, path: &Path) -> RfgrepResult<FileInfo> {
            let metadata = std::fs::metadata(path)?;
            let extension = path
                .extension()
                .and_then(|e| e.to_str())
                .unwrap_or("none")
                .to_string();
            Ok(FileInfo {
                path: path.to_path_buf(),
                size: metadata.len(),
                extension,
                is_binary: crate::processor::is_binary(path),
                modified: metadata.modified().ok(),
            })
        }
        /// Sort files based on criteria
        fn sort_files(
            &self,
            files: &mut [FileInfo],
            sort: crate::cli::SortCriteria,
            reverse: bool,
        ) {
            match sort {
                crate::cli::SortCriteria::Name => {
                    files.sort_by(|a, b| a.path.cmp(&b.path));
                }
                crate::cli::SortCriteria::Size => {
                    files.sort_by(|a, b| a.size.cmp(&b.size));
                }
                crate::cli::SortCriteria::Date => {
                    files
                        .sort_by(|a, b| match (&a.modified, &b.modified) {
                            (Some(a_time), Some(b_time)) => a_time.cmp(b_time),
                            (Some(_), None) => std::cmp::Ordering::Less,
                            (None, Some(_)) => std::cmp::Ordering::Greater,
                            (None, None) => std::cmp::Ordering::Equal,
                        });
                }
                crate::cli::SortCriteria::Type => {
                    files.sort_by(|a, b| a.extension.cmp(&b.extension));
                }
                crate::cli::SortCriteria::Path => {
                    files.sort_by(|a, b| a.path.cmp(&b.path));
                }
            }
            if reverse {
                files.reverse();
            }
        }
        /// Print files in long format
        pub fn print_long_format(&self, files: &[FileInfo]) {
            if files.is_empty() {
                {
                    ::std::io::_print(format_args!("No files found\n"));
                };
                return;
            }
            {
                ::std::io::_print(
                    format_args!(
                        "{0:<12} {1:<8} {2:<6} {3}\n",
                        "SIZE",
                        "BINARY",
                        "TYPE",
                        "PATH",
                    ),
                );
            };
            {
                ::std::io::_print(format_args!("{0}\n", "-".repeat(50)));
            };
            for file in files {
                let size_str = self.format_size(file.size);
                let binary_str = if file.is_binary { "yes" } else { "no" };
                let type_str = if file.extension == "none" {
                    "file"
                } else {
                    &file.extension
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "{0:<12} {1:<8} {2:<6} {3}\n",
                            size_str,
                            binary_str,
                            type_str,
                            file.path.display(),
                        ),
                    );
                };
            }
        }
        /// Print files in simple format
        pub fn print_simple_list(&self, files: &[FileInfo]) {
            for file in files {
                {
                    ::std::io::_print(format_args!("{0}\n", file.path.display()));
                };
            }
        }
        /// Print file statistics
        pub fn print_statistics(&self, files: &[FileInfo]) {
            if files.is_empty() {
                {
                    ::std::io::_print(format_args!("No files found\n"));
                };
                return;
            }
            let total_size: u64 = files.iter().map(|f| f.size).sum();
            let binary_count = files.iter().filter(|f| f.is_binary).count();
            let text_count = files.len() - binary_count;
            let mut ext_counts = std::collections::HashMap::new();
            for file in files {
                *ext_counts.entry(&file.extension).or_insert(0) += 1;
            }
            let mut ext_vec: Vec<_> = ext_counts.into_iter().collect();
            ext_vec.sort_by(|a, b| b.1.cmp(&a.1));
            {
                ::std::io::_print(format_args!("\n{0}\n", "Statistics:".green().bold()));
            };
            {
                ::std::io::_print(
                    format_args!("{0}: {1}\n", "Total files".cyan(), files.len()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("{0}: {1}\n", "Text files".cyan(), text_count),
                );
            };
            {
                ::std::io::_print(
                    format_args!("{0}: {1}\n", "Binary files".cyan(), binary_count),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "{0}: {1}\n",
                        "Total size".cyan(),
                        self.format_size(total_size),
                    ),
                );
            };
            if !ext_vec.is_empty() {
                {
                    ::std::io::_print(
                        format_args!("\n{0}\n", "File types:".green().bold()),
                    );
                };
                for (ext, count) in ext_vec.iter().take(10) {
                    let ext_display = if *ext == "none" { "no extension" } else { ext };
                    {
                        ::std::io::_print(
                            format_args!(
                                "  {0}: {1}\n",
                                ::alloc::__export::must_use({
                                        ::alloc::fmt::format(format_args!(".{0}", ext_display))
                                    })
                                    .cyan(),
                                count,
                            ),
                        );
                    };
                }
            }
        }
        /// Copy file list to clipboard
        pub fn copy_to_clipboard(&self, files: &[FileInfo]) -> RfgrepResult<()> {
            let content = files
                .iter()
                .map(|f| f.path.display().to_string())
                .collect::<Vec<_>>()
                .join("\n");
            let can_use_clipboard = std::env::var("DISPLAY").is_ok()
                || std::env::var("WAYLAND_DISPLAY").is_ok();
            if can_use_clipboard {
                match arboard::Clipboard::new() {
                    Ok(mut clipboard) => {
                        clipboard
                            .set_text(content)
                            .map_err(|e| RfgrepError::Other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Clipboard error: {0}", e),
                                    )
                                }),
                            ))?;
                        {
                            ::std::io::_print(
                                format_args!(
                                    "\n{0}\n",
                                    "File list copied to clipboard!".green(),
                                ),
                            );
                        };
                    }
                    Err(e) => {
                        self.fallback_to_file(&content)?;
                        {
                            ::std::io::_eprint(
                                format_args!("Clipboard init failed: {0}\n", e),
                            );
                        };
                    }
                }
            } else {
                self.fallback_to_file(&content)?;
            }
            Ok(())
        }
        /// Fallback to writing to a temporary file
        fn fallback_to_file(&self, content: &str) -> RfgrepResult<()> {
            let tmp = std::env::temp_dir().join("rfgrep_files.txt");
            std::fs::write(&tmp, content).map_err(|e| RfgrepError::Io(e))?;
            {
                ::std::io::_print(
                    format_args!(
                        "\n{0} {1}\n",
                        "File list written to".green(),
                        tmp.display(),
                    ),
                );
            };
            Ok(())
        }
        /// Format file size in human-readable format
        fn format_size(&self, bytes: u64) -> String {
            const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB"];
            const THRESHOLD: f64 = 1024.0;
            if bytes == 0 {
                return "0 B".to_string();
            }
            let mut size = bytes as f64;
            let mut unit_index = 0;
            while size >= THRESHOLD && unit_index < UNITS.len() - 1 {
                size /= THRESHOLD;
                unit_index += 1;
            }
            if unit_index == 0 {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("{0} {1}", bytes, UNITS[unit_index]),
                    )
                })
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("{0:.1} {1}", size, UNITS[unit_index]),
                    )
                })
            }
        }
    }
}
/// Memory management and optimization
mod memory {
    use crate::config::PerformanceConfig;
    use log::debug;
    use std::sync::atomic::{AtomicU64, Ordering};
    use std::sync::Arc;
    #[allow(dead_code)]
    pub struct AdaptiveMemoryManager {
        config: PerformanceConfig,
        current_memory_usage: Arc<AtomicU64>,
        peak_memory_usage: Arc<AtomicU64>,
    }
    impl AdaptiveMemoryManager {
        #[allow(dead_code)]
        pub fn new(config: PerformanceConfig) -> Self {
            Self {
                config,
                current_memory_usage: Arc::new(AtomicU64::new(0)),
                peak_memory_usage: Arc::new(AtomicU64::new(0)),
            }
        }
        #[allow(dead_code)]
        pub fn get_mmap_threshold(&self) -> u64 {
            if !self.config.adaptive_memory {
                return self.config.mmap_threshold_mb * 1024 * 1024;
            }
            let available_memory = self.get_available_memory();
            let max_memory = self.config.max_memory_usage_mb * 1024 * 1024;
            let adaptive_threshold = (available_memory / 4).min(max_memory);
            let base_threshold = self.config.mmap_threshold_mb * 1024 * 1024;
            let threshold = adaptive_threshold
                .max(base_threshold)
                .min(1024 * 1024 * 1024);
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Adaptive mmap threshold: {0}MB",
                                threshold / 1024 / 1024,
                            ),
                            lvl,
                            &(
                                "rfgrep::memory",
                                "rfgrep::memory",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            threshold
        }
        #[allow(dead_code)]
        pub fn get_chunk_size(&self, total_items: usize) -> usize {
            let base_chunk_size = 100;
            let multiplier = self.config.chunk_size_multiplier;
            let cpu_cores = num_cpus::get();
            let memory_factor = 1.0;
            let cpu_factor = cpu_cores as f64;
            let adjusted_chunk_size = (base_chunk_size as f64 * multiplier
                * memory_factor / cpu_factor.sqrt()) as usize;
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Adaptive chunk size: {0}",
                                adjusted_chunk_size,
                            ),
                            lvl,
                            &(
                                "rfgrep::memory",
                                "rfgrep::memory",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            adjusted_chunk_size.max(1).min(total_items)
        }
        #[allow(dead_code)]
        pub fn should_use_mmap(&self, file_size: u64) -> bool {
            let threshold = self.get_mmap_threshold();
            file_size >= threshold
        }
        #[allow(dead_code)]
        pub fn update_memory_usage(&self, bytes: u64) {
            let current = self.current_memory_usage.load(Ordering::Relaxed);
            let new_val = current.saturating_add(bytes);
            self.current_memory_usage.store(new_val, Ordering::Relaxed);
            let mut prev_peak = self.peak_memory_usage.load(Ordering::Relaxed);
            while new_val > prev_peak {
                match self
                    .peak_memory_usage
                    .compare_exchange(
                        prev_peak,
                        new_val,
                        Ordering::Relaxed,
                        Ordering::Relaxed,
                    )
                {
                    Ok(_) => break,
                    Err(actual) => prev_peak = actual,
                }
            }
        }
        #[allow(dead_code)]
        fn get_available_memory(&self) -> u64 {
            8 * 1024 * 1024 * 1024
        }
        #[allow(dead_code)]
        pub fn get_current_memory_usage(&self) -> u64 {
            self.current_memory_usage.load(Ordering::Relaxed)
        }
        #[allow(dead_code)]
        pub fn reset_memory_usage(&self) {
            self.current_memory_usage.store(0, Ordering::Relaxed);
            self.peak_memory_usage.store(0, Ordering::Relaxed);
        }
    }
    /// Memory usage statistics
    #[allow(dead_code)]
    pub struct MemoryStats {
        pub current_usage: u64,
        pub peak_usage: u64,
        pub available_memory: u64,
        pub mmap_threshold: u64,
        pub chunk_size: usize,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for MemoryStats {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "MemoryStats",
                "current_usage",
                &self.current_usage,
                "peak_usage",
                &self.peak_usage,
                "available_memory",
                &self.available_memory,
                "mmap_threshold",
                &self.mmap_threshold,
                "chunk_size",
                &&self.chunk_size,
            )
        }
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::clone::Clone for MemoryStats {
        #[inline]
        fn clone(&self) -> MemoryStats {
            MemoryStats {
                current_usage: ::core::clone::Clone::clone(&self.current_usage),
                peak_usage: ::core::clone::Clone::clone(&self.peak_usage),
                available_memory: ::core::clone::Clone::clone(&self.available_memory),
                mmap_threshold: ::core::clone::Clone::clone(&self.mmap_threshold),
                chunk_size: ::core::clone::Clone::clone(&self.chunk_size),
            }
        }
    }
    impl AdaptiveMemoryManager {
        #[allow(dead_code)]
        pub fn get_stats(&self) -> MemoryStats {
            MemoryStats {
                current_usage: self.get_current_memory_usage(),
                peak_usage: self.peak_memory_usage.load(Ordering::Relaxed),
                available_memory: self.get_available_memory(),
                mmap_threshold: self.get_mmap_threshold(),
                chunk_size: self.get_chunk_size(100),
            }
        }
    }
}
/// Performance metrics and monitoring
pub mod metrics {
    use prometheus::{Encoder, IntCounter, Opts, Registry, TextEncoder};
    use std::sync::Arc;
    pub struct Metrics {
        pub files_scanned: IntCounter,
        pub matches_found: IntCounter,
        pub files_skipped: IntCounter,
        pub worker_timeouts: IntCounter,
        registry: Arc<Registry>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Metrics {
        #[inline]
        fn clone(&self) -> Metrics {
            Metrics {
                files_scanned: ::core::clone::Clone::clone(&self.files_scanned),
                matches_found: ::core::clone::Clone::clone(&self.matches_found),
                files_skipped: ::core::clone::Clone::clone(&self.files_skipped),
                worker_timeouts: ::core::clone::Clone::clone(&self.worker_timeouts),
                registry: ::core::clone::Clone::clone(&self.registry),
            }
        }
    }
    impl Default for Metrics {
        fn default() -> Self {
            Self::new()
        }
    }
    impl Metrics {
        pub fn new() -> Self {
            let registry = Registry::new();
            let files_scanned = IntCounter::with_opts(
                    Opts::new("files_scanned", "Number of files scanned"),
                )
                .unwrap();
            let matches_found = IntCounter::with_opts(
                    Opts::new("matches_found", "Number of matches found"),
                )
                .unwrap();
            let files_skipped = IntCounter::with_opts(
                    Opts::new("files_skipped", "Number of files skipped by heuristics"),
                )
                .unwrap();
            let worker_timeouts = IntCounter::with_opts(
                    Opts::new("worker_timeouts", "Number of worker timeouts"),
                )
                .unwrap();
            registry.register(Box::new(files_scanned.clone())).ok();
            registry.register(Box::new(matches_found.clone())).ok();
            registry.register(Box::new(files_skipped.clone())).ok();
            registry.register(Box::new(worker_timeouts.clone())).ok();
            Metrics {
                files_scanned,
                matches_found,
                files_skipped,
                worker_timeouts,
                registry: Arc::new(registry),
            }
        }
        pub fn gather(&self) -> String {
            let metric_families = self.registry.gather();
            let mut buffer = Vec::new();
            let encoder = TextEncoder::new();
            encoder.encode(&metric_families, &mut buffer).unwrap();
            String::from_utf8(buffer).unwrap_or_default()
        }
    }
}
/// Output format implementations (JSON, XML, HTML, Markdown)
mod output_formats {
    use crate::processor::SearchMatch;
    use serde_json::{json, Value};
    use std::path::Path;
    /// Output format types
    #[allow(dead_code)]
    pub enum OutputFormat {
        Text,
        Json,
        Xml,
        Html,
        Markdown,
        Csv,
        Tsv,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for OutputFormat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    OutputFormat::Text => "Text",
                    OutputFormat::Json => "Json",
                    OutputFormat::Xml => "Xml",
                    OutputFormat::Html => "Html",
                    OutputFormat::Markdown => "Markdown",
                    OutputFormat::Csv => "Csv",
                    OutputFormat::Tsv => "Tsv",
                },
            )
        }
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::clone::Clone for OutputFormat {
        #[inline]
        fn clone(&self) -> OutputFormat {
            match self {
                OutputFormat::Text => OutputFormat::Text,
                OutputFormat::Json => OutputFormat::Json,
                OutputFormat::Xml => OutputFormat::Xml,
                OutputFormat::Html => OutputFormat::Html,
                OutputFormat::Markdown => OutputFormat::Markdown,
                OutputFormat::Csv => OutputFormat::Csv,
                OutputFormat::Tsv => OutputFormat::Tsv,
            }
        }
    }
    /// Default implementation for OutputFormat
    impl Default for OutputFormat {
        fn default() -> Self {
            OutputFormat::Text
        }
    }
    /// Output formatter for different formats
    #[allow(dead_code)]
    pub struct OutputFormatter {
        format: OutputFormat,
        include_metadata: bool,
        include_context: bool,
        use_color: bool,
        ndjson: bool,
    }
    impl Default for OutputFormatter {
        fn default() -> Self {
            Self {
                format: OutputFormat::default(),
                include_metadata: true,
                include_context: true,
                use_color: is_terminal::is_terminal(&std::io::stdout()),
                ndjson: false,
            }
        }
    }
    impl OutputFormatter {
        #[allow(dead_code)]
        pub fn new(format: OutputFormat) -> Self {
            Self {
                format,
                include_metadata: true,
                include_context: true,
                use_color: is_terminal::is_terminal(&std::io::stdout()),
                ndjson: false,
            }
        }
        #[allow(dead_code)]
        pub fn with_ndjson(mut self, ndjson: bool) -> Self {
            self.ndjson = ndjson;
            self
        }
        #[allow(dead_code)]
        pub fn with_color(mut self, use_color: bool) -> Self {
            self.use_color = use_color;
            self
        }
        #[allow(dead_code)]
        pub fn with_metadata(mut self, include: bool) -> Self {
            self.include_metadata = include;
            self
        }
        #[allow(dead_code)]
        pub fn with_context(mut self, include: bool) -> Self {
            self.include_context = include;
            self
        }
        /// Format search results
        #[allow(dead_code)]
        pub fn format_results(
            &self,
            matches: &[SearchMatch],
            query: &str,
            path: &Path,
        ) -> String {
            match self.format {
                OutputFormat::Text => self.format_text(matches, query, path),
                OutputFormat::Json => self.format_json(matches, query, path),
                OutputFormat::Xml => self.format_xml(matches, query, path),
                OutputFormat::Html => self.format_html(matches, query, path),
                OutputFormat::Markdown => self.format_markdown(matches, query, path),
                OutputFormat::Csv => self.format_csv(matches, query, path),
                OutputFormat::Tsv => self.format_tsv(matches, query, path),
            }
        }
        /// Format as JSON
        #[allow(dead_code)]
        fn format_json(
            &self,
            matches: &[SearchMatch],
            query: &str,
            path: &Path,
        ) -> String {
            if self.ndjson {
                let mut out = String::new();
                for m in matches {
                    let mut match_obj = ::serde_json::Value::Object({
                        let mut object = ::serde_json::Map::new();
                        let _ = object
                            .insert(
                                ("query").into(),
                                ::serde_json::to_value(&query).unwrap(),
                            );
                        let _ = object
                            .insert(
                                ("path").into(),
                                ::serde_json::to_value(&m.path.to_string_lossy()).unwrap(),
                            );
                        let _ = object
                            .insert(
                                ("line_number").into(),
                                ::serde_json::to_value(&m.line_number).unwrap(),
                            );
                        let _ = object
                            .insert(
                                ("line").into(),
                                ::serde_json::to_value(&m.line).unwrap(),
                            );
                        let _ = object
                            .insert(
                                ("matched_text").into(),
                                ::serde_json::to_value(&m.matched_text).unwrap(),
                            );
                        let _ = object
                            .insert(
                                ("column_start").into(),
                                ::serde_json::to_value(&m.column_start).unwrap(),
                            );
                        let _ = object
                            .insert(
                                ("column_end").into(),
                                ::serde_json::to_value(&m.column_end).unwrap(),
                            );
                        object
                    });
                    if self.include_context {
                        let context_before: Vec<Value> = m
                            .context_before
                            .iter()
                            .map(|(num, line)| {
                                ::serde_json::Value::Object({
                                    let mut object = ::serde_json::Map::new();
                                    let _ = object
                                        .insert(
                                            ("line_number").into(),
                                            ::serde_json::to_value(&num).unwrap(),
                                        );
                                    let _ = object
                                        .insert(
                                            ("content").into(),
                                            ::serde_json::to_value(&line).unwrap(),
                                        );
                                    object
                                })
                            })
                            .collect();
                        let context_after: Vec<Value> = m
                            .context_after
                            .iter()
                            .map(|(num, line)| {
                                ::serde_json::Value::Object({
                                    let mut object = ::serde_json::Map::new();
                                    let _ = object
                                        .insert(
                                            ("line_number").into(),
                                            ::serde_json::to_value(&num).unwrap(),
                                        );
                                    let _ = object
                                        .insert(
                                            ("content").into(),
                                            ::serde_json::to_value(&line).unwrap(),
                                        );
                                    object
                                })
                            })
                            .collect();
                        match_obj["context_before"] = Value::Array(context_before);
                        match_obj["context_after"] = Value::Array(context_after);
                    }
                    match serde_json::to_string(&match_obj) {
                        Ok(s) => {
                            out.push_str(&s);
                            out.push('\n');
                        }
                        Err(e) => {
                            let err_obj = ::serde_json::Value::Object({
                                let mut object = ::serde_json::Map::new();
                                let _ = object
                                    .insert(
                                        ("error").into(),
                                        ::serde_json::to_value(&"json_serialization_failed")
                                            .unwrap(),
                                    );
                                let _ = object
                                    .insert(
                                        ("details").into(),
                                        ::serde_json::to_value(&e.to_string()).unwrap(),
                                    );
                                object
                            });
                            if let Ok(s) = serde_json::to_string(&err_obj) {
                                out.push_str(&s);
                                out.push('\n');
                            } else {
                                out.push_str("{\"error\":\"json_serialization_failed\"}\n");
                            }
                        }
                    }
                }
                return out;
            }
            let mut result = ::serde_json::Value::Object({
                let mut object = ::serde_json::Map::new();
                let _ = object
                    .insert(("query").into(), ::serde_json::to_value(&query).unwrap());
                let _ = object
                    .insert(
                        ("path").into(),
                        ::serde_json::to_value(&path.to_string_lossy()).unwrap(),
                    );
                let _ = object
                    .insert(
                        ("total_matches").into(),
                        ::serde_json::to_value(&matches.len()).unwrap(),
                    );
                let _ = object
                    .insert(
                        ("matches").into(),
                        ::serde_json::Value::Array(::alloc::vec::Vec::new()),
                    );
                object
            });
            let matches_array = result["matches"].as_array_mut().unwrap();
            for m in matches {
                let mut match_obj = ::serde_json::Value::Object({
                    let mut object = ::serde_json::Map::new();
                    let _ = object
                        .insert(
                            ("path").into(),
                            ::serde_json::to_value(&m.path.to_string_lossy()).unwrap(),
                        );
                    let _ = object
                        .insert(
                            ("line_number").into(),
                            ::serde_json::to_value(&m.line_number).unwrap(),
                        );
                    let _ = object
                        .insert(
                            ("line").into(),
                            ::serde_json::to_value(&m.line).unwrap(),
                        );
                    let _ = object
                        .insert(
                            ("matched_text").into(),
                            ::serde_json::to_value(&m.matched_text).unwrap(),
                        );
                    let _ = object
                        .insert(
                            ("column_start").into(),
                            ::serde_json::to_value(&m.column_start).unwrap(),
                        );
                    let _ = object
                        .insert(
                            ("column_end").into(),
                            ::serde_json::to_value(&m.column_end).unwrap(),
                        );
                    object
                });
                if self.include_context {
                    let context_before: Vec<Value> = m
                        .context_before
                        .iter()
                        .map(|(num, line)| {
                            ::serde_json::Value::Object({
                                let mut object = ::serde_json::Map::new();
                                let _ = object
                                    .insert(
                                        ("line_number").into(),
                                        ::serde_json::to_value(&num).unwrap(),
                                    );
                                let _ = object
                                    .insert(
                                        ("content").into(),
                                        ::serde_json::to_value(&line).unwrap(),
                                    );
                                object
                            })
                        })
                        .collect();
                    let context_after: Vec<Value> = m
                        .context_after
                        .iter()
                        .map(|(num, line)| {
                            ::serde_json::Value::Object({
                                let mut object = ::serde_json::Map::new();
                                let _ = object
                                    .insert(
                                        ("line_number").into(),
                                        ::serde_json::to_value(&num).unwrap(),
                                    );
                                let _ = object
                                    .insert(
                                        ("content").into(),
                                        ::serde_json::to_value(&line).unwrap(),
                                    );
                                object
                            })
                        })
                        .collect();
                    match_obj["context_before"] = Value::Array(context_before);
                    match_obj["context_after"] = Value::Array(context_after);
                }
                matches_array.push(match_obj);
            }
            serde_json::to_string(&result)
                .unwrap_or_else(|e| {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{{\"error\":\"json_serialization_failed\",\"details\":\"{0}\"}}",
                                e,
                            ),
                        )
                    })
                })
        }
        /// Format as plain text (default)
        #[allow(dead_code)]
        fn format_text(
            &self,
            matches: &[SearchMatch],
            query: &str,
            path: &Path,
        ) -> String {
            let mut output = String::new();
            if self.include_metadata {
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("Query: {0}\n", query))
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Path: {0}\n", path.display()),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Total matches: {0}\n\n", matches.len()),
                            )
                        }),
                    );
            }
            for m in matches {
                let line_len = m.line.len();
                let column_start = m.column_start.min(line_len);
                let column_end = m.column_end.min(line_len);
                let before = if column_start < line_len {
                    &m.line[..column_start]
                } else {
                    ""
                };
                let matched = &m.matched_text;
                {
                    ::std::io::_print(
                        format_args!(
                            "column_end :{0} \nline_len: {1}\n",
                            &column_end,
                            &line_len,
                        ),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!("char at column_end: {0}\n", &m.line[column_end..]),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "char at column_start: {0}\n",
                            &m.line[column_start..],
                        ),
                    );
                };
                let after = if column_end < line_len {
                    &m.line[column_end..]
                } else {
                    ""
                };
                if self.use_color {
                    let highlighted = ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("\u{1b}[33m{0}\u{1b}[0m", matched),
                        )
                    });
                    output
                        .push_str(
                            &::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}:{1}:{2}: {3}{4}{5}\n",
                                        m.path.display(),
                                        m.line_number,
                                        column_start + 1,
                                        before,
                                        highlighted,
                                        after,
                                    ),
                                )
                            }),
                        );
                } else {
                    output
                        .push_str(
                            &::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}:{1}:{2}: {3}{4}{5}\n",
                                        m.path.display(),
                                        m.line_number,
                                        column_start + 1,
                                        before,
                                        matched,
                                        after,
                                    ),
                                )
                            }),
                        );
                }
                if self.include_context
                    && (!m.context_before.is_empty() || !m.context_after.is_empty())
                {
                    output.push_str("-- context --\n");
                    for (num, line) in &m.context_before {
                        output
                            .push_str(
                                &::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("  {0} â {1}\n", num, line),
                                    )
                                }),
                            );
                    }
                    output
                        .push_str(
                            &::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "â {0} â {1}{2}{3}\n",
                                        m.line_number,
                                        before,
                                        matched,
                                        after,
                                    ),
                                )
                            }),
                        );
                    for (num, line) in &m.context_after {
                        output
                            .push_str(
                                &::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("  {0} â {1}\n", num, line),
                                    )
                                }),
                            );
                    }
                    output.push('\n');
                }
            }
            output
        }
        /// Format as XML
        #[allow(dead_code)]
        fn format_xml(
            &self,
            matches: &[SearchMatch],
            query: &str,
            path: &Path,
        ) -> String {
            let mut output = String::new();
            output.push_str("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
            output.push_str("<search-results>\n");
            if self.include_metadata {
                output.push_str("  <metadata>\n");
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("    <query>{0}</query>\n", escape_xml(query)),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "    <path>{0}</path>\n",
                                    escape_xml(&path.to_string_lossy()),
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "    <total-matches>{0}</total-matches>\n",
                                    matches.len(),
                                ),
                            )
                        }),
                    );
                output.push_str("  </metadata>\n");
            }
            output.push_str("  <matches>\n");
            for (i, m) in matches.iter().enumerate() {
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("    <match index=\"{0}\">\n", i + 1),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "      <line-number>{0}</line-number>\n",
                                    m.line_number,
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "      <line>{0}</line>\n",
                                    escape_xml(&m.line),
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "      <matched-text>{0}</matched-text>\n",
                                    escape_xml(&m.matched_text),
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "      <column-start>{0}</column-start>\n",
                                    m.column_start,
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "      <column-end>{0}</column-end>\n",
                                    m.column_end,
                                ),
                            )
                        }),
                    );
                output.push_str("    </match>\n");
            }
            output.push_str("  </matches>\n");
            output.push_str("</search-results>\n");
            output
        }
        /// Format as HTML
        #[allow(dead_code)]
        fn format_html(
            &self,
            matches: &[SearchMatch],
            query: &str,
            path: &Path,
        ) -> String {
            let mut output = String::new();
            output.push_str("<!DOCTYPE html>\n<html>\n<head>\n");
            output.push_str("<meta charset=\"UTF-8\">\n");
            output.push_str("<title>rfgrep Search Results</title>\n");
            output.push_str("<style>\n");
            output.push_str("body { font-family: monospace; margin: 20px; }\n");
            output
                .push_str(
                    ".match { margin: 10px 0; padding: 10px; border-left: 3px solid #007acc; }\n",
                );
            output.push_str(".line-number { color: #666; }\n");
            output
                .push_str(
                    ".matched-text { background-color: #ffff00; font-weight: bold; }\n",
                );
            output.push_str(".context { color: #888; }\n");
            output
                .push_str(
                    ".metadata { background-color: #f5f5f5; padding: 10px; margin-bottom: 20px; }\n",
                );
            output.push_str("</style>\n</head>\n<body>\n");
            if self.include_metadata {
                output.push_str("<div class=\"metadata\">\n");
                output.push_str("<h2>Search Results</h2>\n");
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "<p><strong>Query:</strong> {0}</p>\n",
                                    escape_html(query),
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "<p><strong>Path:</strong> {0}</p>\n",
                                    escape_html(&path.to_string_lossy()),
                                ),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "<p><strong>Total Matches:</strong> {0}</p>\n",
                                    matches.len(),
                                ),
                            )
                        }),
                    );
                output.push_str("</div>\n");
            }
            for (i, m) in matches.iter().enumerate() {
                output.push_str("<div class=\"match\">\n");
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("<h3>Match {0}</h3>\n", i + 1),
                            )
                        }),
                    );
                let line_len = m.line.len();
                let column_start = m.column_start.min(line_len);
                let column_end = m.column_end.min(line_len);
                let before = if column_start < line_len {
                    &m.line[..column_start]
                } else {
                    ""
                };
                let matched_text = &m.matched_text;
                let after = if column_end < line_len {
                    &m.line[column_end..]
                } else {
                    ""
                };
                output.push_str("<div>");
                let matched_html = ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "<span class=\"matched-text\">{0}</span>",
                            escape_html(matched_text),
                        ),
                    )
                });
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "<span class=\"line-number\">â {0:>4}</span> â {1}{2}{3}",
                                    m.line_number,
                                    escape_html(before),
                                    matched_html,
                                    escape_html(after),
                                ),
                            )
                        }),
                    );
                output.push_str("</div>\n");
                output.push_str("</div>\n");
            }
            output.push_str("</body>\n</html>\n");
            output
        }
        /// Format as Markdown
        #[allow(dead_code)]
        fn format_markdown(
            &self,
            matches: &[SearchMatch],
            query: &str,
            path: &Path,
        ) -> String {
            let mut output = String::new();
            output.push_str("# rfgrep Search Results\n\n");
            if self.include_metadata {
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("**Query:** `{0}`\n", query),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("**Path:** `{0}`\n", path.display()),
                            )
                        }),
                    );
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("**Total Matches:** {0}\n\n", matches.len()),
                            )
                        }),
                    );
            }
            for (i, m) in matches.iter().enumerate() {
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("## Match {0}\n\n", i + 1))
                        }),
                    );
                let line_len = m.line.len();
                let column_start = m.column_start.min(line_len);
                let column_end = m.column_end.min(line_len);
                let before = if column_start < line_len {
                    &m.line[..column_start]
                } else {
                    ""
                };
                let matched = &m.matched_text;
                let after = if column_end < line_len {
                    &m.line[column_end..]
                } else {
                    ""
                };
                output.push_str("**Match:**\n");
                output.push_str("```\n");
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "â {0:>4} â {1}{2}{3}\n",
                                    m.line_number,
                                    before,
                                    matched,
                                    after,
                                ),
                            )
                        }),
                    );
                output.push_str("```\n\n");
            }
            output
        }
        /// Format as CSV
        #[allow(dead_code)]
        fn format_csv(
            &self,
            matches: &[SearchMatch],
            _query: &str,
            _path: &Path,
        ) -> String {
            let mut output = String::default();
            output
                .push_str(
                    "file,line_number,column_start,column_end,matched_text,line_content\n",
                );
            for m in matches {
                let file = escape_csv(&m.path.to_string_lossy());
                let line_content = escape_csv(&m.line);
                let matched_text = escape_csv(&m.matched_text);
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0},{1},{2},{3},{4},{5}\n",
                                    file,
                                    m.line_number,
                                    m.column_start,
                                    m.column_end,
                                    matched_text,
                                    line_content,
                                ),
                            )
                        }),
                    );
            }
            output
        }
        /// Format as TSV
        #[allow(dead_code)]
        fn format_tsv(
            &self,
            matches: &[SearchMatch],
            _query: &str,
            _path: &Path,
        ) -> String {
            let mut output = String::default();
            output
                .push_str(
                    "file\tline_number\tcolumn_start\tcolumn_end\tmatched_text\tline_content\n",
                );
            for m in matches {
                let file = escape_tsv(&m.path.to_string_lossy());
                let line_content = escape_tsv(&m.line);
                let matched_text = escape_tsv(&m.matched_text);
                output
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}\t{1}\t{2}\t{3}\t{4}\t{5}\n",
                                    file,
                                    m.line_number,
                                    m.column_start,
                                    m.column_end,
                                    matched_text,
                                    line_content,
                                ),
                            )
                        }),
                    );
            }
            output
        }
    }
    /// Escape CSV special characters
    #[allow(dead_code)]
    fn escape_csv(s: &str) -> String {
        if s.contains(',') || s.contains('"') || s.contains('\n') || s.contains('\r') {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("\"{0}\"", s.replace("\"", "\"\"")))
            })
        } else {
            s.to_string()
        }
    }
    /// Escape TSV special characters
    #[allow(dead_code)]
    fn escape_tsv(s: &str) -> String {
        s.replace('\t', "\\t").replace('\n', "\\n").replace('\r', "\\r")
    }
    /// Escape XML special characters
    #[allow(dead_code)]
    fn escape_xml(s: &str) -> String {
        s.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&apos;")
    }
    /// Escape HTML special characters
    #[allow(dead_code)]
    fn escape_html(s: &str) -> String {
        s.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#39;")
    }
}
/// High-performance optimization modules
///
/// Includes:
/// - Memory pooling and caching
/// - Parallel processing with adaptive chunking
/// - Zero-copy string processing
/// - Optimized memory-mapped I/O
pub mod performance {
    //! Performance optimization modules for rfgrep v0.3.1
    //! Provides memory optimization, I/O optimization, and parallel processing improvements
    pub mod cache_manager {
        //! Cache management for rfgrep performance optimization
        use std::collections::HashMap;
        use std::hash::Hash;
        use std::sync::{Arc, RwLock};
        use std::time::{Duration, Instant};
        /// Cache entry with timestamp
        pub struct CacheEntry<V> {
            pub value: V,
            pub created_at: Instant,
            pub last_accessed: Instant,
        }
        #[automatically_derived]
        impl<V: ::core::fmt::Debug> ::core::fmt::Debug for CacheEntry<V> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "CacheEntry",
                    "value",
                    &self.value,
                    "created_at",
                    &self.created_at,
                    "last_accessed",
                    &&self.last_accessed,
                )
            }
        }
        #[automatically_derived]
        impl<V: ::core::clone::Clone> ::core::clone::Clone for CacheEntry<V> {
            #[inline]
            fn clone(&self) -> CacheEntry<V> {
                CacheEntry {
                    value: ::core::clone::Clone::clone(&self.value),
                    created_at: ::core::clone::Clone::clone(&self.created_at),
                    last_accessed: ::core::clone::Clone::clone(&self.last_accessed),
                }
            }
        }
        impl<V> CacheEntry<V> {
            pub fn new(value: V) -> Self {
                let now = Instant::now();
                Self {
                    value,
                    created_at: now,
                    last_accessed: now,
                }
            }
            pub fn is_expired(&self, ttl: Duration) -> bool {
                self.created_at.elapsed() > ttl
            }
            pub fn update_access(&mut self) {
                self.last_accessed = Instant::now();
            }
        }
        /// LRU cache implementation
        pub struct LruCache<K, V> {
            capacity: usize,
            entries: HashMap<K, CacheEntry<V>>,
            access_order: Vec<K>,
        }
        impl<K, V> LruCache<K, V>
        where
            K: Hash + Eq + Clone,
        {
            pub fn new(capacity: usize) -> Self {
                Self {
                    capacity,
                    entries: HashMap::new(),
                    access_order: Vec::new(),
                }
            }
            pub fn get(&mut self, key: &K) -> Option<&V> {
                if let Some(entry) = self.entries.get_mut(key) {
                    entry.update_access();
                    if let Some(pos) = self.access_order.iter().position(|k| k == key) {
                        self.access_order.remove(pos);
                    }
                    self.access_order.push(key.clone());
                    Some(&entry.value)
                } else {
                    None
                }
            }
            pub fn insert(&mut self, key: K, value: V) {
                if self.entries.contains_key(&key) {
                    if let Some(entry) = self.entries.get_mut(&key) {
                        entry.value = value;
                        entry.update_access();
                    }
                } else {
                    if self.entries.len() >= self.capacity {
                        if !self.access_order.is_empty() {
                            let lru_key = self.access_order.remove(0);
                            self.entries.remove(&lru_key);
                        }
                    }
                    self.entries.insert(key.clone(), CacheEntry::new(value));
                    self.access_order.push(key);
                }
            }
            pub fn remove(&mut self, key: &K) -> Option<V> {
                if let Some(entry) = self.entries.remove(key) {
                    self.access_order.retain(|k| k != key);
                    Some(entry.value)
                } else {
                    None
                }
            }
            pub fn clear(&mut self) {
                self.entries.clear();
                self.access_order.clear();
            }
            pub fn len(&self) -> usize {
                self.entries.len()
            }
            pub fn is_empty(&self) -> bool {
                self.entries.is_empty()
            }
        }
        /// Thread-safe cache manager
        pub struct CacheManager<K, V> {
            cache: Arc<RwLock<LruCache<K, V>>>,
            ttl: Duration,
        }
        impl<K, V> CacheManager<K, V>
        where
            K: Hash + Eq + Clone + Send + Sync,
            V: Clone + Send + Sync,
        {
            pub fn new(capacity: usize, ttl: Duration) -> Self {
                Self {
                    cache: Arc::new(RwLock::new(LruCache::new(capacity))),
                    ttl,
                }
            }
            pub fn get(&self, key: &K) -> Option<V> {
                let mut cache = self.cache.write().unwrap();
                cache.get(key).cloned()
            }
            pub fn insert(&self, key: K, value: V) {
                let mut cache = self.cache.write().unwrap();
                cache.insert(key, value);
            }
            pub fn remove(&self, key: &K) -> Option<V> {
                let mut cache = self.cache.write().unwrap();
                cache.remove(key)
            }
            pub fn clear(&self) {
                let mut cache = self.cache.write().unwrap();
                cache.clear();
            }
            pub fn cleanup_expired(&self) {
                let mut cache = self.cache.write().unwrap();
                let expired_keys: Vec<K> = cache
                    .entries
                    .iter()
                    .filter(|(_, entry)| entry.is_expired(self.ttl))
                    .map(|(key, _)| key.clone())
                    .collect();
                for key in expired_keys {
                    cache.remove(&key);
                }
            }
            pub fn stats(&self) -> CacheStats {
                let cache = self.cache.read().unwrap();
                CacheStats {
                    size: cache.len(),
                    capacity: cache.capacity,
                }
            }
        }
        /// Cache statistics
        pub struct CacheStats {
            pub size: usize,
            pub capacity: usize,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CacheStats {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "CacheStats",
                    "size",
                    &self.size,
                    "capacity",
                    &&self.capacity,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CacheStats {
            #[inline]
            fn clone(&self) -> CacheStats {
                CacheStats {
                    size: ::core::clone::Clone::clone(&self.size),
                    capacity: ::core::clone::Clone::clone(&self.capacity),
                }
            }
        }
        /// Search result cache
        pub type SearchCache = CacheManager<String, Vec<u8>>;
        impl<K, V> Default for CacheManager<K, V>
        where
            K: Hash + Eq + Clone + Send + Sync,
            V: Clone + Send + Sync,
        {
            fn default() -> Self {
                Self::new(100, Duration::from_secs(60))
            }
        }
    }
    pub mod io_optimizer {
        //! I/O optimization module for efficient file processing
        //! Provides buffered I/O, prefetching, and adaptive strategies
        use crossbeam_channel::{bounded, Receiver, Sender};
        use rayon::prelude::*;
        use std::collections::VecDeque;
        use std::fs::File;
        use std::io::{BufRead, BufReader, Read};
        use std::path::{Path, PathBuf};
        use std::thread;
        /// I/O optimization configuration
        pub struct IoConfig {
            pub buffer_size: usize,
            pub prefetch_enabled: bool,
            pub prefetch_queue_size: usize,
            pub mmap_threshold: usize,
            pub parallel_io: bool,
            pub max_parallel_files: usize,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IoConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "buffer_size",
                    "prefetch_enabled",
                    "prefetch_queue_size",
                    "mmap_threshold",
                    "parallel_io",
                    "max_parallel_files",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.buffer_size,
                    &self.prefetch_enabled,
                    &self.prefetch_queue_size,
                    &self.mmap_threshold,
                    &self.parallel_io,
                    &&self.max_parallel_files,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "IoConfig",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IoConfig {
            #[inline]
            fn clone(&self) -> IoConfig {
                IoConfig {
                    buffer_size: ::core::clone::Clone::clone(&self.buffer_size),
                    prefetch_enabled: ::core::clone::Clone::clone(
                        &self.prefetch_enabled,
                    ),
                    prefetch_queue_size: ::core::clone::Clone::clone(
                        &self.prefetch_queue_size,
                    ),
                    mmap_threshold: ::core::clone::Clone::clone(&self.mmap_threshold),
                    parallel_io: ::core::clone::Clone::clone(&self.parallel_io),
                    max_parallel_files: ::core::clone::Clone::clone(
                        &self.max_parallel_files,
                    ),
                }
            }
        }
        impl Default for IoConfig {
            fn default() -> Self {
                Self {
                    buffer_size: 64 * 1024,
                    prefetch_enabled: true,
                    prefetch_queue_size: 10,
                    mmap_threshold: 16 * 1024 * 1024,
                    parallel_io: true,
                    max_parallel_files: 4,
                }
            }
        }
        /// Optimized file reader with buffering and prefetching
        pub struct OptimizedFileReader {
            config: IoConfig,
            prefetch_sender: Option<Sender<PathBuf>>,
            prefetch_receiver: Option<Receiver<PathBuf>>,
        }
        impl OptimizedFileReader {
            pub fn new(config: IoConfig) -> Self {
                let (prefetch_sender, prefetch_receiver) = if config.prefetch_enabled {
                    let (tx, rx) = bounded(config.prefetch_queue_size);
                    (Some(tx), Some(rx))
                } else {
                    (None, None)
                };
                Self {
                    config,
                    prefetch_sender,
                    prefetch_receiver,
                }
            }
            /// Start prefetching files
            pub fn start_prefetching(&self) {
                if let (Some(_sender), Some(_receiver)) = (
                    &self.prefetch_sender,
                    &self.prefetch_receiver,
                ) {
                    let _config = self.config.clone();
                    let receiver = _receiver.clone();
                    thread::spawn(move || {
                        let mut prefetched_files = VecDeque::new();
                        while let Ok(path) = receiver.recv() {
                            if let Ok(file) = File::open(&path) {
                                prefetched_files.push_back((path, file));
                            }
                        }
                    });
                }
            }
            /// Read file with optimal strategy
            pub fn read_file(&self, path: &Path) -> std::io::Result<Vec<u8>> {
                let metadata = std::fs::metadata(path)?;
                let file_size = metadata.len() as usize;
                if file_size > self.config.mmap_threshold {
                    self.read_file_mmap(path)
                } else {
                    self.read_file_buffered(path)
                }
            }
            /// Read file using memory mapping for large files
            fn read_file_mmap(&self, path: &Path) -> std::io::Result<Vec<u8>> {
                use memmap2::Mmap;
                let file = File::open(path)?;
                let mmap = unsafe { Mmap::map(&file)? };
                Ok(mmap.to_vec())
            }
            /// Read file using buffered I/O for smaller files
            fn read_file_buffered(&self, path: &Path) -> std::io::Result<Vec<u8>> {
                let file = File::open(path)?;
                let mut reader = BufReader::with_capacity(self.config.buffer_size, file);
                let mut buffer = Vec::new();
                reader.read_to_end(&mut buffer)?;
                Ok(buffer)
            }
            /// Read file line by line with buffering
            pub fn read_lines(&self, path: &Path) -> std::io::Result<Vec<String>> {
                let file = File::open(path)?;
                let reader = BufReader::with_capacity(self.config.buffer_size, file);
                let mut lines = Vec::new();
                for line in reader.lines() {
                    lines.push(line?);
                }
                Ok(lines)
            }
            /// Check if file should be processed
            pub fn should_process_file(&self, path: &Path) -> bool {
                if let Ok(metadata) = std::fs::metadata(path) {
                    let file_size = metadata.len() as usize;
                    if file_size > 100 * 1024 * 1024 {
                        return false;
                    }
                }
                if let Some(extension) = path.extension() {
                    if let Some(ext_str) = extension.to_str() {
                        match ext_str.to_lowercase().as_str() {
                            "exe" | "dll" | "so" | "bin" => return false,
                            _ => {}
                        }
                    }
                }
                true
            }
        }
        /// Parallel file processor for concurrent I/O
        pub struct ParallelFileProcessor {
            config: IoConfig,
            thread_pool: rayon::ThreadPool,
        }
        impl ParallelFileProcessor {
            pub fn new(config: IoConfig) -> Self {
                let thread_pool = rayon::ThreadPoolBuilder::new()
                    .num_threads(config.max_parallel_files)
                    .build()
                    .unwrap();
                Self { config, thread_pool }
            }
            /// Process multiple files in parallel
            pub fn process_files<F, R>(
                &self,
                paths: Vec<PathBuf>,
                processor: F,
            ) -> Vec<R>
            where
                F: Fn(PathBuf) -> R + Send + Sync,
                R: Send,
            {
                self.thread_pool
                    .install(|| paths.into_par_iter().map(processor).collect())
            }
            /// Process files with error handling
            pub fn process_files_with_error<F, R, E>(
                &self,
                paths: Vec<PathBuf>,
                processor: F,
            ) -> Vec<Result<R, E>>
            where
                F: Fn(PathBuf) -> Result<R, E> + Send + Sync,
                R: Send,
                E: Send,
            {
                self.thread_pool
                    .install(|| paths.into_par_iter().map(processor).collect())
            }
        }
        /// Adaptive I/O strategy that chooses the best approach
        pub struct AdaptiveIoStrategy {
            config: IoConfig,
            file_reader: OptimizedFileReader,
            parallel_processor: ParallelFileProcessor,
        }
        impl AdaptiveIoStrategy {
            pub fn new(config: IoConfig) -> Self {
                let file_reader = OptimizedFileReader::new(config.clone());
                let parallel_processor = ParallelFileProcessor::new(config.clone());
                Self {
                    config,
                    file_reader,
                    parallel_processor,
                }
            }
            /// Choose the best I/O strategy for the given file
            pub fn choose_strategy(&self, path: &Path) -> IoStrategy {
                if let Ok(metadata) = std::fs::metadata(path) {
                    let file_size = metadata.len() as usize;
                    if file_size > self.config.mmap_threshold {
                        IoStrategy::MemoryMapped
                    } else if file_size > self.config.buffer_size * 4 {
                        IoStrategy::Buffered
                    } else {
                        IoStrategy::Direct
                    }
                } else {
                    IoStrategy::Direct
                }
            }
            /// Process a single file with the optimal strategy
            pub fn process_file<F, R>(
                &self,
                path: PathBuf,
                processor: F,
            ) -> Result<R, std::io::Error>
            where
                F: FnOnce(Vec<u8>) -> R,
            {
                let strategy = self.choose_strategy(&path);
                match strategy {
                    IoStrategy::MemoryMapped => {
                        let content = self.file_reader.read_file_mmap(&path)?;
                        Ok(processor(content))
                    }
                    IoStrategy::Buffered => {
                        let content = self.file_reader.read_file_buffered(&path)?;
                        Ok(processor(content))
                    }
                    IoStrategy::Direct => {
                        let content = std::fs::read(&path)?;
                        Ok(processor(content))
                    }
                }
            }
            /// Process multiple files in parallel
            pub fn process_files_parallel<F, R>(
                &self,
                paths: Vec<PathBuf>,
                processor: F,
            ) -> Vec<Result<R, std::io::Error>>
            where
                F: Fn(Vec<u8>) -> R + Send + Sync,
                R: Send,
            {
                self.parallel_processor
                    .process_files_with_error(
                        paths,
                        |path| self.process_file(path, &processor),
                    )
            }
        }
        /// I/O strategy types
        pub enum IoStrategy {
            Direct,
            Buffered,
            MemoryMapped,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IoStrategy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        IoStrategy::Direct => "Direct",
                        IoStrategy::Buffered => "Buffered",
                        IoStrategy::MemoryMapped => "MemoryMapped",
                    },
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        unsafe impl ::core::clone::TrivialClone for IoStrategy {}
        #[automatically_derived]
        impl ::core::clone::Clone for IoStrategy {
            #[inline]
            fn clone(&self) -> IoStrategy {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for IoStrategy {}
    }
    pub mod memory_pool {
        //! Memory pool for efficient memory-mapped file handling
        use log::debug;
        use memmap2::Mmap;
        use std::collections::HashMap;
        use std::fs::File;
        use std::path::PathBuf;
        use std::sync::{Arc, Mutex, RwLock};
        use std::time::{Duration, Instant};
        /// Memory pool for managing memory-mapped files
        pub struct MemoryPool {
            /// Pool of available memory maps
            pool: Arc<RwLock<HashMap<PathBuf, Arc<Mmap>>>>,
            /// Metadata for pooled memory maps
            metadata: Arc<RwLock<HashMap<PathBuf, MmapMetadata>>>,
            /// Maximum number of memory maps to keep in pool
            max_pool_size: usize,
            /// Maximum age for cached memory maps
            max_age: Duration,
            /// Current memory usage in bytes
            memory_usage: Arc<Mutex<usize>>,
            /// Memory pressure threshold
            memory_threshold: usize,
        }
        /// Metadata for pooled memory maps
        struct MmapMetadata {
            last_accessed: Instant,
            file_size: u64,
            access_count: u64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MmapMetadata {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "MmapMetadata",
                    "last_accessed",
                    &self.last_accessed,
                    "file_size",
                    &self.file_size,
                    "access_count",
                    &&self.access_count,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MmapMetadata {
            #[inline]
            fn clone(&self) -> MmapMetadata {
                MmapMetadata {
                    last_accessed: ::core::clone::Clone::clone(&self.last_accessed),
                    file_size: ::core::clone::Clone::clone(&self.file_size),
                    access_count: ::core::clone::Clone::clone(&self.access_count),
                }
            }
        }
        impl MemoryPool {
            /// Create a new memory pool
            pub fn new(
                max_pool_size: usize,
                max_age_seconds: u64,
                memory_threshold: usize,
            ) -> Self {
                Self {
                    pool: Arc::new(RwLock::new(HashMap::new())),
                    metadata: Arc::new(RwLock::new(HashMap::new())),
                    max_pool_size,
                    max_age: Duration::from_secs(max_age_seconds),
                    memory_usage: Arc::new(Mutex::new(0)),
                    memory_threshold,
                }
            }
            /// Get a memory map for the given file, creating it if necessary
            pub fn get_mmap(
                &self,
                path: &PathBuf,
            ) -> Result<Arc<Mmap>, MemoryPoolError> {
                {
                    let pool = self.pool.read().unwrap();
                    if let Some(mmap) = pool.get(path) {
                        if let Some(meta) = self.metadata.write().unwrap().get_mut(path)
                        {
                            meta.last_accessed = Instant::now();
                            meta.access_count += 1;
                        }
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Memory pool hit for file: {0:?}", path),
                                        lvl,
                                        &(
                                            "rfgrep::performance::memory_pool",
                                            "rfgrep::performance::memory_pool",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        return Ok(mmap.clone());
                    }
                }
                self.create_mmap(path)
            }
            /// Create a new memory map and add it to the pool
            fn create_mmap(&self, path: &PathBuf) -> Result<Arc<Mmap>, MemoryPoolError> {
                let file = File::open(path)
                    .map_err(|e| {
                        MemoryPoolError::IoError(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Failed to open file {0:?}: {1}", path, e),
                                )
                            }),
                        )
                    })?;
                let metadata = file
                    .metadata()
                    .map_err(|e| {
                        MemoryPoolError::IoError(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to get metadata for {0:?}: {1}",
                                        path,
                                        e,
                                    ),
                                )
                            }),
                        )
                    })?;
                let file_size = metadata.len();
                if self.is_memory_pressure_high() {
                    return Err(
                        MemoryPoolError::MemoryPressure(
                            "Memory pressure too high".to_string(),
                        ),
                    );
                }
                let mmap = unsafe { Mmap::map(&file) }
                    .map_err(|e| {
                        MemoryPoolError::MmapError(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to create memory map for {0:?}: {1}",
                                        path,
                                        e,
                                    ),
                                )
                            }),
                        )
                    })?;
                {
                    let mut usage = self.memory_usage.lock().unwrap();
                    *usage += file_size as usize;
                }
                let mmap_arc = Arc::new(mmap);
                let metadata = MmapMetadata {
                    last_accessed: Instant::now(),
                    file_size,
                    access_count: 1,
                };
                {
                    let mut pool = self.pool.write().unwrap();
                    let mut meta_map = self.metadata.write().unwrap();
                    if pool.len() >= self.max_pool_size {
                        self.cleanup_old_entries(&mut pool, &mut meta_map);
                    }
                    pool.insert(path.clone(), mmap_arc.clone());
                    meta_map.insert(path.clone(), metadata);
                }
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Created new memory map for file: {0:?} ({1} bytes)",
                                    path,
                                    file_size,
                                ),
                                lvl,
                                &(
                                    "rfgrep::performance::memory_pool",
                                    "rfgrep::performance::memory_pool",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(mmap_arc)
            }
            /// Check if memory pressure is high
            fn is_memory_pressure_high(&self) -> bool {
                let usage = self.memory_usage.lock().unwrap();
                *usage > self.memory_threshold
            }
            /// Clean up old entries from the pool
            fn cleanup_old_entries(
                &self,
                pool: &mut HashMap<PathBuf, Arc<Mmap>>,
                meta_map: &mut HashMap<PathBuf, MmapMetadata>,
            ) {
                let now = Instant::now();
                let mut to_remove = Vec::new();
                for (path, metadata) in meta_map.iter() {
                    if now.duration_since(metadata.last_accessed) > self.max_age {
                        to_remove.push(path.clone());
                    }
                }
                for path in to_remove {
                    if let Some(metadata) = meta_map.remove(&path) {
                        pool.remove(&path);
                        let mut usage = self.memory_usage.lock().unwrap();
                        *usage = usage.saturating_sub(metadata.file_size as usize);
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Removed old memory map from pool: {0:?}",
                                            path,
                                        ),
                                        lvl,
                                        &(
                                            "rfgrep::performance::memory_pool",
                                            "rfgrep::performance::memory_pool",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                }
            }
            /// Remove a specific file from the pool
            pub fn remove_file(&self, path: &PathBuf) {
                let mut pool = self.pool.write().unwrap();
                let mut meta_map = self.metadata.write().unwrap();
                if let Some(metadata) = meta_map.remove(path) {
                    pool.remove(path);
                    let mut usage = self.memory_usage.lock().unwrap();
                    *usage = usage.saturating_sub(metadata.file_size as usize);
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Removed file from memory pool: {0:?}", path),
                                    lvl,
                                    &(
                                        "rfgrep::performance::memory_pool",
                                        "rfgrep::performance::memory_pool",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            /// Clear all entries from the pool
            pub fn clear(&self) {
                let mut pool = self.pool.write().unwrap();
                let mut meta_map = self.metadata.write().unwrap();
                pool.clear();
                meta_map.clear();
                let mut usage = self.memory_usage.lock().unwrap();
                *usage = 0;
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Cleared memory pool"),
                                lvl,
                                &(
                                    "rfgrep::performance::memory_pool",
                                    "rfgrep::performance::memory_pool",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            /// Get current memory usage
            pub fn memory_usage(&self) -> usize {
                *self.memory_usage.lock().unwrap()
            }
            /// Get pool statistics
            pub fn get_stats(&self) -> MemoryPoolStats {
                let pool = self.pool.read().unwrap();
                let usage = self.memory_usage.lock().unwrap();
                MemoryPoolStats {
                    pool_size: pool.len(),
                    memory_usage: *usage,
                    max_pool_size: self.max_pool_size,
                    memory_threshold: self.memory_threshold,
                }
            }
            /// Clean up expired entries
            pub fn cleanup(&self) {
                let mut pool = self.pool.write().unwrap();
                let mut meta_map = self.metadata.write().unwrap();
                self.cleanup_old_entries(&mut pool, &mut meta_map);
            }
        }
        /// Memory pool statistics
        pub struct MemoryPoolStats {
            pub pool_size: usize,
            pub memory_usage: usize,
            pub max_pool_size: usize,
            pub memory_threshold: usize,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MemoryPoolStats {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "MemoryPoolStats",
                    "pool_size",
                    &self.pool_size,
                    "memory_usage",
                    &self.memory_usage,
                    "max_pool_size",
                    &self.max_pool_size,
                    "memory_threshold",
                    &&self.memory_threshold,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MemoryPoolStats {
            #[inline]
            fn clone(&self) -> MemoryPoolStats {
                MemoryPoolStats {
                    pool_size: ::core::clone::Clone::clone(&self.pool_size),
                    memory_usage: ::core::clone::Clone::clone(&self.memory_usage),
                    max_pool_size: ::core::clone::Clone::clone(&self.max_pool_size),
                    memory_threshold: ::core::clone::Clone::clone(&self.memory_threshold),
                }
            }
        }
        /// Memory pool errors
        pub enum MemoryPoolError {
            #[error("IO error: {0}")]
            IoError(String),
            #[error("Memory map error: {0}")]
            MmapError(String),
            #[error("Memory pressure: {0}")]
            MemoryPressure(String),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MemoryPoolError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    MemoryPoolError::IoError(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "IoError",
                            &__self_0,
                        )
                    }
                    MemoryPoolError::MmapError(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "MmapError",
                            &__self_0,
                        )
                    }
                    MemoryPoolError::MemoryPressure(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "MemoryPressure",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::thiserror::__private18::Error for MemoryPoolError {}
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::core::fmt::Display for MemoryPoolError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use ::thiserror::__private18::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    MemoryPoolError::IoError(_0) => {
                        match (_0.as_display(),) {
                            (__display0,) => {
                                __formatter
                                    .write_fmt(format_args!("IO error: {0}", __display0))
                            }
                        }
                    }
                    MemoryPoolError::MmapError(_0) => {
                        match (_0.as_display(),) {
                            (__display0,) => {
                                __formatter
                                    .write_fmt(
                                        format_args!("Memory map error: {0}", __display0),
                                    )
                            }
                        }
                    }
                    MemoryPoolError::MemoryPressure(_0) => {
                        match (_0.as_display(),) {
                            (__display0,) => {
                                __formatter
                                    .write_fmt(format_args!("Memory pressure: {0}", __display0))
                            }
                        }
                    }
                }
            }
        }
        impl Default for MemoryPool {
            fn default() -> Self {
                Self::new(100, 300, 1024 * 1024 * 1024)
            }
        }
    }
    pub mod optimized_mmap {
        //! Optimized memory-mapped I/O with proper error handling and resource management
        use crate::error::{Result as RfgrepResult, RfgrepError};
        use crate::performance::memory_pool::{MemoryPool, MemoryPoolError};
        use log::{debug, warn};
        use memmap2::Mmap;
        use std::fs::File;
        use std::io::BufReader;
        use std::path::Path;
        use std::sync::Arc;
        use std::time::Instant;
        /// Configuration for memory-mapped I/O
        pub struct MmapConfig {
            /// Minimum file size to use memory mapping (in bytes)
            pub min_file_size: u64,
            /// Maximum file size to use memory mapping (in bytes)
            pub max_file_size: u64,
            /// Enable memory pool for caching
            pub enable_pool: bool,
            /// Memory pool size
            pub pool_size: usize,
            /// Memory pool age limit (seconds)
            pub pool_age_limit: u64,
            /// Memory pressure threshold (bytes)
            pub memory_threshold: usize,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MmapConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "min_file_size",
                    "max_file_size",
                    "enable_pool",
                    "pool_size",
                    "pool_age_limit",
                    "memory_threshold",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.min_file_size,
                    &self.max_file_size,
                    &self.enable_pool,
                    &self.pool_size,
                    &self.pool_age_limit,
                    &&self.memory_threshold,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "MmapConfig",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MmapConfig {
            #[inline]
            fn clone(&self) -> MmapConfig {
                MmapConfig {
                    min_file_size: ::core::clone::Clone::clone(&self.min_file_size),
                    max_file_size: ::core::clone::Clone::clone(&self.max_file_size),
                    enable_pool: ::core::clone::Clone::clone(&self.enable_pool),
                    pool_size: ::core::clone::Clone::clone(&self.pool_size),
                    pool_age_limit: ::core::clone::Clone::clone(&self.pool_age_limit),
                    memory_threshold: ::core::clone::Clone::clone(&self.memory_threshold),
                }
            }
        }
        impl Default for MmapConfig {
            fn default() -> Self {
                Self {
                    min_file_size: 16 * 1024 * 1024,
                    max_file_size: 1024 * 1024 * 1024,
                    enable_pool: true,
                    pool_size: 100,
                    pool_age_limit: 300,
                    memory_threshold: 1024 * 1024 * 1024,
                }
            }
        }
        /// Optimized memory-mapped I/O handler
        pub struct OptimizedMmapHandler {
            config: MmapConfig,
            memory_pool: Option<Arc<MemoryPool>>,
        }
        impl OptimizedMmapHandler {
            /// Create a new optimized memory-mapped I/O handler
            pub fn new(config: MmapConfig) -> Self {
                let memory_pool = if config.enable_pool {
                    Some(
                        Arc::new(
                            MemoryPool::new(
                                config.pool_size,
                                config.pool_age_limit,
                                config.memory_threshold,
                            ),
                        ),
                    )
                } else {
                    None
                };
                Self { config, memory_pool }
            }
            /// Read file content using the optimal strategy
            pub fn read_file(&self, path: &Path) -> RfgrepResult<FileContent> {
                let start = Instant::now();
                let metadata = std::fs::metadata(path)
                    .map_err(|e| {
                        RfgrepError::Io(
                            std::io::Error::other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get metadata for {0:?}: {1}",
                                            path,
                                            e,
                                        ),
                                    )
                                }),
                            ),
                        )
                    })?;
                let file_size = metadata.len();
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Reading file {0:?} ({1} bytes)",
                                    path,
                                    file_size,
                                ),
                                lvl,
                                &(
                                    "rfgrep::performance::optimized_mmap",
                                    "rfgrep::performance::optimized_mmap",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let strategy = self.choose_strategy(file_size);
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Chosen strategy for {0:?}: {1:?}",
                                    path,
                                    strategy,
                                ),
                                lvl,
                                &(
                                    "rfgrep::performance::optimized_mmap",
                                    "rfgrep::performance::optimized_mmap",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let content = match strategy {
                    ReadStrategy::MemoryMapped => self.read_with_mmap(path, file_size)?,
                    ReadStrategy::Buffered => self.read_with_buffered(path)?,
                    ReadStrategy::Streaming => self.read_with_streaming(path)?,
                };
                let duration = start.elapsed();
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("File read completed in {0:?}", duration),
                                lvl,
                                &(
                                    "rfgrep::performance::optimized_mmap",
                                    "rfgrep::performance::optimized_mmap",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(content)
            }
            /// Choose the optimal reading strategy based on file characteristics
            fn choose_strategy(&self, file_size: u64) -> ReadStrategy {
                if file_size < self.config.min_file_size {
                    ReadStrategy::Buffered
                } else if file_size > self.config.max_file_size {
                    ReadStrategy::Streaming
                } else {
                    ReadStrategy::MemoryMapped
                }
            }
            /// Read file using memory mapping
            fn read_with_mmap(
                &self,
                path: &Path,
                _file_size: u64,
            ) -> RfgrepResult<FileContent> {
                if let Some(pool) = &self.memory_pool {
                    match pool.get_mmap(&path.to_path_buf()) {
                        Ok(mmap) => {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Using cached memory map for {0:?}", path),
                                            lvl,
                                            &(
                                                "rfgrep::performance::optimized_mmap",
                                                "rfgrep::performance::optimized_mmap",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            return Ok(FileContent::MemoryMapped(mmap));
                        }
                        Err(MemoryPoolError::MemoryPressure(_)) => {
                            {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "Memory pressure detected, falling back to streaming for {0:?}",
                                                path,
                                            ),
                                            lvl,
                                            &(
                                                "rfgrep::performance::optimized_mmap",
                                                "rfgrep::performance::optimized_mmap",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            return self.read_with_streaming(path);
                        }
                        Err(e) => {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "Memory pool error for {0:?}: {1}, falling back to direct mmap",
                                                path,
                                                e,
                                            ),
                                            lvl,
                                            &(
                                                "rfgrep::performance::optimized_mmap",
                                                "rfgrep::performance::optimized_mmap",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                        }
                    }
                }
                let file = File::open(path)
                    .map_err(|e| {
                        RfgrepError::Io(
                            std::io::Error::other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Failed to open file {0:?}: {1}", path, e),
                                    )
                                }),
                            ),
                        )
                    })?;
                let mmap = unsafe { Mmap::map(&file) }
                    .map_err(|e| {
                        RfgrepError::Io(
                            std::io::Error::other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to create memory map for {0:?}: {1}",
                                            path,
                                            e,
                                        ),
                                    )
                                }),
                            ),
                        )
                    })?;
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Created new memory map for {0:?}", path),
                                lvl,
                                &(
                                    "rfgrep::performance::optimized_mmap",
                                    "rfgrep::performance::optimized_mmap",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(FileContent::MemoryMapped(Arc::new(mmap)))
            }
            /// Read file using buffered I/O
            fn read_with_buffered(&self, path: &Path) -> RfgrepResult<FileContent> {
                let content = std::fs::read_to_string(path)
                    .map_err(|e| {
                        RfgrepError::Io(
                            std::io::Error::other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Failed to read file {0:?}: {1}", path, e),
                                    )
                                }),
                            ),
                        )
                    })?;
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Read file with buffered I/O: {0:?}", path),
                                lvl,
                                &(
                                    "rfgrep::performance::optimized_mmap",
                                    "rfgrep::performance::optimized_mmap",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(FileContent::String(content))
            }
            /// Read file using streaming I/O
            fn read_with_streaming(&self, path: &Path) -> RfgrepResult<FileContent> {
                let file = File::open(path)
                    .map_err(|e| {
                        RfgrepError::Io(
                            std::io::Error::other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Failed to open file {0:?}: {1}", path, e),
                                    )
                                }),
                            ),
                        )
                    })?;
                let reader = BufReader::new(file);
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Using streaming I/O for {0:?}", path),
                                lvl,
                                &(
                                    "rfgrep::performance::optimized_mmap",
                                    "rfgrep::performance::optimized_mmap",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(FileContent::Streaming(reader))
            }
            /// Get memory pool statistics
            pub fn get_pool_stats(
                &self,
            ) -> Option<crate::performance::memory_pool::MemoryPoolStats> {
                self.memory_pool.as_ref().map(|pool| pool.get_stats())
            }
            /// Clean up memory pool
            pub fn cleanup(&self) {
                if let Some(pool) = &self.memory_pool {
                    pool.cleanup();
                }
            }
            /// Remove file from memory pool
            pub fn remove_from_pool(&self, path: &Path) {
                if let Some(pool) = &self.memory_pool {
                    pool.remove_file(&path.to_path_buf());
                }
            }
        }
        /// File content representation
        pub enum FileContent {
            /// Memory-mapped content
            MemoryMapped(Arc<Mmap>),
            /// String content
            String(String),
            /// Streaming reader
            Streaming(BufReader<File>),
        }
        impl FileContent {
            /// Get content as bytes
            pub fn as_bytes(&self) -> &[u8] {
                match self {
                    FileContent::MemoryMapped(mmap) => mmap,
                    FileContent::String(s) => s.as_bytes(),
                    FileContent::Streaming(_) => &[],
                }
            }
            /// Get content as string slice
            pub fn as_str(&self) -> RfgrepResult<&str> {
                match self {
                    FileContent::MemoryMapped(mmap) => {
                        std::str::from_utf8(mmap)
                            .map_err(|e| RfgrepError::Other(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("Invalid UTF-8: {0}", e))
                                }),
                            ))
                    }
                    FileContent::String(s) => Ok(s),
                    FileContent::Streaming(_) => {
                        Err(
                            RfgrepError::Other(
                                "Cannot get string from streaming content".to_string(),
                            ),
                        )
                    }
                }
            }
            /// Check if content is memory-mapped
            pub fn is_memory_mapped(&self) -> bool {
                #[allow(non_exhaustive_omitted_patterns)]
                match self {
                    FileContent::MemoryMapped(_) => true,
                    _ => false,
                }
            }
            /// Get content size
            pub fn len(&self) -> usize {
                match self {
                    FileContent::MemoryMapped(mmap) => mmap.len(),
                    FileContent::String(s) => s.len(),
                    FileContent::Streaming(_) => 0,
                }
            }
            /// Check if content is empty
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
        }
        /// Reading strategy
        pub enum ReadStrategy {
            MemoryMapped,
            Buffered,
            Streaming,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ReadStrategy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ReadStrategy::MemoryMapped => "MemoryMapped",
                        ReadStrategy::Buffered => "Buffered",
                        ReadStrategy::Streaming => "Streaming",
                    },
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        unsafe impl ::core::clone::TrivialClone for ReadStrategy {}
        #[automatically_derived]
        impl ::core::clone::Clone for ReadStrategy {
            #[inline]
            fn clone(&self) -> ReadStrategy {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ReadStrategy {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ReadStrategy {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ReadStrategy {
            #[inline]
            fn eq(&self, other: &ReadStrategy) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ReadStrategy {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
    }
    pub mod parallel_processor {
        //! Parallel file processing utilities for rfgrep
        use rayon::prelude::*;
        use std::path::PathBuf;
        use std::sync::atomic::{AtomicUsize, Ordering};
        use std::sync::Arc;
        /// Configuration for parallel processing
        pub struct ParallelConfig {
            pub max_threads: usize,
            pub chunk_size: usize,
            pub timeout_seconds: Option<u64>,
            pub adaptive_chunking: bool,
            pub memory_pressure_threshold: usize,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ParallelConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "ParallelConfig",
                    "max_threads",
                    &self.max_threads,
                    "chunk_size",
                    &self.chunk_size,
                    "timeout_seconds",
                    &self.timeout_seconds,
                    "adaptive_chunking",
                    &self.adaptive_chunking,
                    "memory_pressure_threshold",
                    &&self.memory_pressure_threshold,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ParallelConfig {
            #[inline]
            fn clone(&self) -> ParallelConfig {
                ParallelConfig {
                    max_threads: ::core::clone::Clone::clone(&self.max_threads),
                    chunk_size: ::core::clone::Clone::clone(&self.chunk_size),
                    timeout_seconds: ::core::clone::Clone::clone(&self.timeout_seconds),
                    adaptive_chunking: ::core::clone::Clone::clone(
                        &self.adaptive_chunking,
                    ),
                    memory_pressure_threshold: ::core::clone::Clone::clone(
                        &self.memory_pressure_threshold,
                    ),
                }
            }
        }
        /// Memory pressure levels for adaptive chunking
        pub enum MemoryPressure {
            Low,
            Medium,
            High,
            Critical,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MemoryPressure {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        MemoryPressure::Low => "Low",
                        MemoryPressure::Medium => "Medium",
                        MemoryPressure::High => "High",
                        MemoryPressure::Critical => "Critical",
                    },
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        unsafe impl ::core::clone::TrivialClone for MemoryPressure {}
        #[automatically_derived]
        impl ::core::clone::Clone for MemoryPressure {
            #[inline]
            fn clone(&self) -> MemoryPressure {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for MemoryPressure {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MemoryPressure {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MemoryPressure {
            #[inline]
            fn eq(&self, other: &MemoryPressure) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for MemoryPressure {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl Default for ParallelConfig {
            fn default() -> Self {
                Self {
                    max_threads: num_cpus::get(),
                    chunk_size: 100,
                    timeout_seconds: None,
                    adaptive_chunking: true,
                    memory_pressure_threshold: 1024 * 1024 * 1024,
                }
            }
        }
        /// Parallel file processor
        pub struct ParallelProcessor {
            config: ParallelConfig,
            memory_usage: Arc<AtomicUsize>,
        }
        impl ParallelProcessor {
            pub fn new(config: ParallelConfig) -> Self {
                Self {
                    config,
                    memory_usage: Arc::new(AtomicUsize::new(0)),
                }
            }
            /// Calculate adaptive chunk size based on system resources
            fn calculate_chunk_size(&self, total_files: usize) -> usize {
                if !self.config.adaptive_chunking {
                    return self.config.chunk_size;
                }
                let cpu_cores = self.config.max_threads;
                let memory_pressure = self.get_memory_pressure();
                let base_chunk_size = std::cmp::max(total_files / (cpu_cores * 4), 50);
                let adjusted_chunk_size = match memory_pressure {
                    MemoryPressure::Low => base_chunk_size,
                    MemoryPressure::Medium => (base_chunk_size as f64 * 0.8) as usize,
                    MemoryPressure::High => (base_chunk_size as f64 * 0.6) as usize,
                    MemoryPressure::Critical => (base_chunk_size as f64 * 0.4) as usize,
                };
                adjusted_chunk_size.clamp(10, 1000)
            }
            /// Get current memory pressure level
            fn get_memory_pressure(&self) -> MemoryPressure {
                let current_usage = self.memory_usage.load(Ordering::Relaxed);
                let threshold = self.config.memory_pressure_threshold;
                if current_usage < threshold / 4 {
                    MemoryPressure::Low
                } else if current_usage < threshold / 2 {
                    MemoryPressure::Medium
                } else if current_usage < threshold * 3 / 4 {
                    MemoryPressure::High
                } else {
                    MemoryPressure::Critical
                }
            }
            /// Track memory usage
            pub fn track_memory_usage(&self, amount: usize) {
                self.memory_usage.fetch_add(amount, Ordering::Relaxed);
            }
            /// Release memory usage
            pub fn release_memory_usage(&self, amount: usize) {
                self.memory_usage.fetch_sub(amount, Ordering::Relaxed);
            }
            /// Process files in parallel
            pub fn process_files<F, R>(
                &self,
                files: Vec<PathBuf>,
                processor: F,
            ) -> Vec<R>
            where
                F: Fn(PathBuf) -> R + Send + Sync,
                R: Send,
            {
                let chunk_size = self.calculate_chunk_size(files.len());
                files.into_par_iter().with_max_len(chunk_size).map(processor).collect()
            }
            /// Process files with error handling
            pub fn process_files_with_result<F, R, E>(
                &self,
                files: Vec<PathBuf>,
                processor: F,
            ) -> Vec<Result<R, E>>
            where
                F: Fn(PathBuf) -> Result<R, E> + Send + Sync,
                R: Send,
                E: Send,
            {
                let chunk_size = self.calculate_chunk_size(files.len());
                files.into_par_iter().with_max_len(chunk_size).map(processor).collect()
            }
            /// Get processing statistics
            pub fn get_stats(&self) -> ProcessingStats {
                ProcessingStats {
                    max_threads: self.config.max_threads,
                    chunk_size: self.config.chunk_size,
                    adaptive_chunking: self.config.adaptive_chunking,
                    memory_usage: self.memory_usage.load(Ordering::Relaxed),
                    memory_pressure: self.get_memory_pressure(),
                }
            }
        }
        /// Processing statistics
        pub struct ProcessingStats {
            pub max_threads: usize,
            pub chunk_size: usize,
            pub adaptive_chunking: bool,
            pub memory_usage: usize,
            pub memory_pressure: MemoryPressure,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ProcessingStats {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "ProcessingStats",
                    "max_threads",
                    &self.max_threads,
                    "chunk_size",
                    &self.chunk_size,
                    "adaptive_chunking",
                    &self.adaptive_chunking,
                    "memory_usage",
                    &self.memory_usage,
                    "memory_pressure",
                    &&self.memory_pressure,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProcessingStats {
            #[inline]
            fn clone(&self) -> ProcessingStats {
                ProcessingStats {
                    max_threads: ::core::clone::Clone::clone(&self.max_threads),
                    chunk_size: ::core::clone::Clone::clone(&self.chunk_size),
                    adaptive_chunking: ::core::clone::Clone::clone(
                        &self.adaptive_chunking,
                    ),
                    memory_usage: ::core::clone::Clone::clone(&self.memory_usage),
                    memory_pressure: ::core::clone::Clone::clone(&self.memory_pressure),
                }
            }
        }
        /// Parallel search processor
        pub struct ParallelSearchProcessor {
            processor: ParallelProcessor,
        }
        impl ParallelSearchProcessor {
            pub fn new(config: ParallelConfig) -> Self {
                Self {
                    processor: ParallelProcessor::new(config),
                }
            }
            /// Process search operations in parallel
            pub fn search_files<F, R>(&self, files: Vec<PathBuf>, searcher: F) -> Vec<R>
            where
                F: Fn(PathBuf) -> R + Send + Sync,
                R: Send,
            {
                self.processor.process_files(files, searcher)
            }
        }
    }
    pub mod zero_copy {
        //! Zero-copy string processing utilities for rfgrep
        use crate::error::{Result as RfgrepResult, RfgrepError};
        use memmap2::Mmap;
        use regex::Regex;
        use std::path::PathBuf;
        /// Zero-copy search match that uses string slices instead of owned strings
        pub struct ZeroCopyMatch<'a> {
            pub path: PathBuf,
            pub line_number: usize,
            pub column: usize,
            pub matched_text: &'a str,
            pub context_before: Vec<&'a str>,
            pub context_after: Vec<&'a str>,
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ZeroCopyMatch<'a> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "path",
                    "line_number",
                    "column",
                    "matched_text",
                    "context_before",
                    "context_after",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.path,
                    &self.line_number,
                    &self.column,
                    &self.matched_text,
                    &self.context_before,
                    &&self.context_after,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ZeroCopyMatch",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ZeroCopyMatch<'a> {
            #[inline]
            fn clone(&self) -> ZeroCopyMatch<'a> {
                ZeroCopyMatch {
                    path: ::core::clone::Clone::clone(&self.path),
                    line_number: ::core::clone::Clone::clone(&self.line_number),
                    column: ::core::clone::Clone::clone(&self.column),
                    matched_text: ::core::clone::Clone::clone(&self.matched_text),
                    context_before: ::core::clone::Clone::clone(&self.context_before),
                    context_after: ::core::clone::Clone::clone(&self.context_after),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ZeroCopyMatch<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ZeroCopyMatch<'a> {
            #[inline]
            fn eq(&self, other: &ZeroCopyMatch<'a>) -> bool {
                self.path == other.path && self.line_number == other.line_number
                    && self.column == other.column
                    && self.matched_text == other.matched_text
                    && self.context_before == other.context_before
                    && self.context_after == other.context_after
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ZeroCopyMatch<'a> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<usize>;
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
                let _: ::core::cmp::AssertParamIsEq<Vec<&'a str>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<&'a str>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ZeroCopyMatch<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ZeroCopyMatch<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.path, &other.path) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.line_number,
                            &other.line_number,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.column,
                                    &other.column,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.matched_text,
                                            &other.matched_text,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.context_before,
                                                    &other.context_before,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.context_after,
                                                            &other.context_after,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ZeroCopyMatch<'a> {
            #[inline]
            fn cmp(&self, other: &ZeroCopyMatch<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.path, &other.path) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.line_number,
                            &other.line_number,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.column, &other.column) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.matched_text,
                                            &other.matched_text,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(
                                                    &self.context_before,
                                                    &other.context_before,
                                                ) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(
                                                            &self.context_after,
                                                            &other.context_after,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        /// Zero-copy search result that holds references to the original content
        pub struct ZeroCopySearchResult<'a> {
            pub content: &'a str,
            pub matches: Vec<ZeroCopyMatch<'a>>,
        }
        impl<'a> ZeroCopySearchResult<'a> {
            /// Create a new zero-copy search result
            pub fn new(content: &'a str) -> Self {
                Self {
                    content,
                    matches: Vec::new(),
                }
            }
            /// Add a match to the result
            pub fn add_match(
                &mut self,
                path: PathBuf,
                line_number: usize,
                column: usize,
                matched_text: &'a str,
                context_before: Vec<&'a str>,
                context_after: Vec<&'a str>,
            ) {
                self.matches
                    .push(ZeroCopyMatch {
                        path,
                        line_number,
                        column,
                        matched_text,
                        context_before,
                        context_after,
                    });
            }
            /// Get the number of matches
            pub fn len(&self) -> usize {
                self.matches.len()
            }
            /// Check if there are any matches
            pub fn is_empty(&self) -> bool {
                self.matches.is_empty()
            }
        }
        /// Zero-copy string processor for efficient text processing
        pub struct ZeroCopyProcessor<'a> {
            content: &'a str,
            lines: Vec<&'a str>,
        }
        impl<'a> ZeroCopyProcessor<'a> {
            /// Create a new zero-copy processor
            pub fn new(content: &'a str) -> Self {
                let lines = content.lines().collect();
                Self { content, lines }
            }
            /// Search for pattern using zero-copy string processing
            pub fn search_with_context(
                &self,
                pattern: &Regex,
                path: PathBuf,
                context_lines: usize,
            ) -> RfgrepResult<ZeroCopySearchResult<'a>> {
                let mut result = ZeroCopySearchResult::new(self.content);
                for (line_idx, line) in self.lines.iter().enumerate() {
                    for mat in pattern.find_iter(line) {
                        let line_number = line_idx + 1;
                        let column = mat.start() + 1;
                        let matched_text = &line[mat.start()..mat.end()];
                        let context_before = self
                            .get_context_before(line_idx, context_lines);
                        let context_after = self
                            .get_context_after(line_idx, context_lines);
                        result
                            .add_match(
                                path.clone(),
                                line_number,
                                column,
                                matched_text,
                                context_before,
                                context_after,
                            );
                    }
                }
                Ok(result)
            }
            /// Get context lines before the current line
            fn get_context_before(
                &self,
                line_idx: usize,
                context_lines: usize,
            ) -> Vec<&'a str> {
                let start = line_idx.saturating_sub(context_lines);
                self.lines[start..line_idx].to_vec()
            }
            /// Get context lines after the current line
            fn get_context_after(
                &self,
                line_idx: usize,
                context_lines: usize,
            ) -> Vec<&'a str> {
                let end = if line_idx + context_lines + 1 < self.lines.len() {
                    line_idx + context_lines + 1
                } else {
                    self.lines.len()
                };
                self.lines[line_idx + 1..end].to_vec()
            }
            /// Find all line boundaries in the content
            pub fn find_line_boundaries(&self) -> Vec<usize> {
                let mut boundaries = Vec::new();
                let mut pos = 0;
                for line in self.lines.iter() {
                    boundaries.push(pos);
                    pos += line.len() + 1;
                }
                boundaries
            }
            /// Get a specific line by index
            pub fn get_line(&self, line_idx: usize) -> Option<&'a str> {
                self.lines.get(line_idx).copied()
            }
            /// Get the total number of lines
            pub fn line_count(&self) -> usize {
                self.lines.len()
            }
            /// Check if content is empty
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
            /// Get content as bytes
            pub fn as_bytes(&self) -> &[u8] {
                self.content.as_bytes()
            }
            /// Get content length
            pub fn len(&self) -> usize {
                self.content.len()
            }
        }
        /// Memory-mapped zero-copy processor for large files
        pub struct MmapZeroCopyProcessor<'a> {
            mmap: &'a Mmap,
            content: &'a str,
            processor: ZeroCopyProcessor<'a>,
        }
        impl<'a> MmapZeroCopyProcessor<'a> {
            /// Create a new memory-mapped zero-copy processor
            pub fn new(mmap: &'a Mmap) -> RfgrepResult<Self> {
                let content = std::str::from_utf8(mmap)
                    .map_err(|e| {
                        RfgrepError::Other(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Invalid UTF-8 in memory-mapped file: {0}", e),
                                )
                            }),
                        )
                    })?;
                let processor = ZeroCopyProcessor::new(content);
                Ok(Self { mmap, content, processor })
            }
            /// Search using zero-copy processing
            pub fn search_with_context(
                &self,
                pattern: &Regex,
                path: PathBuf,
                context_lines: usize,
            ) -> RfgrepResult<ZeroCopySearchResult<'a>> {
                self.processor.search_with_context(pattern, path, context_lines)
            }
            /// Get the underlying processor
            pub fn processor(&self) -> &ZeroCopyProcessor<'a> {
                &self.processor
            }
        }
        /// Zero-copy string utilities
        pub struct ZeroCopyUtils;
        impl ZeroCopyUtils {
            /// Split string into lines without allocation
            pub fn lines(content: &str) -> impl Iterator<Item = &str> {
                content.lines()
            }
            /// Find all occurrences of a pattern without allocation
            pub fn find_all<'a>(content: &'a str, pattern: &Regex) -> Vec<&'a str> {
                pattern
                    .find_iter(content)
                    .map(|mat| &content[mat.start()..mat.end()])
                    .collect()
            }
            /// Extract context around a match without allocation
            pub fn extract_context(
                content: &str,
                start: usize,
                end: usize,
                context_chars: usize,
            ) -> (&str, &str, &str) {
                let context_start = start.saturating_sub(context_chars);
                let context_end = (end + context_chars).min(content.len());
                let before = &content[context_start..start];
                let matched = &content[start..end];
                let after = &content[end..context_end];
                (before, matched, after)
            }
            /// Count occurrences of a pattern without allocation
            pub fn count_matches(content: &str, pattern: &Regex) -> usize {
                pattern.find_iter(content).count()
            }
            /// Check if content contains a pattern without allocation
            pub fn contains_pattern(content: &str, pattern: &Regex) -> bool {
                pattern.is_match(content)
            }
        }
        /// Convert zero-copy matches to owned matches (when needed)
        pub fn to_owned_matches<'a>(
            zero_copy_matches: &[ZeroCopyMatch<'a>],
        ) -> Vec<crate::processor::SearchMatch> {
            zero_copy_matches
                .iter()
                .map(|m| crate::processor::SearchMatch {
                    path: m.path.clone(),
                    line_number: m.line_number,
                    line: m.matched_text.to_string(),
                    column_start: m.column,
                    column_end: m.column + m.matched_text.len(),
                    matched_text: m.matched_text.to_string(),
                    context_before: m
                        .context_before
                        .iter()
                        .enumerate()
                        .map(|(i, s)| (i + 1, s.to_string()))
                        .collect(),
                    context_after: m
                        .context_after
                        .iter()
                        .enumerate()
                        .map(|(i, s)| (i + 1, s.to_string()))
                        .collect(),
                })
                .collect()
        }
    }
    use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
    use std::sync::Arc;
    use std::time::Instant;
    /// Performance metrics for monitoring and optimization
    pub struct PerformanceMetrics {
        pub search_time: std::time::Duration,
        pub memory_usage: usize,
        pub files_processed: usize,
        pub matches_found: usize,
        pub cache_hits: usize,
        pub cache_misses: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PerformanceMetrics {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "search_time",
                "memory_usage",
                "files_processed",
                "matches_found",
                "cache_hits",
                "cache_misses",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.search_time,
                &self.memory_usage,
                &self.files_processed,
                &self.matches_found,
                &self.cache_hits,
                &&self.cache_misses,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "PerformanceMetrics",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PerformanceMetrics {
        #[inline]
        fn clone(&self) -> PerformanceMetrics {
            PerformanceMetrics {
                search_time: ::core::clone::Clone::clone(&self.search_time),
                memory_usage: ::core::clone::Clone::clone(&self.memory_usage),
                files_processed: ::core::clone::Clone::clone(&self.files_processed),
                matches_found: ::core::clone::Clone::clone(&self.matches_found),
                cache_hits: ::core::clone::Clone::clone(&self.cache_hits),
                cache_misses: ::core::clone::Clone::clone(&self.cache_misses),
            }
        }
    }
    /// Thread-safe performance metrics using atomic operations
    pub struct AtomicPerformanceMetrics {
        search_time_nanos: AtomicU64,
        memory_usage: AtomicUsize,
        files_processed: AtomicUsize,
        matches_found: AtomicUsize,
        cache_hits: AtomicUsize,
        cache_misses: AtomicUsize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AtomicPerformanceMetrics {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "search_time_nanos",
                "memory_usage",
                "files_processed",
                "matches_found",
                "cache_hits",
                "cache_misses",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.search_time_nanos,
                &self.memory_usage,
                &self.files_processed,
                &self.matches_found,
                &self.cache_hits,
                &&self.cache_misses,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AtomicPerformanceMetrics",
                names,
                values,
            )
        }
    }
    impl AtomicPerformanceMetrics {
        pub fn new() -> Self {
            Self {
                search_time_nanos: AtomicU64::new(0),
                memory_usage: AtomicUsize::new(0),
                files_processed: AtomicUsize::new(0),
                matches_found: AtomicUsize::new(0),
                cache_hits: AtomicUsize::new(0),
                cache_misses: AtomicUsize::new(0),
            }
        }
        pub fn set_search_time(&self, duration: std::time::Duration) {
            self.search_time_nanos.store(duration.as_nanos() as u64, Ordering::Relaxed);
        }
        pub fn add_memory_usage(&self, amount: usize) {
            self.memory_usage.fetch_add(amount, Ordering::Relaxed);
        }
        pub fn increment_files_processed(&self) {
            self.files_processed.fetch_add(1, Ordering::Relaxed);
        }
        pub fn add_matches_found(&self, count: usize) {
            self.matches_found.fetch_add(count, Ordering::Relaxed);
        }
        pub fn increment_cache_hit(&self) {
            self.cache_hits.fetch_add(1, Ordering::Relaxed);
        }
        pub fn increment_cache_miss(&self) {
            self.cache_misses.fetch_add(1, Ordering::Relaxed);
        }
        pub fn to_performance_metrics(&self) -> PerformanceMetrics {
            PerformanceMetrics {
                search_time: std::time::Duration::from_nanos(
                    self.search_time_nanos.load(Ordering::Relaxed),
                ),
                memory_usage: self.memory_usage.load(Ordering::Relaxed),
                files_processed: self.files_processed.load(Ordering::Relaxed),
                matches_found: self.matches_found.load(Ordering::Relaxed),
                cache_hits: self.cache_hits.load(Ordering::Relaxed),
                cache_misses: self.cache_misses.load(Ordering::Relaxed),
            }
        }
    }
    impl PerformanceMetrics {
        pub fn new() -> Self {
            Self {
                search_time: std::time::Duration::ZERO,
                memory_usage: 0,
                files_processed: 0,
                matches_found: 0,
                cache_hits: 0,
                cache_misses: 0,
            }
        }
        pub fn files_per_second(&self) -> f64 {
            if self.search_time.as_secs_f64() > 0.0 {
                self.files_processed as f64 / self.search_time.as_secs_f64()
            } else {
                0.0
            }
        }
        pub fn memory_per_file(&self) -> f64 {
            if self.files_processed > 0 {
                self.memory_usage as f64 / self.files_processed as f64
            } else {
                0.0
            }
        }
        pub fn cache_hit_rate(&self) -> f64 {
            let total_requests = self.cache_hits + self.cache_misses;
            if total_requests > 0 {
                self.cache_hits as f64 / total_requests as f64
            } else {
                0.0
            }
        }
    }
    /// Performance monitor for tracking and optimizing rfgrep performance
    pub struct PerformanceMonitor {
        metrics: Arc<AtomicPerformanceMetrics>,
        start_time: Option<Instant>,
    }
    impl PerformanceMonitor {
        pub fn new() -> Self {
            Self {
                metrics: Arc::new(AtomicPerformanceMetrics::new()),
                start_time: None,
            }
        }
        pub fn start_timing(&mut self) {
            self.start_time = Some(Instant::now());
        }
        pub fn stop_timing(&mut self) {
            if let Some(start) = self.start_time {
                let duration = start.elapsed();
                self.metrics.set_search_time(duration);
                self.start_time = None;
            }
        }
        pub fn record_file_processed(&self) {
            self.metrics.increment_files_processed();
        }
        pub fn record_matches_found(&self, count: usize) {
            self.metrics.add_matches_found(count);
        }
        pub fn record_cache_hit(&self) {
            self.metrics.increment_cache_hit();
        }
        pub fn record_cache_miss(&self) {
            self.metrics.increment_cache_miss();
        }
        pub fn record_memory_usage(&self, amount: usize) {
            self.metrics.add_memory_usage(amount);
        }
        pub fn get_metrics(&self) -> PerformanceMetrics {
            self.metrics.to_performance_metrics()
        }
        pub fn get_atomic_metrics(&self) -> Arc<AtomicPerformanceMetrics> {
            self.metrics.clone()
        }
        /// Reset all metrics to zero
        pub fn reset(&self) {
            self.metrics.search_time_nanos.store(0, Ordering::Relaxed);
            self.metrics.memory_usage.store(0, Ordering::Relaxed);
            self.metrics.files_processed.store(0, Ordering::Relaxed);
            self.metrics.matches_found.store(0, Ordering::Relaxed);
            self.metrics.cache_hits.store(0, Ordering::Relaxed);
            self.metrics.cache_misses.store(0, Ordering::Relaxed);
        }
    }
    impl Default for PerformanceMonitor {
        fn default() -> Self {
            Self::new()
        }
    }
    /// Memory usage tracker for optimization
    pub struct MemoryTracker {
        peak_usage: AtomicUsize,
        current_usage: AtomicUsize,
        allocations: AtomicUsize,
        deallocations: AtomicUsize,
    }
    impl MemoryTracker {
        pub fn new() -> Self {
            Self {
                peak_usage: AtomicUsize::new(0),
                current_usage: AtomicUsize::new(0),
                allocations: AtomicUsize::new(0),
                deallocations: AtomicUsize::new(0),
            }
        }
        pub fn track_allocation(&self, size: usize) {
            let current = self.current_usage.fetch_add(size, Ordering::Relaxed);
            let new_current = current + size;
            let mut peak = self.peak_usage.load(Ordering::Relaxed);
            while new_current > peak {
                match self
                    .peak_usage
                    .compare_exchange_weak(
                        peak,
                        new_current,
                        Ordering::Relaxed,
                        Ordering::Relaxed,
                    )
                {
                    Ok(_) => break,
                    Err(current_peak) => peak = current_peak,
                }
            }
            self.allocations.fetch_add(1, Ordering::Relaxed);
        }
        pub fn track_deallocation(&self, size: usize) {
            self.current_usage.fetch_sub(size, Ordering::Relaxed);
            self.deallocations.fetch_add(1, Ordering::Relaxed);
        }
        pub fn peak_usage(&self) -> usize {
            self.peak_usage.load(Ordering::Relaxed)
        }
        pub fn current_usage(&self) -> usize {
            self.current_usage.load(Ordering::Relaxed)
        }
        pub fn allocation_count(&self) -> usize {
            self.allocations.load(Ordering::Relaxed)
        }
        pub fn deallocation_count(&self) -> usize {
            self.deallocations.load(Ordering::Relaxed)
        }
        /// Reset all counters to zero
        pub fn reset(&self) {
            self.peak_usage.store(0, Ordering::Relaxed);
            self.current_usage.store(0, Ordering::Relaxed);
            self.allocations.store(0, Ordering::Relaxed);
            self.deallocations.store(0, Ordering::Relaxed);
        }
        /// Get memory usage statistics
        pub fn get_stats(&self) -> MemoryStats {
            MemoryStats {
                peak_usage: self.peak_usage(),
                current_usage: self.current_usage(),
                allocations: self.allocation_count(),
                deallocations: self.deallocation_count(),
            }
        }
    }
    /// Memory usage statistics
    pub struct MemoryStats {
        pub peak_usage: usize,
        pub current_usage: usize,
        pub allocations: usize,
        pub deallocations: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MemoryStats {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "MemoryStats",
                "peak_usage",
                &self.peak_usage,
                "current_usage",
                &self.current_usage,
                "allocations",
                &self.allocations,
                "deallocations",
                &&self.deallocations,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MemoryStats {
        #[inline]
        fn clone(&self) -> MemoryStats {
            MemoryStats {
                peak_usage: ::core::clone::Clone::clone(&self.peak_usage),
                current_usage: ::core::clone::Clone::clone(&self.current_usage),
                allocations: ::core::clone::Clone::clone(&self.allocations),
                deallocations: ::core::clone::Clone::clone(&self.deallocations),
            }
        }
    }
    impl Default for MemoryTracker {
        fn default() -> Self {
            Self::new()
        }
    }
}
/// Plugin command-line interface
pub mod plugin_cli {
    //! CLI commands for plugin management
    use crate::error::Result as RfgrepResult;
    use crate::plugin_system::EnhancedPluginManager;
    use colored::Colorize;
    use std::sync::Arc;
    /// Plugin management CLI commands
    pub struct PluginCli {
        manager: Arc<EnhancedPluginManager>,
    }
    impl PluginCli {
        pub fn new(manager: Arc<EnhancedPluginManager>) -> Self {
            Self { manager }
        }
        /// List all available plugins
        pub async fn list_plugins(&self) -> RfgrepResult<()> {
            let plugins = self.manager.list_plugins().await;
            if plugins.is_empty() {
                {
                    ::std::io::_print(
                        format_args!("{0}\n", "No plugins registered".yellow()),
                    );
                };
                return Ok(());
            }
            {
                ::std::io::_print(
                    format_args!("{0}\n", "Available Plugins:".green().bold()),
                );
            };
            {
                ::std::io::_print(format_args!("{0}\n", "==================".green()));
            };
            for plugin in plugins {
                let status = if plugin.enabled {
                    "ENABLED".green()
                } else {
                    "DISABLED".red()
                };
                let streaming = if plugin.supports_streaming {
                    " [STREAMING]".blue()
                } else {
                    "".clear()
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "\n{0} {1} {2}\n",
                            plugin.name.bold(),
                            status,
                            streaming,
                        ),
                    );
                };
                {
                    ::std::io::_print(format_args!("  Version: {0}\n", plugin.version));
                };
                {
                    ::std::io::_print(
                        format_args!("  Description: {0}\n", plugin.description),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!("  Priority: {0}\n", plugin.priority),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "  Extensions: {0}\n",
                            plugin.supported_extensions.join(", "),
                        ),
                    );
                };
            }
            Ok(())
        }
        /// Show plugin statistics
        pub async fn show_stats(&self) -> RfgrepResult<()> {
            let stats = self.manager.get_plugin_stats().await;
            {
                ::std::io::_print(
                    format_args!("{0}\n", "Plugin Statistics:".green().bold()),
                );
            };
            {
                ::std::io::_print(format_args!("{0}\n", "==================".green()));
            };
            {
                ::std::io::_print(
                    format_args!("Total Plugins: {0}\n", stats.total_plugins),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "Enabled: {0}\n",
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", stats.enabled_plugins),
                                )
                            })
                            .green(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "Disabled: {0}\n",
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", stats.disabled_plugins),
                                )
                            })
                            .red(),
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "Streaming Support: {0}\n",
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("{0}", stats.streaming_plugins),
                                )
                            })
                            .blue(),
                    ),
                );
            };
            Ok(())
        }
        /// Enable a plugin
        pub async fn enable_plugin(&self, name: &str) -> RfgrepResult<()> {
            if let Some(mut config) = self.manager.get_plugin_config(name).await {
                config.enabled = true;
                self.manager.update_plugin_config(name, config).await?;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' enabled", name),
                                    )
                                })
                                .green(),
                        ),
                    );
                };
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' not found", name),
                                    )
                                })
                                .red(),
                        ),
                    );
                };
            }
            Ok(())
        }
        /// Disable a plugin
        pub async fn disable_plugin(&self, name: &str) -> RfgrepResult<()> {
            if let Some(mut config) = self.manager.get_plugin_config(name).await {
                config.enabled = false;
                self.manager.update_plugin_config(name, config).await?;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' disabled", name),
                                    )
                                })
                                .yellow(),
                        ),
                    );
                };
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' not found", name),
                                    )
                                })
                                .red(),
                        ),
                    );
                };
            }
            Ok(())
        }
        /// Show detailed plugin information
        pub async fn show_plugin_info(&self, name: &str) -> RfgrepResult<()> {
            let plugins = self.manager.list_plugins().await;
            if let Some(plugin) = plugins.iter().find(|p| p.name == name) {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin: {0}", plugin.name),
                                    )
                                })
                                .green()
                                .bold(),
                        ),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!("{0}\n", "=".repeat(plugin.name.len() + 8).green()),
                    );
                };
                {
                    ::std::io::_print(format_args!("Version: {0}\n", plugin.version));
                };
                {
                    ::std::io::_print(
                        format_args!("Description: {0}\n", plugin.description),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "Status: {0}\n",
                            if plugin.enabled {
                                "ENABLED".green()
                            } else {
                                "DISABLED".red()
                            },
                        ),
                    );
                };
                {
                    ::std::io::_print(format_args!("Priority: {0}\n", plugin.priority));
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "Streaming Support: {0}\n",
                            if plugin.supports_streaming {
                                "Yes".green()
                            } else {
                                "No".red()
                            },
                        ),
                    );
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "Supported Extensions: {0}\n",
                            plugin.supported_extensions.join(", "),
                        ),
                    );
                };
                if let Some(config) = self.manager.get_plugin_config(name).await {
                    if !config.settings.is_empty() {
                        {
                            ::std::io::_print(format_args!("\nConfiguration:\n"));
                        };
                        for (key, value) in &config.settings {
                            {
                                ::std::io::_print(format_args!("  {0}: {1}\n", key, value));
                            };
                        }
                    }
                }
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' not found", name),
                                    )
                                })
                                .red(),
                        ),
                    );
                };
            }
            Ok(())
        }
        /// Set plugin priority
        pub async fn set_priority(&self, name: &str, priority: u32) -> RfgrepResult<()> {
            if let Some(mut config) = self.manager.get_plugin_config(name).await {
                config.priority = priority;
                self.manager.update_plugin_config(name, config).await?;
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Plugin \'{0}\' priority set to {1}",
                                            name,
                                            priority,
                                        ),
                                    )
                                })
                                .green(),
                        ),
                    );
                };
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' not found", name),
                                    )
                                })
                                .red(),
                        ),
                    );
                };
            }
            Ok(())
        }
        /// Show plugin configuration options
        pub async fn show_config_options(&self, name: &str) -> RfgrepResult<()> {
            let plugins = self.manager.list_plugins().await;
            if let Some(plugin) = plugins.iter().find(|p| p.name == name) {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Configuration Options for \'{0}\':",
                                            plugin.name,
                                        ),
                                    )
                                })
                                .green()
                                .bold(),
                        ),
                    );
                };
                {
                    ::std::io::_print(format_args!("{0}\n", "=".repeat(40).green()));
                };
                {
                    ::std::io::_print(
                        format_args!(
                            "Configuration options not yet implemented for this plugin.\n",
                        ),
                    );
                };
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Plugin \'{0}\' not found", name),
                                    )
                                })
                                .red(),
                        ),
                    );
                };
            }
            Ok(())
        }
        /// Test a plugin with a specific file
        pub async fn test_plugin(
            &self,
            name: &str,
            file_path: &str,
            pattern: &str,
        ) -> RfgrepResult<()> {
            use std::path::Path;
            let path = Path::new(file_path);
            if !path.exists() {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("File \'{0}\' does not exist", file_path),
                                    )
                                })
                                .red(),
                        ),
                    );
                };
                return Ok(());
            }
            {
                ::std::io::_print(
                    format_args!(
                        "{0}\n",
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Testing plugin \'{0}\' on file \'{1}\' with pattern \'{2}\'",
                                        name,
                                        file_path,
                                        pattern,
                                    ),
                                )
                            })
                            .green()
                            .bold(),
                    ),
                );
            };
            {
                ::std::io::_print(format_args!("{0}\n", "=".repeat(60).green()));
            };
            match self.manager.search_file(path, pattern).await {
                Ok(matches) => {
                    if matches.is_empty() {
                        {
                            ::std::io::_print(
                                format_args!("{0}\n", "No matches found".yellow()),
                            );
                        };
                    } else {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "{0}\n",
                                    ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("Found {0} matches:", matches.len()),
                                            )
                                        })
                                        .green(),
                                ),
                            );
                        };
                        for (i, m) in matches.iter().enumerate() {
                            {
                                ::std::io::_print(
                                    format_args!(
                                        "  {0}. Line {1}: {2}\n",
                                        i + 1,
                                        m.line_number,
                                        m.line,
                                    ),
                                );
                            };
                        }
                    }
                }
                Err(e) => {
                    {
                        ::std::io::_print(
                            format_args!(
                                "{0}\n",
                                ::alloc::__export::must_use({
                                        ::alloc::fmt::format(format_args!("Error: {0}", e))
                                    })
                                    .red(),
                            ),
                        );
                    };
                }
            }
            Ok(())
        }
        /// Show help for plugin commands
        pub fn show_help(&self) {
            {
                ::std::io::_print(
                    format_args!("{0}\n", "Plugin Management Commands:".green().bold()),
                );
            };
            {
                ::std::io::_print(
                    format_args!("{0}\n", "===========================".green()),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "list                    - List all available plugins\n",
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!("stats                  - Show plugin statistics\n"),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "info <name>            - Show detailed plugin information\n",
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!("enable <name>          - Enable a plugin\n"),
                );
            };
            {
                ::std::io::_print(
                    format_args!("disable <name>         - Disable a plugin\n"),
                );
            };
            {
                ::std::io::_print(
                    format_args!("priority <name> <num>  - Set plugin priority\n"),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "config <name>          - Show plugin configuration options\n",
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!(
                        "test <name> <file> <pattern> - Test plugin with specific file\n",
                    ),
                );
            };
            {
                ::std::io::_print(
                    format_args!("help                   - Show this help message\n"),
                );
            };
        }
    }
}
/// Extensible plugin system with dynamic loading
pub mod plugin_system {
    //! Enhanced plugin system for rfgrep with dynamic loading and better integration
    use crate::error::Result as RfgrepResult;
    use crate::processor::SearchMatch;
    use crate::search_algorithms::SearchAlgorithm;
    use crate::streaming_search::{StreamingConfig, StreamingSearchPipeline};
    use libloading::{Library, Symbol};
    use serde::{Deserialize, Serialize};
    use std::collections::HashMap;
    use std::ffi::OsStr;
    use std::path::{Path, PathBuf};
    use std::sync::Arc;
    use tokio::sync::RwLock;
    /// Enhanced plugin trait with more capabilities
    pub trait EnhancedSearchPlugin: Send + Sync {
        /// Plugin name
        fn name(&self) -> &str;
        /// Plugin version
        fn version(&self) -> &str;
        /// Plugin description
        fn description(&self) -> &str;
        /// Check if this plugin can handle the given file
        fn can_handle(&self, file: &Path) -> bool;
        /// Get the priority of this plugin (lower = higher priority)
        fn priority(&self) -> u32;
        /// Search a file using this plugin
        fn search(&self, file: &Path, pattern: &str) -> RfgrepResult<Vec<SearchMatch>>;
        /// Get supported file extensions
        fn supported_extensions(&self) -> Vec<String>;
        /// Get plugin configuration options
        fn get_config_options(&self) -> HashMap<String, PluginConfigOption>;
        /// Update plugin configuration
        fn update_config(
            &mut self,
            config: HashMap<String, serde_json::Value>,
        ) -> RfgrepResult<()>;
        /// Check if plugin supports streaming search
        fn supports_streaming(&self) -> bool {
            false
        }
        /// Get preferred search algorithm for this plugin
        fn preferred_algorithm(&self) -> Option<SearchAlgorithm> {
            None
        }
        /// Initialize plugin with given configuration
        fn initialize(&mut self, _config: PluginConfig) -> RfgrepResult<()> {
            Ok(())
        }
        /// Cleanup plugin resources
        fn cleanup(&mut self) -> RfgrepResult<()> {
            Ok(())
        }
    }
    /// Plugin configuration option
    pub struct PluginConfigOption {
        pub name: String,
        pub description: String,
        pub default_value: serde_json::Value,
        pub value_type: ConfigValueType,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PluginConfigOption {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "PluginConfigOption",
                "name",
                &self.name,
                "description",
                &self.description,
                "default_value",
                &self.default_value,
                "value_type",
                &&self.value_type,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PluginConfigOption {
        #[inline]
        fn clone(&self) -> PluginConfigOption {
            PluginConfigOption {
                name: ::core::clone::Clone::clone(&self.name),
                description: ::core::clone::Clone::clone(&self.description),
                default_value: ::core::clone::Clone::clone(&self.default_value),
                value_type: ::core::clone::Clone::clone(&self.value_type),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PluginConfigOption {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PluginConfigOption",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "default_value",
                    &self.default_value,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value_type",
                    &self.value_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PluginConfigOption {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private228::Ok(__Field::__field0),
                            "description" => _serde::__private228::Ok(__Field::__field1),
                            "default_value" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            "value_type" => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private228::Ok(__Field::__field0),
                            b"description" => _serde::__private228::Ok(__Field::__field1),
                            b"default_value" => {
                                _serde::__private228::Ok(__Field::__field2)
                            }
                            b"value_type" => _serde::__private228::Ok(__Field::__field3),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<PluginConfigOption>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PluginConfigOption;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct PluginConfigOption",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PluginConfigOption with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PluginConfigOption with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            serde_json::Value,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PluginConfigOption with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ConfigValueType,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct PluginConfigOption with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private228::Ok(PluginConfigOption {
                            name: __field0,
                            description: __field1,
                            default_value: __field2,
                            value_type: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<String> = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<String> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<
                            serde_json::Value,
                        > = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<
                            ConfigValueType,
                        > = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "default_value",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            serde_json::Value,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value_type",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ConfigValueType,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("description")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("default_value")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("value_type")?
                            }
                        };
                        _serde::__private228::Ok(PluginConfigOption {
                            name: __field0,
                            description: __field1,
                            default_value: __field2,
                            value_type: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "description",
                    "default_value",
                    "value_type",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PluginConfigOption",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<PluginConfigOption>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    /// Configuration value types
    pub enum ConfigValueType {
        String,
        Integer,
        Boolean,
        Float,
        Array,
        Object,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ConfigValueType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ConfigValueType::String => "String",
                    ConfigValueType::Integer => "Integer",
                    ConfigValueType::Boolean => "Boolean",
                    ConfigValueType::Float => "Float",
                    ConfigValueType::Array => "Array",
                    ConfigValueType::Object => "Object",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ConfigValueType {
        #[inline]
        fn clone(&self) -> ConfigValueType {
            match self {
                ConfigValueType::String => ConfigValueType::String,
                ConfigValueType::Integer => ConfigValueType::Integer,
                ConfigValueType::Boolean => ConfigValueType::Boolean,
                ConfigValueType::Float => ConfigValueType::Float,
                ConfigValueType::Array => ConfigValueType::Array,
                ConfigValueType::Object => ConfigValueType::Object,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ConfigValueType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ConfigValueType::String => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigValueType",
                            0u32,
                            "String",
                        )
                    }
                    ConfigValueType::Integer => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigValueType",
                            1u32,
                            "Integer",
                        )
                    }
                    ConfigValueType::Boolean => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigValueType",
                            2u32,
                            "Boolean",
                        )
                    }
                    ConfigValueType::Float => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigValueType",
                            3u32,
                            "Float",
                        )
                    }
                    ConfigValueType::Array => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigValueType",
                            4u32,
                            "Array",
                        )
                    }
                    ConfigValueType::Object => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ConfigValueType",
                            5u32,
                            "Object",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ConfigValueType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            4u64 => _serde::__private228::Ok(__Field::__field4),
                            5u64 => _serde::__private228::Ok(__Field::__field5),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 6",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "String" => _serde::__private228::Ok(__Field::__field0),
                            "Integer" => _serde::__private228::Ok(__Field::__field1),
                            "Boolean" => _serde::__private228::Ok(__Field::__field2),
                            "Float" => _serde::__private228::Ok(__Field::__field3),
                            "Array" => _serde::__private228::Ok(__Field::__field4),
                            "Object" => _serde::__private228::Ok(__Field::__field5),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"String" => _serde::__private228::Ok(__Field::__field0),
                            b"Integer" => _serde::__private228::Ok(__Field::__field1),
                            b"Boolean" => _serde::__private228::Ok(__Field::__field2),
                            b"Float" => _serde::__private228::Ok(__Field::__field3),
                            b"Array" => _serde::__private228::Ok(__Field::__field4),
                            b"Object" => _serde::__private228::Ok(__Field::__field5),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<ConfigValueType>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ConfigValueType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum ConfigValueType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(ConfigValueType::String)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(ConfigValueType::Integer)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(ConfigValueType::Boolean)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(ConfigValueType::Float)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(ConfigValueType::Array)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(ConfigValueType::Object)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "String",
                    "Integer",
                    "Boolean",
                    "Float",
                    "Array",
                    "Object",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ConfigValueType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<ConfigValueType>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    /// Plugin configuration
    pub struct PluginConfig {
        pub enabled: bool,
        pub priority: u32,
        pub settings: HashMap<String, serde_json::Value>,
        pub streaming_enabled: bool,
        pub preferred_algorithm: Option<SearchAlgorithm>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PluginConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "PluginConfig",
                "enabled",
                &self.enabled,
                "priority",
                &self.priority,
                "settings",
                &self.settings,
                "streaming_enabled",
                &self.streaming_enabled,
                "preferred_algorithm",
                &&self.preferred_algorithm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PluginConfig {
        #[inline]
        fn clone(&self) -> PluginConfig {
            PluginConfig {
                enabled: ::core::clone::Clone::clone(&self.enabled),
                priority: ::core::clone::Clone::clone(&self.priority),
                settings: ::core::clone::Clone::clone(&self.settings),
                streaming_enabled: ::core::clone::Clone::clone(&self.streaming_enabled),
                preferred_algorithm: ::core::clone::Clone::clone(
                    &self.preferred_algorithm,
                ),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PluginConfig {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PluginConfig",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enabled",
                    &self.enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "priority",
                    &self.priority,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "settings",
                    &self.settings,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "streaming_enabled",
                    &self.streaming_enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "preferred_algorithm",
                    &self.preferred_algorithm,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PluginConfig {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            4u64 => _serde::__private228::Ok(__Field::__field4),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enabled" => _serde::__private228::Ok(__Field::__field0),
                            "priority" => _serde::__private228::Ok(__Field::__field1),
                            "settings" => _serde::__private228::Ok(__Field::__field2),
                            "streaming_enabled" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            "preferred_algorithm" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enabled" => _serde::__private228::Ok(__Field::__field0),
                            b"priority" => _serde::__private228::Ok(__Field::__field1),
                            b"settings" => _serde::__private228::Ok(__Field::__field2),
                            b"streaming_enabled" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            b"preferred_algorithm" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<PluginConfig>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PluginConfig;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct PluginConfig",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PluginConfig with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PluginConfig with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            HashMap<String, serde_json::Value>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PluginConfig with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct PluginConfig with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<SearchAlgorithm>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct PluginConfig with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private228::Ok(PluginConfig {
                            enabled: __field0,
                            priority: __field1,
                            settings: __field2,
                            streaming_enabled: __field3,
                            preferred_algorithm: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<bool> = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<u32> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<
                            HashMap<String, serde_json::Value>,
                        > = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<bool> = _serde::__private228::None;
                        let mut __field4: _serde::__private228::Option<
                            Option<SearchAlgorithm>,
                        > = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enabled",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "priority",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "settings",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            HashMap<String, serde_json::Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "streaming_enabled",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private228::Option::is_some(&__field4) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "preferred_algorithm",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<SearchAlgorithm>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("enabled")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("priority")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("settings")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field(
                                    "streaming_enabled",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private228::Some(__field4) => __field4,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field(
                                    "preferred_algorithm",
                                )?
                            }
                        };
                        _serde::__private228::Ok(PluginConfig {
                            enabled: __field0,
                            priority: __field1,
                            settings: __field2,
                            streaming_enabled: __field3,
                            preferred_algorithm: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enabled",
                    "priority",
                    "settings",
                    "streaming_enabled",
                    "preferred_algorithm",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PluginConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<PluginConfig>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    impl Default for PluginConfig {
        fn default() -> Self {
            Self {
                enabled: true,
                priority: 100,
                settings: HashMap::new(),
                streaming_enabled: false,
                preferred_algorithm: None,
            }
        }
    }
    /// Enhanced plugin manager with dynamic loading and configuration
    pub struct EnhancedPluginManager {
        plugins: Arc<RwLock<HashMap<String, Box<dyn EnhancedSearchPlugin>>>>,
        plugin_configs: Arc<RwLock<HashMap<String, PluginConfig>>>,
        streaming_pipeline: Option<StreamingSearchPipeline>,
    }
    impl EnhancedPluginManager {
        pub fn new() -> Self {
            Self {
                plugins: Arc::new(RwLock::new(HashMap::new())),
                plugin_configs: Arc::new(RwLock::new(HashMap::new())),
                streaming_pipeline: None,
            }
        }
        /// Register a plugin
        pub async fn register_plugin(
            &self,
            mut plugin: Box<dyn EnhancedSearchPlugin>,
        ) -> RfgrepResult<()> {
            let name = plugin.name().to_string();
            let config = PluginConfig::default();
            plugin.initialize(config.clone())?;
            self.plugins.write().await.insert(name.clone(), plugin);
            self.plugin_configs.write().await.insert(name, config);
            Ok(())
        }
        /// Unregister a plugin
        pub async fn unregister_plugin(&self, name: &str) -> RfgrepResult<()> {
            if let Some(mut plugin) = self.plugins.write().await.remove(name) {
                plugin.cleanup()?;
            }
            self.plugin_configs.write().await.remove(name);
            Ok(())
        }
        /// Update plugin configuration
        pub async fn update_plugin_config(
            &self,
            name: &str,
            config: PluginConfig,
        ) -> RfgrepResult<()> {
            if let Some(plugin) = self.plugins.write().await.get_mut(name) {
                plugin.update_config(config.settings.clone())?;
            }
            self.plugin_configs.write().await.insert(name.to_string(), config);
            Ok(())
        }
        /// Get plugin configuration
        pub async fn get_plugin_config(&self, name: &str) -> Option<PluginConfig> {
            self.plugin_configs.read().await.get(name).cloned()
        }
        /// List all registered plugins
        pub async fn list_plugins(&self) -> Vec<PluginInfo> {
            let plugins = self.plugins.read().await;
            let configs = self.plugin_configs.read().await;
            plugins
                .iter()
                .map(|(name, plugin)| {
                    let config = configs.get(name).cloned().unwrap_or_default();
                    PluginInfo {
                        name: name.clone(),
                        version: plugin.version().to_string(),
                        description: plugin.description().to_string(),
                        enabled: config.enabled,
                        priority: config.priority,
                        supported_extensions: plugin.supported_extensions(),
                        supports_streaming: plugin.supports_streaming(),
                    }
                })
                .collect()
        }
        /// Search a file using the best available plugin
        pub async fn search_file(
            &self,
            file: &Path,
            pattern: &str,
        ) -> RfgrepResult<Vec<SearchMatch>> {
            let plugins = self.plugins.read().await;
            let configs = self.plugin_configs.read().await;
            let mut candidates: Vec<_> = plugins
                .iter()
                .filter(|(name, plugin)| {
                    if let Some(config) = configs.get(*name) {
                        config.enabled && plugin.can_handle(file)
                    } else {
                        false
                    }
                })
                .collect();
            candidates
                .sort_by_key(|(name, _)| {
                    configs.get(*name).map(|c| c.priority).unwrap_or(100)
                });
            if let Some((_, plugin)) = candidates.first() {
                if plugin.supports_streaming() && self.streaming_pipeline.is_some() {
                    if let Some(pipeline) = &self.streaming_pipeline {
                        pipeline.search_file(file, pattern).await
                    } else {
                        plugin.search(file, pattern)
                    }
                } else {
                    plugin.search(file, pattern)
                }
            } else {
                Ok(::alloc::vec::Vec::new())
            }
        }
        /// Set up streaming pipeline for plugins that support it
        pub fn setup_streaming(&mut self, config: StreamingConfig) {
            self.streaming_pipeline = Some(StreamingSearchPipeline::new(config));
        }
        /// Get plugin statistics
        pub async fn get_plugin_stats(&self) -> PluginStats {
            let plugins = self.plugins.read().await;
            let configs = self.plugin_configs.read().await;
            let total_plugins = plugins.len();
            let enabled_plugins = configs.values().filter(|c| c.enabled).count();
            let streaming_plugins = plugins
                .values()
                .filter(|p| p.supports_streaming())
                .count();
            PluginStats {
                total_plugins,
                enabled_plugins,
                streaming_plugins,
                disabled_plugins: total_plugins - enabled_plugins,
            }
        }
    }
    /// Plugin information
    pub struct PluginInfo {
        pub name: String,
        pub version: String,
        pub description: String,
        pub enabled: bool,
        pub priority: u32,
        pub supported_extensions: Vec<String>,
        pub supports_streaming: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PluginInfo {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "version",
                "description",
                "enabled",
                "priority",
                "supported_extensions",
                "supports_streaming",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.version,
                &self.description,
                &self.enabled,
                &self.priority,
                &self.supported_extensions,
                &&self.supports_streaming,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "PluginInfo",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PluginInfo {
        #[inline]
        fn clone(&self) -> PluginInfo {
            PluginInfo {
                name: ::core::clone::Clone::clone(&self.name),
                version: ::core::clone::Clone::clone(&self.version),
                description: ::core::clone::Clone::clone(&self.description),
                enabled: ::core::clone::Clone::clone(&self.enabled),
                priority: ::core::clone::Clone::clone(&self.priority),
                supported_extensions: ::core::clone::Clone::clone(
                    &self.supported_extensions,
                ),
                supports_streaming: ::core::clone::Clone::clone(&self.supports_streaming),
            }
        }
    }
    /// Plugin statistics
    pub struct PluginStats {
        pub total_plugins: usize,
        pub enabled_plugins: usize,
        pub disabled_plugins: usize,
        pub streaming_plugins: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PluginStats {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "PluginStats",
                "total_plugins",
                &self.total_plugins,
                "enabled_plugins",
                &self.enabled_plugins,
                "disabled_plugins",
                &self.disabled_plugins,
                "streaming_plugins",
                &&self.streaming_plugins,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PluginStats {
        #[inline]
        fn clone(&self) -> PluginStats {
            PluginStats {
                total_plugins: ::core::clone::Clone::clone(&self.total_plugins),
                enabled_plugins: ::core::clone::Clone::clone(&self.enabled_plugins),
                disabled_plugins: ::core::clone::Clone::clone(&self.disabled_plugins),
                streaming_plugins: ::core::clone::Clone::clone(&self.streaming_plugins),
            }
        }
    }
    /// Built-in text search plugin with enhanced capabilities
    pub struct EnhancedTextSearchPlugin {
        config: PluginConfig,
        text_extensions: Vec<String>,
        case_sensitive: bool,
        max_file_size: Option<usize>,
    }
    impl EnhancedTextSearchPlugin {
        pub fn new() -> Self {
            Self {
                config: PluginConfig::default(),
                text_extensions: <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        "txt".to_string(),
                        "md".to_string(),
                        "rs".to_string(),
                        "py".to_string(),
                        "js".to_string(),
                        "ts".to_string(),
                        "go".to_string(),
                        "java".to_string(),
                        "cpp".to_string(),
                        "c".to_string(),
                        "h".to_string(),
                        "hpp".to_string(),
                        "json".to_string(),
                        "yaml".to_string(),
                        "toml".to_string(),
                        "xml".to_string(),
                        "html".to_string(),
                        "css".to_string(),
                        "sh".to_string(),
                        "bash".to_string(),
                        "zsh".to_string(),
                        "fish".to_string(),
                        "ps1".to_string(),
                        "bat".to_string(),
                        "ini".to_string(),
                        "cfg".to_string(),
                        "conf".to_string(),
                    ]),
                ),
                case_sensitive: false,
                max_file_size: Some(10 * 1024 * 1024),
            }
        }
    }
    impl EnhancedSearchPlugin for EnhancedTextSearchPlugin {
        fn name(&self) -> &str {
            "enhanced_text"
        }
        fn version(&self) -> &str {
            "1.0.0"
        }
        fn description(&self) -> &str {
            "Enhanced text file search with streaming support"
        }
        fn can_handle(&self, file: &Path) -> bool {
            if let Some(max_size) = self.max_file_size {
                if let Ok(metadata) = file.metadata() {
                    if metadata.len() > max_size as u64 {
                        return false;
                    }
                }
            }
            if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                self.text_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
            } else {
                if let Ok(content) = std::fs::read(file) {
                    content.iter().take(1024).all(|&b| b.is_ascii() || b >= 128)
                } else {
                    false
                }
            }
        }
        fn priority(&self) -> u32 {
            10
        }
        fn search(&self, file: &Path, pattern: &str) -> RfgrepResult<Vec<SearchMatch>> {
            let content = std::fs::read_to_string(file)?;
            let regex_pattern = if self.case_sensitive {
                pattern.to_string()
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("(?i){0}", pattern))
                })
            };
            let regex = regex::Regex::new(&regex_pattern)?;
            let mut matches = Vec::new();
            for (line_num, line) in content.lines().enumerate() {
                for mat in regex.find_iter(line) {
                    matches
                        .push(SearchMatch {
                            path: file.to_path_buf(),
                            line_number: line_num + 1,
                            line: line.to_string(),
                            context_before: Vec::new(),
                            context_after: Vec::new(),
                            matched_text: mat.as_str().to_string(),
                            column_start: mat.start(),
                            column_end: mat.end(),
                        });
                }
            }
            Ok(matches)
        }
        fn supported_extensions(&self) -> Vec<String> {
            self.text_extensions.clone()
        }
        fn get_config_options(&self) -> HashMap<String, PluginConfigOption> {
            let mut options = HashMap::new();
            options
                .insert(
                    "case_sensitive".to_string(),
                    PluginConfigOption {
                        name: "Case Sensitive".to_string(),
                        description: "Enable case-sensitive search".to_string(),
                        default_value: serde_json::Value::Bool(false),
                        value_type: ConfigValueType::Boolean,
                    },
                );
            options
                .insert(
                    "max_file_size".to_string(),
                    PluginConfigOption {
                        name: "Max File Size".to_string(),
                        description: "Maximum file size to process (in bytes)"
                            .to_string(),
                        default_value: serde_json::Value::Number(
                            serde_json::Number::from(10 * 1024 * 1024),
                        ),
                        value_type: ConfigValueType::Integer,
                    },
                );
            options
        }
        fn update_config(
            &mut self,
            config: HashMap<String, serde_json::Value>,
        ) -> RfgrepResult<()> {
            if let Some(value) = config.get("case_sensitive") {
                if let Some(bool_val) = value.as_bool() {
                    self.case_sensitive = bool_val;
                }
            }
            if let Some(value) = config.get("max_file_size") {
                if let Some(int_val) = value.as_u64() {
                    self.max_file_size = Some(int_val as usize);
                }
            }
            Ok(())
        }
        fn supports_streaming(&self) -> bool {
            true
        }
        fn preferred_algorithm(&self) -> Option<SearchAlgorithm> {
            Some(SearchAlgorithm::BoyerMoore)
        }
    }
    /// Built-in binary search plugin with enhanced capabilities
    pub struct EnhancedBinarySearchPlugin {
        config: PluginConfig,
        binary_extensions: Vec<String>,
        search_metadata: bool,
    }
    impl EnhancedBinarySearchPlugin {
        pub fn new() -> Self {
            Self {
                config: PluginConfig::default(),
                binary_extensions: <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        "exe".to_string(),
                        "dll".to_string(),
                        "so".to_string(),
                        "dylib".to_string(),
                        "bin".to_string(),
                        "obj".to_string(),
                        "o".to_string(),
                        "a".to_string(),
                        "lib".to_string(),
                        "pdb".to_string(),
                        "map".to_string(),
                    ]),
                ),
                search_metadata: true,
            }
        }
    }
    impl EnhancedSearchPlugin for EnhancedBinarySearchPlugin {
        fn name(&self) -> &str {
            "enhanced_binary"
        }
        fn version(&self) -> &str {
            "1.0.0"
        }
        fn description(&self) -> &str {
            "Enhanced binary file search with metadata support"
        }
        fn can_handle(&self, file: &Path) -> bool {
            if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                self.binary_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
            } else {
                if let Ok(content) = std::fs::read(file) {
                    content.iter().take(1024).any(|&b| b == 0)
                } else {
                    false
                }
            }
        }
        fn priority(&self) -> u32 {
            20
        }
        fn search(&self, file: &Path, pattern: &str) -> RfgrepResult<Vec<SearchMatch>> {
            let content = std::fs::read(file)?;
            let pattern_bytes = pattern.as_bytes();
            let mut matches = Vec::new();
            let mut pos = 0;
            while let Some(found) = memchr::memmem::find(
                &content[pos..],
                pattern_bytes,
            ) {
                let absolute_pos = pos + found;
                matches
                    .push(SearchMatch {
                        path: file.to_path_buf(),
                        line_number: 1,
                        line: ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Binary data at offset {0}", absolute_pos),
                            )
                        }),
                        context_before: Vec::new(),
                        context_after: Vec::new(),
                        matched_text: pattern.to_string(),
                        column_start: absolute_pos,
                        column_end: absolute_pos + pattern_bytes.len(),
                    });
                pos = absolute_pos + 1;
            }
            Ok(matches)
        }
        fn supported_extensions(&self) -> Vec<String> {
            self.binary_extensions.clone()
        }
        fn get_config_options(&self) -> HashMap<String, PluginConfigOption> {
            let mut options = HashMap::new();
            options
                .insert(
                    "search_metadata".to_string(),
                    PluginConfigOption {
                        name: "Search Metadata".to_string(),
                        description: "Search file metadata in addition to content"
                            .to_string(),
                        default_value: serde_json::Value::Bool(true),
                        value_type: ConfigValueType::Boolean,
                    },
                );
            options
        }
        fn update_config(
            &mut self,
            config: HashMap<String, serde_json::Value>,
        ) -> RfgrepResult<()> {
            if let Some(value) = config.get("search_metadata") {
                if let Some(bool_val) = value.as_bool() {
                    self.search_metadata = bool_val;
                }
            }
            Ok(())
        }
        fn preferred_algorithm(&self) -> Option<SearchAlgorithm> {
            Some(SearchAlgorithm::Simd)
        }
    }
    /// Plugin registry for managing plugin discovery and loading
    pub struct PluginRegistry {
        manager: Arc<EnhancedPluginManager>,
        plugin_paths: Vec<std::path::PathBuf>,
    }
    impl PluginRegistry {
        pub fn new(manager: Arc<EnhancedPluginManager>) -> Self {
            Self {
                manager,
                plugin_paths: Vec::new(),
            }
        }
        /// Add a plugin directory to search for plugins
        pub fn add_plugin_directory(&mut self, path: std::path::PathBuf) {
            self.plugin_paths.push(path);
        }
        /// Load all plugins from registered directories
        pub async fn load_plugins(&self) -> RfgrepResult<()> {
            self.manager
                .register_plugin(Box::new(EnhancedTextSearchPlugin::new()))
                .await?;
            self.manager
                .register_plugin(Box::new(EnhancedBinarySearchPlugin::new()))
                .await?;
            self.load_dynamic_plugins().await?;
            Ok(())
        }
        /// Reload all plugins
        pub async fn reload_plugins(&self) -> RfgrepResult<()> {
            let mut plugins = self.manager.plugins.write().await;
            for (_, mut plugin) in plugins.drain() {
                let _ = plugin.cleanup();
            }
            drop(plugins);
            self.load_plugins().await
        }
        /// Load dynamic plugins from directories
        async fn load_dynamic_plugins(&self) -> RfgrepResult<()> {
            let plugin_dirs = self.get_plugin_directories();
            for dir in plugin_dirs {
                if let Err(e) = self.load_plugins_from_directory(&dir).await {
                    {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Failed to load plugins from directory {0:?}: {1}",
                                        dir,
                                        e,
                                    ),
                                    lvl,
                                    &(
                                        "rfgrep::plugin_system",
                                        "rfgrep::plugin_system",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
            Ok(())
        }
        /// Get plugin directories to search
        fn get_plugin_directories(&self) -> Vec<PathBuf> {
            let mut dirs = Vec::new();
            if let Ok(plugin_path) = std::env::var("RFGREP_PLUGIN_PATH") {
                for path in plugin_path.split(':') {
                    dirs.push(PathBuf::from(path));
                }
            }
            if let Some(home) = dirs::home_dir() {
                dirs.push(home.join(".local/share/rfgrep/plugins"));
                dirs.push(home.join(".config/rfgrep/plugins"));
            }
            dirs.push(PathBuf::from("/usr/local/lib/rfgrep/plugins"));
            dirs.push(PathBuf::from("/usr/lib/rfgrep/plugins"));
            dirs.into_iter().filter(|d| d.exists() && d.is_dir()).collect()
        }
        /// Load plugins from a specific directory
        async fn load_plugins_from_directory(&self, dir: &Path) -> RfgrepResult<()> {
            let entries = std::fs::read_dir(dir)?;
            for entry in entries {
                let entry = entry?;
                let path = entry.path();
                if self.is_plugin_file(&path) {
                    if let Err(e) = self.load_plugin_from_file(&path).await {
                        {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Failed to load plugin from {0:?}: {1}",
                                            path,
                                            e,
                                        ),
                                        lvl,
                                        &(
                                            "rfgrep::plugin_system",
                                            "rfgrep::plugin_system",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                    }
                }
            }
            Ok(())
        }
        /// Check if a file is a valid plugin
        fn is_plugin_file(&self, path: &Path) -> bool {
            path.extension()
                .and_then(OsStr::to_str)
                .map_or(
                    false,
                    |extension| {
                        #[allow(non_exhaustive_omitted_patterns)]
                        match extension {
                            "so" | "dylib" | "dll" => true,
                            _ => false,
                        }
                    },
                )
        }
        /// Load a plugin from a shared library file
        async fn load_plugin_from_file(&self, path: &Path) -> RfgrepResult<()> {
            unsafe {
                let lib = Library::new(path)?;
                let create_plugin: Symbol<
                    unsafe extern "C" fn() -> *mut dyn EnhancedSearchPlugin,
                > = lib.get(b"create_plugin")?;
                let plugin_ptr = create_plugin();
                if plugin_ptr.is_null() {
                    return Err(
                        crate::error::RfgrepError::Other(
                            "Plugin creation function returned null".to_string(),
                        ),
                    );
                }
                let plugin = Box::from_raw(plugin_ptr);
                self.manager.register_plugin(plugin).await?;
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Successfully loaded dynamic plugin from {0:?}",
                                    path,
                                ),
                                lvl,
                                &(
                                    "rfgrep::plugin_system",
                                    "rfgrep::plugin_system",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(())
            }
        }
    }
}
/// Core file processing and search logic
pub mod processor {
    //! File-level search helpers and match extraction used by the rfgrep core.
    use crate::error::{Result as RfgrepResult, RfgrepError};
    use crate::file_types::{FileTypeClassifier, SearchDecision};
    use lazy_static::lazy_static;
    use log::{debug, info, warn};
    use memmap2::Mmap;
    use regex::Regex;
    use std::collections::HashMap;
    use std::collections::VecDeque;
    use std::fs::File;
    use std::fs::Metadata;
    use std::io::{BufRead, BufReader, Read};
    use std::path::Path;
    use std::sync::Mutex;
    use std::time::Instant;
    const CONTEXT_LINES: usize = 2;
    const BINARY_CHECK_SIZE: usize = 8000;
    pub const MMAP_THRESHOLD: u64 = 16 * 1024 * 1024;
    const MAX_SCAN_FILE_SIZE: u64 = 100 * 1024 * 1024;
    /// Get adaptive mmap threshold based on available system memory
    pub fn get_adaptive_mmap_threshold() -> u64 {
        {
            use std::fs;
            if let Ok(meminfo) = fs::read_to_string("/proc/meminfo") {
                if let Some(available_line) = meminfo
                    .lines()
                    .find(|line| line.starts_with("MemAvailable:"))
                {
                    if let Some(kb_str) = available_line.split_whitespace().nth(1) {
                        if let Ok(kb) = kb_str.parse::<u64>() {
                            let threshold = (kb * 1024 / 8).min(1024 * 1024 * 1024);
                            return threshold.max(MMAP_THRESHOLD);
                        }
                    }
                }
            }
        }
        MMAP_THRESHOLD
    }
    /// Expose adaptive chunk size for streaming
    pub fn get_adaptive_chunk_size(file_size: u64) -> usize {
        if file_size < 64 * 1024 {
            4096
        } else if file_size < 1024 * 1024 {
            8192
        } else if file_size < 16 * 1024 * 1024 {
            65536
        } else {
            262144
        }
    }
    use serde::{Deserialize, Serialize};
    pub struct SearchMatch {
        pub path: std::path::PathBuf,
        pub line_number: usize,
        pub line: String,
        pub context_before: Vec<(usize, String)>,
        pub context_after: Vec<(usize, String)>,
        pub matched_text: String,
        pub column_start: usize,
        pub column_end: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchMatch {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "path",
                "line_number",
                "line",
                "context_before",
                "context_after",
                "matched_text",
                "column_start",
                "column_end",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.path,
                &self.line_number,
                &self.line,
                &self.context_before,
                &self.context_after,
                &self.matched_text,
                &self.column_start,
                &&self.column_end,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SearchMatch",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchMatch {
        #[inline]
        fn clone(&self) -> SearchMatch {
            SearchMatch {
                path: ::core::clone::Clone::clone(&self.path),
                line_number: ::core::clone::Clone::clone(&self.line_number),
                line: ::core::clone::Clone::clone(&self.line),
                context_before: ::core::clone::Clone::clone(&self.context_before),
                context_after: ::core::clone::Clone::clone(&self.context_after),
                matched_text: ::core::clone::Clone::clone(&self.matched_text),
                column_start: ::core::clone::Clone::clone(&self.column_start),
                column_end: ::core::clone::Clone::clone(&self.column_end),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SearchMatch {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SearchMatch {
        #[inline]
        fn eq(&self, other: &SearchMatch) -> bool {
            self.path == other.path && self.line_number == other.line_number
                && self.line == other.line && self.context_before == other.context_before
                && self.context_after == other.context_after
                && self.matched_text == other.matched_text
                && self.column_start == other.column_start
                && self.column_end == other.column_end
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for SearchMatch {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<std::path::PathBuf>;
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<(usize, String)>>;
            let _: ::core::cmp::AssertParamIsEq<Vec<(usize, String)>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SearchMatch {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SearchMatch,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.path, &other.path) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.line_number,
                        &other.line_number,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.line,
                                &other.line,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.context_before,
                                        &other.context_before,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.context_after,
                                                &other.context_after,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.matched_text,
                                                        &other.matched_text,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.column_start,
                                                                &other.column_start,
                                                            ) {
                                                                ::core::option::Option::Some(
                                                                    ::core::cmp::Ordering::Equal,
                                                                ) => {
                                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                                        &self.column_end,
                                                                        &other.column_end,
                                                                    )
                                                                }
                                                                cmp => cmp,
                                                            }
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for SearchMatch {
        #[inline]
        fn cmp(&self, other: &SearchMatch) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.path, &other.path) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.line_number, &other.line_number) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.line, &other.line) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.context_before,
                                        &other.context_before,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.context_after,
                                                &other.context_after,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.matched_text,
                                                        &other.matched_text,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            match ::core::cmp::Ord::cmp(
                                                                &self.column_start,
                                                                &other.column_start,
                                                            ) {
                                                                ::core::cmp::Ordering::Equal => {
                                                                    ::core::cmp::Ord::cmp(&self.column_end, &other.column_end)
                                                                }
                                                                cmp => cmp,
                                                            }
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SearchMatch {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SearchMatch",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "path",
                    &self.path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "line_number",
                    &self.line_number,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "line",
                    &self.line,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "context_before",
                    &self.context_before,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "context_after",
                    &self.context_after,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "matched_text",
                    &self.matched_text,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "column_start",
                    &self.column_start,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "column_end",
                    &self.column_end,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SearchMatch {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            4u64 => _serde::__private228::Ok(__Field::__field4),
                            5u64 => _serde::__private228::Ok(__Field::__field5),
                            6u64 => _serde::__private228::Ok(__Field::__field6),
                            7u64 => _serde::__private228::Ok(__Field::__field7),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "path" => _serde::__private228::Ok(__Field::__field0),
                            "line_number" => _serde::__private228::Ok(__Field::__field1),
                            "line" => _serde::__private228::Ok(__Field::__field2),
                            "context_before" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            "context_after" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            "matched_text" => _serde::__private228::Ok(__Field::__field5),
                            "column_start" => _serde::__private228::Ok(__Field::__field6),
                            "column_end" => _serde::__private228::Ok(__Field::__field7),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"path" => _serde::__private228::Ok(__Field::__field0),
                            b"line_number" => _serde::__private228::Ok(__Field::__field1),
                            b"line" => _serde::__private228::Ok(__Field::__field2),
                            b"context_before" => {
                                _serde::__private228::Ok(__Field::__field3)
                            }
                            b"context_after" => {
                                _serde::__private228::Ok(__Field::__field4)
                            }
                            b"matched_text" => {
                                _serde::__private228::Ok(__Field::__field5)
                            }
                            b"column_start" => {
                                _serde::__private228::Ok(__Field::__field6)
                            }
                            b"column_end" => _serde::__private228::Ok(__Field::__field7),
                            _ => _serde::__private228::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<SearchMatch>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SearchMatch;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "struct SearchMatch",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            std::path::PathBuf,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<(usize, String)>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Vec<(usize, String)>,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private228::Some(__value) => __value,
                            _serde::__private228::None => {
                                return _serde::__private228::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct SearchMatch with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private228::Ok(SearchMatch {
                            path: __field0,
                            line_number: __field1,
                            line: __field2,
                            context_before: __field3,
                            context_after: __field4,
                            matched_text: __field5,
                            column_start: __field6,
                            column_end: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private228::Option<
                            std::path::PathBuf,
                        > = _serde::__private228::None;
                        let mut __field1: _serde::__private228::Option<usize> = _serde::__private228::None;
                        let mut __field2: _serde::__private228::Option<String> = _serde::__private228::None;
                        let mut __field3: _serde::__private228::Option<
                            Vec<(usize, String)>,
                        > = _serde::__private228::None;
                        let mut __field4: _serde::__private228::Option<
                            Vec<(usize, String)>,
                        > = _serde::__private228::None;
                        let mut __field5: _serde::__private228::Option<String> = _serde::__private228::None;
                        let mut __field6: _serde::__private228::Option<usize> = _serde::__private228::None;
                        let mut __field7: _serde::__private228::Option<usize> = _serde::__private228::None;
                        while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private228::Option::is_some(&__field0) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("path"),
                                        );
                                    }
                                    __field0 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            std::path::PathBuf,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private228::Option::is_some(&__field1) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "line_number",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private228::Option::is_some(&__field2) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("line"),
                                        );
                                    }
                                    __field2 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private228::Option::is_some(&__field3) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "context_before",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<(usize, String)>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private228::Option::is_some(&__field4) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "context_after",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<(usize, String)>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private228::Option::is_some(&__field5) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "matched_text",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private228::Option::is_some(&__field6) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "column_start",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private228::Option::is_some(&__field7) {
                                        return _serde::__private228::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "column_end",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private228::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private228::Some(__field0) => __field0,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("path")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private228::Some(__field1) => __field1,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("line_number")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private228::Some(__field2) => __field2,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("line")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private228::Some(__field3) => __field3,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("context_before")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private228::Some(__field4) => __field4,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("context_after")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private228::Some(__field5) => __field5,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("matched_text")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private228::Some(__field6) => __field6,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("column_start")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private228::Some(__field7) => __field7,
                            _serde::__private228::None => {
                                _serde::__private228::de::missing_field("column_end")?
                            }
                        };
                        _serde::__private228::Ok(SearchMatch {
                            path: __field0,
                            line_number: __field1,
                            line: __field2,
                            context_before: __field3,
                            context_after: __field4,
                            matched_text: __field5,
                            column_start: __field6,
                            column_end: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "path",
                    "line_number",
                    "line",
                    "context_before",
                    "context_after",
                    "matched_text",
                    "column_start",
                    "column_end",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SearchMatch",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<SearchMatch>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SearchMatch {
        #[inline]
        fn default() -> SearchMatch {
            SearchMatch {
                path: ::core::default::Default::default(),
                line_number: ::core::default::Default::default(),
                line: ::core::default::Default::default(),
                context_before: ::core::default::Default::default(),
                context_after: ::core::default::Default::default(),
                matched_text: ::core::default::Default::default(),
                column_start: ::core::default::Default::default(),
                column_end: ::core::default::Default::default(),
            }
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct REGEX_CACHE {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    static REGEX_CACHE: REGEX_CACHE = REGEX_CACHE { __private_field: () };
    impl ::lazy_static::__Deref for REGEX_CACHE {
        type Target = Mutex<HashMap<String, Regex>>;
        fn deref(&self) -> &Mutex<HashMap<String, Regex>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<HashMap<String, Regex>> {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<HashMap<String, Regex>> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<HashMap<String, Regex>>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for REGEX_CACHE {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    pub fn is_binary(file: &Path) -> bool {
        if let Ok(Some(k)) = infer::get_from_path(file) {
            if !k.mime_type().starts_with("text/") {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Infer detected binary for {0}: {1}",
                                    file.display(),
                                    k.mime_type(),
                                ),
                                lvl,
                                &(
                                    "rfgrep::processor",
                                    "rfgrep::processor",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                return true;
            }
        }
        if let Ok(mut f) = File::open(file) {
            let mut buffer = ::alloc::vec::from_elem(0u8, BINARY_CHECK_SIZE);
            match f.read(&mut buffer) {
                Ok(n) if n > 0 => {
                    if n >= 2 {
                        let bom_utf16_le = &buffer[0..2] == b"\xff\xfe";
                        let bom_utf16_be = &buffer[0..2] == b"\xfe\xff";
                        if bom_utf16_le || bom_utf16_be {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "UTF-16 BOM detected, treating as text: {0}",
                                                file.display(),
                                            ),
                                            lvl,
                                            &(
                                                "rfgrep::processor",
                                                "rfgrep::processor",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            return false;
                        }
                    }
                    if n >= 3 && &buffer[0..3] == b"\xef\xbb\xbf" {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "UTF-8 BOM detected, treating as text: {0}",
                                            file.display(),
                                        ),
                                        lvl,
                                        &(
                                            "rfgrep::processor",
                                            "rfgrep::processor",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        return false;
                    }
                    if n >= 4 {
                        let mut utf16_likely = true;
                        let mut utf16_be_likely = true;
                        for i in (0..n - 1).step_by(2) {
                            if i + 1 < n {
                                if buffer[i] != 0 && buffer[i + 1] == 0 {
                                    utf16_likely = false;
                                }
                                if buffer[i] == 0 && buffer[i + 1] != 0 {
                                    utf16_be_likely = false;
                                }
                            }
                        }
                        if utf16_likely || utf16_be_likely {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "UTF-16 pattern detected, treating as text: {0}",
                                                file.display(),
                                            ),
                                            lvl,
                                            &(
                                                "rfgrep::processor",
                                                "rfgrep::processor",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            return false;
                        }
                    }
                    let null_bytes = buffer[..n].iter().filter(|&&b| b == 0).count();
                    let binary_threshold = (n as f64 * 0.1).max(1.0);
                    if (null_bytes as f64) > binary_threshold {
                        {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Null byte heuristic detected binary file: {0}",
                                            f.metadata().map(|m| m.len()).unwrap_or(0),
                                        ),
                                        lvl,
                                        &(
                                            "rfgrep::processor",
                                            "rfgrep::processor",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        return true;
                    }
                }
                Ok(_) => {}
                Err(e) => {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Failed to read sample from {0}: {1}",
                                        file.display(),
                                        e,
                                    ),
                                    lvl,
                                    &(
                                        "rfgrep::processor",
                                        "rfgrep::processor",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
            }
        }
        false
    }
    /// Decide whether a file should be skipped entirely before attempting to read/scan it.
    /// Uses smart file type classification with extension, MIME, and size analysis.
    pub fn should_skip(path: &Path, metadata: &Metadata) -> bool {
        if metadata.is_dir() {
            return true;
        }
        if let Ok(s) = path.canonicalize() {
            if let Some(root_str) = s.to_str() {
                if root_str.starts_with("/proc") || root_str.starts_with("/dev") {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Skipping kernel fs path: {0}",
                                        path.display(),
                                    ),
                                    lvl,
                                    &(
                                        "rfgrep::processor",
                                        "rfgrep::processor",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    return true;
                }
            }
        }
        let ftype = metadata.file_type();
        {
            use std::os::unix::fs::FileTypeExt;
            if ftype.is_socket() || ftype.is_fifo() || ftype.is_block_device()
                || ftype.is_char_device() || ftype.is_symlink()
            {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Skipping special unix file type: {0}",
                                    path.display(),
                                ),
                                lvl,
                                &(
                                    "rfgrep::processor",
                                    "rfgrep::processor",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                return true;
            }
        }
        let classifier = FileTypeClassifier::new();
        match classifier.should_search(path, metadata) {
            SearchDecision::Search(_) => {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Searching file: {0}", path.display()),
                                lvl,
                                &(
                                    "rfgrep::processor",
                                    "rfgrep::processor",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                false
            }
            SearchDecision::Skip(reason) => {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Skipping file: {0} - {1}",
                                    path.display(),
                                    reason,
                                ),
                                lvl,
                                &(
                                    "rfgrep::processor",
                                    "rfgrep::processor",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                true
            }
            SearchDecision::Conditional(mode, reason) => {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Conditional search: {0} - {1} ({2:?})",
                                    path.display(),
                                    reason,
                                    mode,
                                ),
                                lvl,
                                &(
                                    "rfgrep::processor",
                                    "rfgrep::processor",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                false
            }
        }
    }
    fn is_binary_content(data: &[u8]) -> bool {
        if data.is_empty() {
            return false;
        }
        let sample_size = data.len().min(BINARY_CHECK_SIZE);
        let null_bytes = data[..sample_size].iter().filter(|&b| *b == 0).count();
        (null_bytes as f64 / sample_size as f64) > 0.3
    }
    pub fn get_or_compile_regex(pattern: &str) -> RfgrepResult<Regex> {
        let mut cache = REGEX_CACHE.lock().unwrap();
        if let Some(regex) = cache.get(pattern) {
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Regex cache hit for pattern: {0}", pattern),
                            lvl,
                            &(
                                "rfgrep::processor",
                                "rfgrep::processor",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            Ok(regex.clone())
        } else {
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Regex cache miss for pattern: {0}. Compiling.",
                                pattern,
                            ),
                            lvl,
                            &(
                                "rfgrep::processor",
                                "rfgrep::processor",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let regex = Regex::new(pattern).map_err(RfgrepError::Regex)?;
            cache.insert(pattern.to_string(), regex.clone());
            Ok(regex)
        }
    }
    pub fn search_file(path: &Path, pattern: &Regex) -> RfgrepResult<Vec<SearchMatch>> {
        let _start = Instant::now();
        let file_display = path.display();
        {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        { ::log::__private_api::GlobalLogger },
                        format_args!("Starting search in file: {0}", file_display),
                        lvl,
                        &(
                            "rfgrep::processor",
                            "rfgrep::processor",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            }
        };
        let file = File::open(path).map_err(RfgrepError::Io)?;
        let metadata = file.metadata().map_err(RfgrepError::Io)?;
        let file_size = metadata.len();
        if should_skip(path, &metadata) {
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Skipping file by pre-scan heuristic: {0}",
                                file_display,
                            ),
                            lvl,
                            &(
                                "rfgrep::processor",
                                "rfgrep::processor",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            return Ok(::alloc::vec::Vec::new());
        }
        let matches_found = if file_size >= get_adaptive_mmap_threshold() {
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Attempting memory mapping for file: {0} ({1} bytes)",
                                file_display,
                                file_size,
                            ),
                            lvl,
                            &(
                                "rfgrep::processor",
                                "rfgrep::processor",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            match unsafe { Mmap::map(&file) } {
                Ok(mmap) => {
                    {
                        {
                            let lvl = ::log::Level::Debug;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Successfully memory mapped file: {0}",
                                        file_display,
                                    ),
                                    lvl,
                                    &(
                                        "rfgrep::processor",
                                        "rfgrep::processor",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    if is_binary_content(&mmap) {
                        {
                            {
                                let lvl = ::log::Level::Info;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Skipping binary file (mmap): {0}",
                                            file_display,
                                        ),
                                        lvl,
                                        &(
                                            "rfgrep::processor",
                                            "rfgrep::processor",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        return Ok(::alloc::vec::Vec::new());
                    }
                    match std::str::from_utf8(&mmap) {
                        Ok(content) => {
                            find_matches_with_context(
                                content.to_string(),
                                pattern,
                                path,
                            )?
                        }
                        Err(e) => {
                            {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!(
                                                "Invalid UTF-8 in file {0}, falling back to streaming: {1}",
                                                file_display,
                                                e,
                                            ),
                                            lvl,
                                            &(
                                                "rfgrep::processor",
                                                "rfgrep::processor",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            let reader = BufReader::new(file);
                            find_matches_streaming(reader, pattern, path)?
                        }
                    }
                }
                Err(_) => {
                    {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Failed to memory map, falling back to streaming: {0}",
                                        file_display,
                                    ),
                                    lvl,
                                    &(
                                        "rfgrep::processor",
                                        "rfgrep::processor",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let reader = BufReader::new(file);
                    find_matches_streaming(reader, pattern, path)?
                }
            }
        } else {
            let reader = BufReader::new(file);
            find_matches_streaming(reader, pattern, path)?
        };
        {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        { ::log::__private_api::GlobalLogger },
                        format_args!(
                            "Finished search in file: {0} ({1} matches found)",
                            file_display,
                            matches_found.len(),
                        ),
                        lvl,
                        &(
                            "rfgrep::processor",
                            "rfgrep::processor",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            }
        };
        Ok(matches_found)
    }
    fn find_matches_with_context(
        content: String,
        pattern: &Regex,
        path: &Path,
    ) -> RfgrepResult<Vec<SearchMatch>> {
        let mut matches = Vec::new();
        let lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();
        for (i, line) in lines.iter().enumerate() {
            if let Some(m) = pattern.find(line) {
                let start_idx = i.saturating_sub(CONTEXT_LINES);
                let context_before: Vec<(usize, String)> = (start_idx..i)
                    .map(|idx| (idx + 1, lines[idx].clone()))
                    .collect();
                let end_idx = (i + CONTEXT_LINES + 1).min(lines.len());
                let context_after: Vec<(usize, String)> = ((i + 1)..end_idx)
                    .map(|idx| (idx + 1, lines[idx].to_string()))
                    .collect();
                matches
                    .push(SearchMatch {
                        path: path.to_path_buf(),
                        line_number: i + 1,
                        line: line.clone(),
                        context_before,
                        context_after,
                        matched_text: m.as_str().to_string(),
                        column_start: m.start(),
                        column_end: m.end(),
                    });
            }
        }
        Ok(matches)
    }
    fn find_matches_streaming<R: Read>(
        reader: BufReader<R>,
        pattern: &Regex,
        path: &Path,
    ) -> RfgrepResult<Vec<SearchMatch>> {
        let mut matches = Vec::new();
        let mut buffer: VecDeque<(usize, String)> = VecDeque::with_capacity(
            2 * CONTEXT_LINES + 1,
        );
        let mut lines_iter = reader.lines();
        let mut line_no = 0usize;
        while let Some(line_res) = lines_iter.next() {
            line_no += 1;
            let line = line_res.map_err(RfgrepError::Io)?;
            buffer.push_back((line_no, line.clone()));
            if buffer.len() > 2 * CONTEXT_LINES + 1 {
                buffer.pop_front();
            }
            if let Some(m) = pattern.find(&line) {
                let context_before: Vec<(usize, String)> = buffer
                    .iter()
                    .take(CONTEXT_LINES)
                    .cloned()
                    .collect();
                let mut context_after = Vec::new();
                for next in lines_iter.by_ref().take(CONTEXT_LINES) {
                    let nline = next.map_err(RfgrepError::Io)?;
                    line_no += 1;
                    context_after.push((line_no, nline));
                }
                matches
                    .push(SearchMatch {
                        path: path.to_path_buf(),
                        line_number: line_no,
                        line: line.clone(),
                        context_before,
                        context_after,
                        matched_text: m.as_str().to_string(),
                        column_start: m.start(),
                        column_end: m.end(),
                    });
            }
        }
        Ok(matches)
    }
}
/// Progress tracking and reporting
mod progress {
    use indicatif::{MultiProgress, ProgressBar, ProgressStyle};
    use parking_lot::Mutex;
    use std::sync::Arc;
    use std::time::Instant;
    #[allow(dead_code)]
    pub struct ProgressStats {
        files_processed: usize,
        bytes_processed: u64,
        matches_found: usize,
        start_time: Instant,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for ProgressStats {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ProgressStats",
                "files_processed",
                &self.files_processed,
                "bytes_processed",
                &self.bytes_processed,
                "matches_found",
                &self.matches_found,
                "start_time",
                &&self.start_time,
            )
        }
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::clone::Clone for ProgressStats {
        #[inline]
        fn clone(&self) -> ProgressStats {
            ProgressStats {
                files_processed: ::core::clone::Clone::clone(&self.files_processed),
                bytes_processed: ::core::clone::Clone::clone(&self.bytes_processed),
                matches_found: ::core::clone::Clone::clone(&self.matches_found),
                start_time: ::core::clone::Clone::clone(&self.start_time),
            }
        }
    }
    #[allow(dead_code)]
    pub struct ProgressReporter {
        pub multi_progress: Arc<MultiProgress>,
        pub main_progress: ProgressBar,
        pub stats: Arc<Mutex<ProgressStats>>,
        pub total_files: usize,
        pub style: ProgressStyle,
    }
    impl ProgressReporter {
        #[allow(dead_code)]
        pub fn new(total_files: usize) -> Self {
            let multi_progress = Arc::new(MultiProgress::new());
            let style = ProgressStyle::default_bar()
                .template(
                    "{spinner:.green} [{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} files ({eta})\n{msg}",
                )
                .unwrap()
                .progress_chars("=>-");
            let main_progress = multi_progress.add(ProgressBar::new(total_files as u64));
            main_progress.set_style(style.clone());
            Self {
                multi_progress,
                main_progress,
                stats: Arc::new(
                    Mutex::new(ProgressStats {
                        files_processed: 0,
                        bytes_processed: 0,
                        matches_found: 0,
                        start_time: Instant::now(),
                    }),
                ),
                total_files,
                style,
            }
        }
        #[allow(dead_code)]
        pub fn create_subprocess_bar(&self, name: &str, size: u64) -> ProgressBar {
            let pb = ProgressBar::new(size);
            pb.set_style(self.style.clone());
            pb.set_prefix(name.to_string());
            self.multi_progress.add(pb)
        }
        #[allow(dead_code)]
        pub fn update(&self, files: usize, bytes: u64, matches: usize) {
            let mut stats = self.stats.lock();
            stats.files_processed += files;
            stats.bytes_processed += bytes;
            stats.matches_found += matches;
            self.main_progress.inc(files as u64);
            self.update_message(&stats);
        }
        #[allow(dead_code)]
        fn update_message(&self, stats: &ProgressStats) {
            let elapsed = stats.start_time.elapsed();
            let speed = if elapsed.as_secs() > 0 {
                stats.bytes_processed as f64 / elapsed.as_secs() as f64
            } else {
                0.0
            };
            self.main_progress
                .set_message(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Speed: {0:.2} MB/s | Matches: {1} | Total Size: {2:.2} MB",
                                speed / (1024.0 * 1024.0),
                                stats.matches_found,
                                stats.bytes_processed as f64 / (1024.0 * 1024.0),
                            ),
                        )
                    }),
                );
        }
        #[allow(dead_code)]
        pub fn finish(self) -> ProgressStats {
            let stats = self.stats.lock().clone();
            self.main_progress
                .finish_with_message(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Completed in {0:.2}s: {1} files, {2} matches",
                                stats.start_time.elapsed().as_secs_f64(),
                                stats.files_processed,
                                stats.matches_found,
                            ),
                        )
                    }),
                );
            stats
        }
    }
}
/// Search algorithm implementations
mod search {
    //! Advanced search engine with streaming and plugin support
    pub mod algorithms {
        //! Advanced search algorithms including SIMD, Aho-Corasick, and fuzzy search
        use crate::processor::SearchMatch;
        use std::path::Path;
        /// Trait for search algorithms
        pub trait SearchAlgorithmTrait {
            fn search(&self, text: &str, pattern: &str) -> Vec<usize>;
            fn search_with_context(
                &self,
                text: &str,
                pattern: &str,
                context_lines: usize,
            ) -> Vec<SearchMatch>;
            fn name(&self) -> &'static str;
        }
        /// SIMD-optimized search using memchr
        pub struct SimdSearch {
            pattern: Vec<u8>,
            pattern_str: String,
        }
        impl SimdSearch {
            pub fn new(pattern: &str) -> Self {
                Self {
                    pattern: pattern.as_bytes().to_vec(),
                    pattern_str: pattern.to_string(),
                }
            }
        }
        impl SearchAlgorithmTrait for SimdSearch {
            fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
                if self.pattern.is_empty() {
                    return ::alloc::vec::Vec::new();
                }
                let text_bytes = text.as_bytes();
                let mut matches = Vec::new();
                let mut pos = 0;
                while let Some(found_pos) = memchr::memmem::find(
                    &text_bytes[pos..],
                    &self.pattern,
                ) {
                    let absolute_pos = pos + found_pos;
                    matches.push(absolute_pos);
                    pos = absolute_pos + 1;
                    if pos >= text_bytes.len() {
                        break;
                    }
                }
                matches
            }
            fn search_with_context(
                &self,
                text: &str,
                pattern: &str,
                context_lines: usize,
            ) -> Vec<SearchMatch> {
                let matches = self.search(text, pattern);
                let lines: Vec<&str> = text.lines().collect();
                let mut results = Vec::new();
                for &match_pos in &matches {
                    let pre_lines = text[..match_pos].lines().count();
                    let line_number = pre_lines.max(1);
                    let line_index = line_number - 1;
                    if line_index < lines.len() {
                        let line = lines[line_index];
                        let context_before = self
                            .get_context_before(&lines, line_index, context_lines);
                        let context_after = self
                            .get_context_after(&lines, line_index, context_lines);
                        let line_start = text[..match_pos].rfind('\n').unwrap_or(0);
                        let column_start = match_pos - line_start;
                        let column_end = column_start + self.pattern.len();
                        let matched_text = if column_start < line.len()
                            && column_end <= line.len()
                        {
                            line[column_start..column_end].to_string()
                        } else {
                            self.pattern_str.clone()
                        };
                        results
                            .push(SearchMatch {
                                path: Path::new("").to_path_buf(),
                                line_number,
                                line: line.to_string(),
                                context_before,
                                context_after,
                                matched_text,
                                column_start,
                                column_end,
                            });
                    }
                }
                results
            }
            fn name(&self) -> &'static str {
                "SIMD"
            }
        }
        impl SimdSearch {
            fn get_context_before(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let start = current_line.saturating_sub(context_lines);
                (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
            }
            fn get_context_after(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let end = (current_line + context_lines + 1).min(lines.len());
                ((current_line + 1)..end)
                    .map(|i| (i + 1, lines[i].to_string()))
                    .collect()
            }
        }
        /// Aho-Corasick algorithm for multiple pattern matching
        pub struct AhoCorasickSearch {
            patterns: Vec<String>,
            automaton: aho_corasick::AhoCorasick,
        }
        impl AhoCorasickSearch {
            pub fn new(patterns: Vec<String>) -> crate::error::Result<Self> {
                let automaton = aho_corasick::AhoCorasick::new(&patterns)
                    .map_err(|e| crate::error::RfgrepError::Other(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Aho-Corasick error: {0}", e),
                            )
                        }),
                    ))?;
                Ok(Self { patterns, automaton })
            }
        }
        impl SearchAlgorithmTrait for AhoCorasickSearch {
            fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
                self.automaton.find_iter(text).map(|m| m.start()).collect()
            }
            fn search_with_context(
                &self,
                text: &str,
                pattern: &str,
                context_lines: usize,
            ) -> Vec<SearchMatch> {
                let matches = self.search(text, pattern);
                let lines: Vec<&str> = text.lines().collect();
                let mut results = Vec::new();
                for &match_pos in &matches {
                    let pre_lines = text[..match_pos].lines().count();
                    let line_number = pre_lines.max(1);
                    let line_index = line_number - 1;
                    if line_index < lines.len() {
                        let line = lines[line_index];
                        let context_before = self
                            .get_context_before(&lines, line_index, context_lines);
                        let context_after = self
                            .get_context_after(&lines, line_index, context_lines);
                        let matched_text = self
                            .automaton
                            .find_iter(&text[match_pos..])
                            .next()
                            .map(|m| m.pattern().as_usize())
                            .and_then(|i| self.patterns.get(i))
                            .map_or(pattern, |v| v)
                            .to_string();
                        results
                            .push(SearchMatch {
                                path: Path::new("").to_path_buf(),
                                line_number,
                                line: line.to_string(),
                                context_before,
                                context_after,
                                matched_text: matched_text.clone(),
                                column_start: match_pos
                                    - text[..match_pos].rfind('\n').unwrap_or(0),
                                column_end: match_pos
                                    - text[..match_pos].rfind('\n').unwrap_or(0)
                                    + matched_text.len(),
                            });
                    }
                }
                results
            }
            fn name(&self) -> &'static str {
                "Aho-Corasick"
            }
        }
        impl AhoCorasickSearch {
            fn get_context_before(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let start = current_line.saturating_sub(context_lines);
                (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
            }
            fn get_context_after(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let end = (current_line + context_lines + 1).min(lines.len());
                ((current_line + 1)..end)
                    .map(|i| (i + 1, lines[i].to_string()))
                    .collect()
            }
        }
        /// Fuzzy search using edit distance
        pub struct FuzzySearch {
            pattern: String,
            max_distance: usize,
        }
        impl FuzzySearch {
            pub fn new(pattern: &str, max_distance: usize) -> Self {
                Self {
                    pattern: pattern.to_string(),
                    max_distance,
                }
            }
            fn levenshtein_distance(&self, s1: &str, s2: &str) -> usize {
                let s1_chars: Vec<char> = s1.chars().collect();
                let s2_chars: Vec<char> = s2.chars().collect();
                let s1_len = s1_chars.len();
                let s2_len = s2_chars.len();
                let mut matrix = ::alloc::vec::from_elem(
                    ::alloc::vec::from_elem(0, s2_len + 1),
                    s1_len + 1,
                );
                for i in 0..=s1_len {
                    matrix[i][0] = i;
                }
                for j in 0..=s2_len {
                    matrix[0][j] = j;
                }
                for i in 1..=s1_len {
                    for j in 1..=s2_len {
                        let cost = if s1_chars[i - 1] == s2_chars[j - 1] {
                            0
                        } else {
                            1
                        };
                        matrix[i][j] = (matrix[i - 1][j] + 1)
                            .min(matrix[i][j - 1] + 1)
                            .min(matrix[i - 1][j - 1] + cost);
                    }
                }
                matrix[s1_len][s2_len]
            }
        }
        impl SearchAlgorithmTrait for FuzzySearch {
            fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
                let mut matches = Vec::new();
                let words: Vec<&str> = text.split_whitespace().collect();
                for (i, word) in words.iter().enumerate() {
                    if self.levenshtein_distance(word, &self.pattern)
                        <= self.max_distance
                    {
                        let mut pos = 0;
                        for (j, w) in words.iter().enumerate() {
                            if j == i {
                                break;
                            }
                            pos += w.len() + 1;
                        }
                        matches.push(pos);
                    }
                }
                matches
            }
            fn search_with_context(
                &self,
                text: &str,
                pattern: &str,
                context_lines: usize,
            ) -> Vec<SearchMatch> {
                let matches = self.search(text, pattern);
                let lines: Vec<&str> = text.lines().collect();
                let mut results = Vec::new();
                for &match_pos in &matches {
                    let pre_lines = text[..match_pos].lines().count();
                    let line_number = pre_lines.max(1);
                    let line_index = line_number - 1;
                    if line_index < lines.len() {
                        let line = lines[line_index];
                        let context_before = self
                            .get_context_before(&lines, line_index, context_lines);
                        let context_after = self
                            .get_context_after(&lines, line_index, context_lines);
                        let line_start = text[..match_pos].rfind('\n').unwrap_or(0);
                        let column_start = match_pos - line_start;
                        let column_end = column_start + self.pattern.len();
                        let matched_text = if column_start < line.len()
                            && column_end <= line.len()
                        {
                            line[column_start..column_end].to_string()
                        } else {
                            self.pattern.clone()
                        };
                        results
                            .push(SearchMatch {
                                path: Path::new("").to_path_buf(),
                                line_number,
                                line: line.to_string(),
                                context_before,
                                context_after,
                                matched_text,
                                column_start,
                                column_end,
                            });
                    }
                }
                results
            }
            fn name(&self) -> &'static str {
                "Fuzzy"
            }
        }
        impl FuzzySearch {
            fn get_context_before(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let start = current_line.saturating_sub(context_lines);
                (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
            }
            fn get_context_after(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let end = (current_line + context_lines + 1).min(lines.len());
                ((current_line + 1)..end)
                    .map(|i| (i + 1, lines[i].to_string()))
                    .collect()
            }
        }
        /// Rabin-Karp algorithm for rolling hash search
        pub struct RabinKarpSearch {
            pattern: String,
            pattern_hash: u64,
            base: u64,
            mod_value: u64,
        }
        impl RabinKarpSearch {
            pub fn new(pattern: &str) -> Self {
                let base = 256u64;
                let mod_value = 1000000007u64;
                let pattern_hash = Self::calculate_hash(pattern, base, mod_value);
                Self {
                    pattern: pattern.to_string(),
                    pattern_hash,
                    base,
                    mod_value,
                }
            }
            fn calculate_hash(text: &str, base: u64, mod_value: u64) -> u64 {
                let mut hash = 0u64;
                for ch in text.chars() {
                    hash = (hash * base + ch as u64) % mod_value;
                }
                hash
            }
            fn rolling_hash(&self, text: &str, start: usize, length: usize) -> u64 {
                let mut hash = 0u64;
                let mut power = 1u64;
                for i in 0..length {
                    if start + i < text.len() {
                        hash = (hash
                            + (text.chars().nth(start + i).unwrap() as u64) * power)
                            % self.mod_value;
                        if i < length - 1 {
                            power = (power * self.base) % self.mod_value;
                        }
                    }
                }
                hash
            }
        }
        impl SearchAlgorithmTrait for RabinKarpSearch {
            fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
                let mut matches = Vec::new();
                let pattern_len = self.pattern.len();
                let text_len = text.len();
                if pattern_len == 0 || pattern_len > text_len {
                    return matches;
                }
                let mut text_hash = self.rolling_hash(text, 0, pattern_len);
                let mut power = 1u64;
                for _ in 0..pattern_len - 1 {
                    power = (power * self.base) % self.mod_value;
                }
                for i in 0..=text_len - pattern_len {
                    if text_hash == self.pattern_hash {
                        if &text[i..i + pattern_len] == self.pattern {
                            matches.push(i);
                        }
                    }
                    if i < text_len - pattern_len {
                        text_hash = (text_hash + self.mod_value
                            - (text.chars().nth(i).unwrap() as u64 * power)
                                % self.mod_value) % self.mod_value;
                        text_hash = (text_hash * self.base
                            + text.chars().nth(i + pattern_len).unwrap() as u64)
                            % self.mod_value;
                    }
                }
                matches
            }
            fn search_with_context(
                &self,
                text: &str,
                pattern: &str,
                context_lines: usize,
            ) -> Vec<SearchMatch> {
                let matches = self.search(text, pattern);
                let lines: Vec<&str> = text.lines().collect();
                let mut results = Vec::new();
                for &match_pos in &matches {
                    let pre_lines = text[..match_pos].lines().count();
                    let line_number = pre_lines.max(1);
                    let line_index = line_number - 1;
                    if line_index < lines.len() {
                        let line = lines[line_index];
                        let context_before = self
                            .get_context_before(&lines, line_index, context_lines);
                        let context_after = self
                            .get_context_after(&lines, line_index, context_lines);
                        let line_start = text[..match_pos].rfind('\n').unwrap_or(0);
                        let column_start = match_pos - line_start;
                        let column_end = column_start + self.pattern.len();
                        let matched_text = if column_start < line.len()
                            && column_end <= line.len()
                        {
                            line[column_start..column_end].to_string()
                        } else {
                            self.pattern.clone()
                        };
                        results
                            .push(SearchMatch {
                                path: Path::new("").to_path_buf(),
                                line_number,
                                line: line.to_string(),
                                context_before,
                                context_after,
                                matched_text,
                                column_start,
                                column_end,
                            });
                    }
                }
                results
            }
            fn name(&self) -> &'static str {
                "Rabin-Karp"
            }
        }
        impl RabinKarpSearch {
            fn get_context_before(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let start = current_line.saturating_sub(context_lines);
                (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
            }
            fn get_context_after(
                &self,
                lines: &[&str],
                current_line: usize,
                context_lines: usize,
            ) -> Vec<(usize, String)> {
                let end = (current_line + context_lines + 1).min(lines.len());
                ((current_line + 1)..end)
                    .map(|i| (i + 1, lines[i].to_string()))
                    .collect()
            }
        }
    }
    pub mod cache {
        //! Intelligent caching system for search results and file metadata
        use crate::processor::SearchMatch;
        use lru::LruCache;
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::path::PathBuf;
        use std::sync::Mutex;
        use std::time::UNIX_EPOCH;
        /// Cache key for search results
        pub struct CacheKey {
            pub file_path: PathBuf,
            pub pattern: String,
            pub case_sensitive: bool,
            pub file_hash: u64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CacheKey {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "CacheKey",
                    "file_path",
                    &self.file_path,
                    "pattern",
                    &self.pattern,
                    "case_sensitive",
                    &self.case_sensitive,
                    "file_hash",
                    &&self.file_hash,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CacheKey {
            #[inline]
            fn clone(&self) -> CacheKey {
                CacheKey {
                    file_path: ::core::clone::Clone::clone(&self.file_path),
                    pattern: ::core::clone::Clone::clone(&self.pattern),
                    case_sensitive: ::core::clone::Clone::clone(&self.case_sensitive),
                    file_hash: ::core::clone::Clone::clone(&self.file_hash),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CacheKey {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CacheKey {
            #[inline]
            fn eq(&self, other: &CacheKey) -> bool {
                self.case_sensitive == other.case_sensitive
                    && self.file_hash == other.file_hash
                    && self.file_path == other.file_path && self.pattern == other.pattern
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for CacheKey {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
            }
        }
        impl Hash for CacheKey {
            fn hash<H: Hasher>(&self, state: &mut H) {
                self.file_path.hash(state);
                self.pattern.hash(state);
                self.case_sensitive.hash(state);
                self.file_hash.hash(state);
            }
        }
        /// Search result cache
        pub struct SearchCache {
            results_cache: Mutex<LruCache<CacheKey, Vec<SearchMatch>>>,
            metadata_cache: Mutex<LruCache<PathBuf, FileMetadata>>,
            max_results_cache_size: usize,
            max_metadata_cache_size: usize,
        }
        /// File metadata for cache invalidation
        pub struct FileMetadata {
            pub size: u64,
            pub modified: u64,
            pub hash: u64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FileMetadata {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "FileMetadata",
                    "size",
                    &self.size,
                    "modified",
                    &self.modified,
                    "hash",
                    &&self.hash,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FileMetadata {
            #[inline]
            fn clone(&self) -> FileMetadata {
                FileMetadata {
                    size: ::core::clone::Clone::clone(&self.size),
                    modified: ::core::clone::Clone::clone(&self.modified),
                    hash: ::core::clone::Clone::clone(&self.hash),
                }
            }
        }
        impl SearchCache {
            /// Create a new search cache
            pub fn new() -> Self {
                Self {
                    results_cache: Mutex::new(
                        LruCache::new(std::num::NonZeroUsize::new(1000).unwrap()),
                    ),
                    metadata_cache: Mutex::new(
                        LruCache::new(std::num::NonZeroUsize::new(10000).unwrap()),
                    ),
                    max_results_cache_size: 1000,
                    max_metadata_cache_size: 10000,
                }
            }
            /// Get cached search results
            pub fn get(
                &self,
                file_path: &std::path::Path,
                pattern: &str,
                case_sensitive: bool,
            ) -> Option<Vec<SearchMatch>> {
                let metadata = self.get_file_metadata(file_path)?;
                let key = CacheKey {
                    file_path: file_path.to_path_buf(),
                    pattern: pattern.to_string(),
                    case_sensitive,
                    file_hash: metadata.hash,
                };
                self.results_cache.lock().unwrap().get(&key).cloned()
            }
            /// Insert search results into cache
            pub fn insert(
                &self,
                file_path: &std::path::Path,
                pattern: &str,
                case_sensitive: bool,
                matches: Vec<SearchMatch>,
            ) {
                let metadata = match self.get_file_metadata(file_path) {
                    Some(meta) => meta,
                    None => return,
                };
                let key = CacheKey {
                    file_path: file_path.to_path_buf(),
                    pattern: pattern.to_string(),
                    case_sensitive,
                    file_hash: metadata.hash,
                };
                self.results_cache.lock().unwrap().put(key, matches);
            }
            /// Get file metadata (cached)
            pub fn get_file_metadata(
                &self,
                file_path: &std::path::Path,
            ) -> Option<FileMetadata> {
                if let Some(metadata) = self
                    .metadata_cache
                    .lock()
                    .unwrap()
                    .get(file_path)
                {
                    return Some(metadata.clone());
                }
                let metadata = self.load_file_metadata(file_path)?;
                self.metadata_cache
                    .lock()
                    .unwrap()
                    .put(file_path.to_path_buf(), metadata.clone());
                Some(metadata)
            }
            /// Load file metadata from filesystem
            fn load_file_metadata(
                &self,
                file_path: &std::path::Path,
            ) -> Option<FileMetadata> {
                let metadata = std::fs::metadata(file_path).ok()?;
                let modified = metadata
                    .modified()
                    .ok()?
                    .duration_since(UNIX_EPOCH)
                    .ok()?
                    .as_secs();
                let hash = self.calculate_file_hash(file_path)?;
                Some(FileMetadata {
                    size: metadata.len(),
                    modified,
                    hash,
                })
            }
            /// Calculate a simple hash of the file for cache invalidation
            fn calculate_file_hash(&self, file_path: &std::path::Path) -> Option<u64> {
                let metadata = std::fs::metadata(file_path).ok()?;
                let mut hasher = DefaultHasher::new();
                metadata.len().hash(&mut hasher);
                metadata
                    .modified()
                    .ok()?
                    .duration_since(UNIX_EPOCH)
                    .ok()?
                    .as_secs()
                    .hash(&mut hasher);
                Some(hasher.finish())
            }
            /// Check if file has been modified since last cache
            pub fn is_file_modified(&self, file_path: &std::path::Path) -> bool {
                let current_metadata = self.load_file_metadata(file_path);
                let mut cache_guard = self.metadata_cache.lock().unwrap();
                let cached_metadata = cache_guard.get(file_path);
                match (current_metadata, cached_metadata) {
                    (Some(current), Some(cached)) => {
                        current.size != cached.size
                            || current.modified != cached.modified
                    }
                    (Some(_), None) => true,
                    (None, _) => true,
                }
            }
            /// Invalidate cache for a specific file
            pub fn invalidate_file(&self, file_path: &std::path::Path) {
                self.metadata_cache.lock().unwrap().pop(file_path);
                let mut results_cache = self.results_cache.lock().unwrap();
                let keys_to_remove: Vec<_> = results_cache
                    .iter()
                    .filter(|(key, _)| key.file_path == file_path)
                    .map(|(key, _)| key.clone())
                    .collect();
                for key in keys_to_remove {
                    results_cache.pop(&key);
                }
            }
            /// Clear all caches
            pub fn clear(&self) {
                self.results_cache.lock().unwrap().clear();
                self.metadata_cache.lock().unwrap().clear();
            }
            /// Get cache statistics
            pub fn get_stats(&self) -> CacheStats {
                let results_cache = self.results_cache.lock().unwrap();
                let metadata_cache = self.metadata_cache.lock().unwrap();
                CacheStats {
                    results_cache_size: results_cache.len(),
                    metadata_cache_size: metadata_cache.len(),
                    max_results_cache_size: self.max_results_cache_size,
                    max_metadata_cache_size: self.max_metadata_cache_size,
                }
            }
        }
        /// Cache statistics
        pub struct CacheStats {
            pub results_cache_size: usize,
            pub metadata_cache_size: usize,
            pub max_results_cache_size: usize,
            pub max_metadata_cache_size: usize,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CacheStats {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "CacheStats",
                    "results_cache_size",
                    &self.results_cache_size,
                    "metadata_cache_size",
                    &self.metadata_cache_size,
                    "max_results_cache_size",
                    &self.max_results_cache_size,
                    "max_metadata_cache_size",
                    &&self.max_metadata_cache_size,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CacheStats {
            #[inline]
            fn clone(&self) -> CacheStats {
                CacheStats {
                    results_cache_size: ::core::clone::Clone::clone(
                        &self.results_cache_size,
                    ),
                    metadata_cache_size: ::core::clone::Clone::clone(
                        &self.metadata_cache_size,
                    ),
                    max_results_cache_size: ::core::clone::Clone::clone(
                        &self.max_results_cache_size,
                    ),
                    max_metadata_cache_size: ::core::clone::Clone::clone(
                        &self.max_metadata_cache_size,
                    ),
                }
            }
        }
        /// Cache warming utility
        pub struct CacheWarmer {
            cache: std::sync::Arc<SearchCache>,
        }
        impl CacheWarmer {
            pub fn new(cache: std::sync::Arc<SearchCache>) -> Self {
                Self { cache }
            }
            /// Warm up cache by pre-loading metadata for common file types
            pub async fn warm_metadata(&self, paths: &[std::path::PathBuf]) {
                use rayon::prelude::*;
                paths
                    .par_iter()
                    .for_each(|path| {
                        let _ = self.cache.get_file_metadata(path);
                    });
            }
            /// Warm up cache by pre-searching common patterns
            pub async fn warm_search_results(
                &self,
                paths: &[std::path::PathBuf],
                patterns: &[String],
            ) {
                use rayon::prelude::*;
                for pattern in patterns {
                    paths
                        .par_iter()
                        .for_each(|path| {
                            let _ = self.cache.get(path, pattern, false);
                        });
                }
            }
        }
        /// Cache configuration
        pub struct CacheConfig {
            pub enable_results_cache: bool,
            pub enable_metadata_cache: bool,
            pub max_results_cache_size: usize,
            pub max_metadata_cache_size: usize,
            pub cache_ttl_seconds: u64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CacheConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "CacheConfig",
                    "enable_results_cache",
                    &self.enable_results_cache,
                    "enable_metadata_cache",
                    &self.enable_metadata_cache,
                    "max_results_cache_size",
                    &self.max_results_cache_size,
                    "max_metadata_cache_size",
                    &self.max_metadata_cache_size,
                    "cache_ttl_seconds",
                    &&self.cache_ttl_seconds,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CacheConfig {
            #[inline]
            fn clone(&self) -> CacheConfig {
                CacheConfig {
                    enable_results_cache: ::core::clone::Clone::clone(
                        &self.enable_results_cache,
                    ),
                    enable_metadata_cache: ::core::clone::Clone::clone(
                        &self.enable_metadata_cache,
                    ),
                    max_results_cache_size: ::core::clone::Clone::clone(
                        &self.max_results_cache_size,
                    ),
                    max_metadata_cache_size: ::core::clone::Clone::clone(
                        &self.max_metadata_cache_size,
                    ),
                    cache_ttl_seconds: ::core::clone::Clone::clone(
                        &self.cache_ttl_seconds,
                    ),
                }
            }
        }
        impl Default for CacheConfig {
            fn default() -> Self {
                Self {
                    enable_results_cache: true,
                    enable_metadata_cache: true,
                    max_results_cache_size: 1000,
                    max_metadata_cache_size: 10000,
                    cache_ttl_seconds: 3600,
                }
            }
        }
    }
    pub mod engine {
        //! Core search engine implementation
        use crate::metrics::Metrics;
        use crate::search::cache::SearchCache;
        use crate::search::plugins::PluginManager;
        use std::sync::Arc;
        /// Main search engine that coordinates all search operations
        pub struct SearchEngine {
            pub metrics: Arc<Metrics>,
            pub plugin_manager: PluginManager,
            pub cache: SearchCache,
        }
        impl SearchEngine {
            /// Create a new search engine
            pub fn new(metrics: Arc<Metrics>) -> crate::error::Result<Self> {
                Ok(Self {
                    metrics,
                    plugin_manager: PluginManager::new()?,
                    cache: SearchCache::new(),
                })
            }
        }
    }
    pub mod plugins {
        //! Plugin system for extensible search capabilities
        use crate::error::Result as RfgrepResult;
        use crate::processor::SearchMatch;
        use std::collections::HashMap;
        use std::path::Path;
        /// Trait for search plugins
        pub trait SearchPlugin: Send + Sync {
            fn name(&self) -> &str;
            fn can_handle(&self, file: &Path) -> bool;
            fn search(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>>;
            fn priority(&self) -> u32 {
                100
            }
        }
        /// Plugin manager that coordinates different search plugins
        pub struct PluginManager {
            plugins: Vec<Box<dyn SearchPlugin>>,
            plugin_cache: HashMap<String, usize>,
        }
        impl PluginManager {
            pub fn new() -> RfgrepResult<Self> {
                let mut manager = Self {
                    plugins: Vec::new(),
                    plugin_cache: HashMap::new(),
                };
                manager.register_plugin(Box::new(TextSearchPlugin::new()?));
                manager.register_plugin(Box::new(BinarySearchPlugin::new()?));
                manager.register_plugin(Box::new(ArchiveSearchPlugin::new()?));
                manager.register_plugin(Box::new(DatabaseSearchPlugin::new()?));
                manager.register_plugin(Box::new(ImageSearchPlugin::new()?));
                Ok(manager)
            }
            pub fn register_plugin(&mut self, plugin: Box<dyn SearchPlugin>) {
                let name = plugin.name().to_string();
                let index = self.plugins.len();
                self.plugins.push(plugin);
                self.plugin_cache.insert(name, index);
            }
            pub fn search_file(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>> {
                let mut candidates: Vec<_> = self
                    .plugins
                    .iter()
                    .enumerate()
                    .filter(|(_, plugin)| plugin.can_handle(file))
                    .collect();
                candidates.sort_by_key(|(_, plugin)| plugin.priority());
                if let Some((_, plugin)) = candidates.first() {
                    plugin.search(file, pattern)
                } else {
                    Ok(::alloc::vec::Vec::new())
                }
            }
            pub fn get_plugin_names(&self) -> Vec<&str> {
                self.plugins.iter().map(|p| p.name()).collect()
            }
        }
        /// Text file search plugin
        pub struct TextSearchPlugin {
            text_extensions: Vec<String>,
        }
        impl TextSearchPlugin {
            pub fn new() -> RfgrepResult<Self> {
                Ok(Self {
                    text_extensions: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "txt".to_string(),
                            "md".to_string(),
                            "rs".to_string(),
                            "py".to_string(),
                            "js".to_string(),
                            "ts".to_string(),
                            "go".to_string(),
                            "java".to_string(),
                            "cpp".to_string(),
                            "c".to_string(),
                            "h".to_string(),
                            "hpp".to_string(),
                            "json".to_string(),
                            "yaml".to_string(),
                            "toml".to_string(),
                            "xml".to_string(),
                            "html".to_string(),
                            "css".to_string(),
                            "sh".to_string(),
                            "bash".to_string(),
                            "zsh".to_string(),
                            "fish".to_string(),
                            "ps1".to_string(),
                            "bat".to_string(),
                        ]),
                    ),
                })
            }
        }
        impl SearchPlugin for TextSearchPlugin {
            fn name(&self) -> &str {
                "text"
            }
            fn can_handle(&self, file: &Path) -> bool {
                if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                    self.text_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
                } else {
                    if let Ok(content) = std::fs::read(file) {
                        content.iter().take(1024).all(|&b| b.is_ascii() || b >= 128)
                    } else {
                        false
                    }
                }
            }
            fn search(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>> {
                let content = std::fs::read_to_string(file)?;
                let regex = regex::Regex::new(pattern)?;
                let mut matches = Vec::new();
                for (line_num, line) in content.lines().enumerate() {
                    for mat in regex.find_iter(line) {
                        matches
                            .push(SearchMatch {
                                path: file.to_path_buf(),
                                line_number: line_num + 1,
                                line: line.to_string(),
                                context_before: Vec::new(),
                                context_after: Vec::new(),
                                matched_text: mat.as_str().to_string(),
                                column_start: mat.start(),
                                column_end: mat.end(),
                            });
                    }
                }
                Ok(matches)
            }
            fn priority(&self) -> u32 {
                10
            }
        }
        /// Binary file search plugin
        pub struct BinarySearchPlugin {
            binary_extensions: Vec<String>,
        }
        impl BinarySearchPlugin {
            pub fn new() -> RfgrepResult<Self> {
                Ok(Self {
                    binary_extensions: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "exe".to_string(),
                            "dll".to_string(),
                            "so".to_string(),
                            "dylib".to_string(),
                            "bin".to_string(),
                            "obj".to_string(),
                            "o".to_string(),
                            "a".to_string(),
                            "lib".to_string(),
                        ]),
                    ),
                })
            }
        }
        impl SearchPlugin for BinarySearchPlugin {
            fn name(&self) -> &str {
                "binary"
            }
            fn can_handle(&self, file: &Path) -> bool {
                if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                    self.binary_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
                } else {
                    if let Ok(content) = std::fs::read(file) {
                        content.iter().take(1024).any(|&b| b == 0)
                    } else {
                        false
                    }
                }
            }
            fn search(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>> {
                let content = std::fs::read(file)?;
                let pattern_bytes = pattern.as_bytes();
                let mut matches = Vec::new();
                let mut pos = 0;
                while let Some(found) = memchr::memmem::find(
                    &content[pos..],
                    pattern_bytes,
                ) {
                    let absolute_pos = pos + found;
                    matches
                        .push(SearchMatch {
                            path: file.to_path_buf(),
                            line_number: 1,
                            line: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Binary data at offset {0}", absolute_pos),
                                )
                            }),
                            context_before: Vec::new(),
                            context_after: Vec::new(),
                            matched_text: pattern.to_string(),
                            column_start: absolute_pos,
                            column_end: absolute_pos + pattern_bytes.len(),
                        });
                    pos = absolute_pos + 1;
                }
                Ok(matches)
            }
            fn priority(&self) -> u32 {
                20
            }
        }
        /// Archive file search plugin
        pub struct ArchiveSearchPlugin {
            archive_extensions: Vec<String>,
        }
        impl ArchiveSearchPlugin {
            pub fn new() -> RfgrepResult<Self> {
                Ok(Self {
                    archive_extensions: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "zip".to_string(),
                            "tar".to_string(),
                            "gz".to_string(),
                            "bz2".to_string(),
                            "xz".to_string(),
                            "7z".to_string(),
                            "rar".to_string(),
                            "tar.gz".to_string(),
                            "tgz".to_string(),
                        ]),
                    ),
                })
            }
        }
        impl SearchPlugin for ArchiveSearchPlugin {
            fn name(&self) -> &str {
                "archive"
            }
            fn can_handle(&self, file: &Path) -> bool {
                if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                    self.archive_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
                } else {
                    false
                }
            }
            fn search(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>> {
                let content = std::fs::read(file)?;
                let pattern_bytes = pattern.as_bytes();
                let mut matches = Vec::new();
                let mut pos = 0;
                while let Some(found) = memchr::memmem::find(
                    &content[pos..],
                    pattern_bytes,
                ) {
                    let absolute_pos = pos + found;
                    matches
                        .push(SearchMatch {
                            path: file.to_path_buf(),
                            line_number: 1,
                            line: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Archive metadata at offset {0}", absolute_pos),
                                )
                            }),
                            context_before: Vec::new(),
                            context_after: Vec::new(),
                            matched_text: pattern.to_string(),
                            column_start: absolute_pos,
                            column_end: absolute_pos + pattern_bytes.len(),
                        });
                    pos = absolute_pos + 1;
                }
                Ok(matches)
            }
            fn priority(&self) -> u32 {
                30
            }
        }
        /// Database file search plugin
        pub struct DatabaseSearchPlugin {
            db_extensions: Vec<String>,
        }
        impl DatabaseSearchPlugin {
            pub fn new() -> RfgrepResult<Self> {
                Ok(Self {
                    db_extensions: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "sqlite".to_string(),
                            "db".to_string(),
                            "sqlite3".to_string(),
                            "mdb".to_string(),
                            "accdb".to_string(),
                        ]),
                    ),
                })
            }
        }
        impl SearchPlugin for DatabaseSearchPlugin {
            fn name(&self) -> &str {
                "database"
            }
            fn can_handle(&self, file: &Path) -> bool {
                if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                    self.db_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
                } else {
                    false
                }
            }
            fn search(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>> {
                let content = std::fs::read(file)?;
                let pattern_bytes = pattern.as_bytes();
                let mut matches = Vec::new();
                let mut pos = 0;
                while let Some(found) = memchr::memmem::find(
                    &content[pos..],
                    pattern_bytes,
                ) {
                    let absolute_pos = pos + found;
                    matches
                        .push(SearchMatch {
                            path: file.to_path_buf(),
                            line_number: 1,
                            line: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Database content at offset {0}", absolute_pos),
                                )
                            }),
                            context_before: Vec::new(),
                            context_after: Vec::new(),
                            matched_text: pattern.to_string(),
                            column_start: absolute_pos,
                            column_end: absolute_pos + pattern_bytes.len(),
                        });
                    pos = absolute_pos + 1;
                }
                Ok(matches)
            }
            fn priority(&self) -> u32 {
                40
            }
        }
        /// Image file search plugin
        pub struct ImageSearchPlugin {
            image_extensions: Vec<String>,
        }
        impl ImageSearchPlugin {
            pub fn new() -> RfgrepResult<Self> {
                Ok(Self {
                    image_extensions: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "jpg".to_string(),
                            "jpeg".to_string(),
                            "png".to_string(),
                            "gif".to_string(),
                            "bmp".to_string(),
                            "webp".to_string(),
                            "svg".to_string(),
                            "ico".to_string(),
                            "tiff".to_string(),
                        ]),
                    ),
                })
            }
        }
        impl SearchPlugin for ImageSearchPlugin {
            fn name(&self) -> &str {
                "image"
            }
            fn can_handle(&self, file: &Path) -> bool {
                if let Some(ext) = file.extension().and_then(|e| e.to_str()) {
                    self.image_extensions.iter().any(|e| e.eq_ignore_ascii_case(ext))
                } else {
                    false
                }
            }
            fn search(
                &self,
                file: &Path,
                pattern: &str,
            ) -> RfgrepResult<Vec<SearchMatch>> {
                let content = std::fs::read(file)?;
                let pattern_bytes = pattern.as_bytes();
                let mut matches = Vec::new();
                let mut pos = 0;
                while let Some(found) = memchr::memmem::find(
                    &content[pos..],
                    pattern_bytes,
                ) {
                    let absolute_pos = pos + found;
                    matches
                        .push(SearchMatch {
                            path: file.to_path_buf(),
                            line_number: 1,
                            line: ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Image metadata at offset {0}", absolute_pos),
                                )
                            }),
                            context_before: Vec::new(),
                            context_after: Vec::new(),
                            matched_text: pattern.to_string(),
                            column_start: absolute_pos,
                            column_end: absolute_pos + pattern_bytes.len(),
                        });
                    pos = absolute_pos + 1;
                }
                Ok(matches)
            }
            fn priority(&self) -> u32 {
                50
            }
        }
        /// Plugin configuration
        pub struct PluginConfig {
            pub enabled_plugins: Vec<String>,
            pub plugin_settings: HashMap<String, serde_json::Value>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PluginConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PluginConfig",
                    "enabled_plugins",
                    &self.enabled_plugins,
                    "plugin_settings",
                    &&self.plugin_settings,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PluginConfig {
            #[inline]
            fn clone(&self) -> PluginConfig {
                PluginConfig {
                    enabled_plugins: ::core::clone::Clone::clone(&self.enabled_plugins),
                    plugin_settings: ::core::clone::Clone::clone(&self.plugin_settings),
                }
            }
        }
        impl Default for PluginConfig {
            fn default() -> Self {
                Self {
                    enabled_plugins: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "text".to_string(),
                            "binary".to_string(),
                            "archive".to_string(),
                            "database".to_string(),
                        ]),
                    ),
                    plugin_settings: HashMap::new(),
                }
            }
        }
    }
    pub mod streaming {
        //! Streaming search implementation for memory-efficient processing
        use crate::processor::SearchMatch;
        use crate::search::algorithms::SearchAlgorithmTrait;
        use std::collections::VecDeque;
        use std::fs::File;
        use std::io::{BufRead, BufReader, Read};
        use std::path::Path;
        /// Streaming search engine that processes files in chunks
        pub struct StreamingSearch {
            chunk_size: usize,
            buffer_pool: BufferPool,
        }
        /// Pool of reusable buffers to avoid allocations
        struct BufferPool {
            buffers: Vec<Vec<u8>>,
            max_size: usize,
        }
        impl BufferPool {
            fn new(max_size: usize) -> Self {
                Self {
                    buffers: Vec::new(),
                    max_size,
                }
            }
            fn get_buffer(&mut self, size: usize) -> Vec<u8> {
                self.buffers
                    .pop()
                    .filter(|buf| buf.capacity() >= size)
                    .unwrap_or_else(|| ::alloc::vec::from_elem(0u8, size))
            }
            fn return_buffer(&mut self, mut buffer: Vec<u8>) {
                if self.buffers.len() < self.max_size {
                    buffer.clear();
                    self.buffers.push(buffer);
                }
            }
        }
        impl StreamingSearch {
            /// Create a new streaming search engine
            pub fn new(chunk_size: usize) -> Self {
                Self {
                    chunk_size,
                    buffer_pool: BufferPool::new(10),
                }
            }
            /// Search a file using streaming approach
            pub fn search_file_streaming<A>(
                &mut self,
                path: &Path,
                pattern: &str,
                algorithm: &A,
                context_lines: usize,
            ) -> crate::error::Result<Vec<SearchMatch>>
            where
                A: SearchAlgorithmTrait,
            {
                let file = File::open(path)?;
                let mut reader = BufReader::new(file);
                let mut matches = Vec::new();
                let mut _line_buffer: VecDeque<String> = VecDeque::new();
                let mut line_number = 0;
                let mut context_before = VecDeque::new();
                let mut buffer = self.buffer_pool.get_buffer(self.chunk_size);
                let mut remaining = String::new();
                loop {
                    match reader.read(&mut buffer) {
                        Ok(0) => break,
                        Ok(n) => {
                            let chunk = String::from_utf8_lossy(&buffer[..n]);
                            let full_text = remaining + &chunk;
                            let lines: Vec<&str> = full_text.lines().collect();
                            let last_line_incomplete = !full_text.ends_with('\n');
                            let lines_to_process = if last_line_incomplete {
                                lines.len() - 1
                            } else {
                                lines.len()
                            };
                            for i in 0..lines_to_process {
                                line_number += 1;
                                let line = lines[i];
                                context_before.push_back((line_number, line.to_string()));
                                if context_before.len() > context_lines {
                                    context_before.pop_front();
                                }
                                let line_matches = algorithm.search(line, pattern);
                                for &match_pos in &line_matches {
                                    let context_before_vec: Vec<(usize, String)> = context_before
                                        .iter()
                                        .take(context_lines)
                                        .cloned()
                                        .collect();
                                    matches
                                        .push(SearchMatch {
                                            path: path.to_path_buf(),
                                            line_number,
                                            line: line.to_string(),
                                            context_before: context_before_vec,
                                            context_after: Vec::new(),
                                            matched_text: pattern.to_string(),
                                            column_start: match_pos,
                                            column_end: match_pos + pattern.len(),
                                        });
                                }
                            }
                            remaining = if last_line_incomplete {
                                lines.last().unwrap().to_string()
                            } else {
                                String::new()
                            };
                        }
                        Err(e) => return Err(crate::error::RfgrepError::Io(e)),
                    }
                }
                if !remaining.is_empty() {
                    line_number += 1;
                    let line_matches = algorithm.search(&remaining, pattern);
                    for &match_pos in &line_matches {
                        let context_before_vec: Vec<(usize, String)> = context_before
                            .iter()
                            .take(context_lines)
                            .cloned()
                            .collect();
                        matches
                            .push(SearchMatch {
                                path: path.to_path_buf(),
                                line_number,
                                line: remaining.clone(),
                                context_before: context_before_vec,
                                context_after: Vec::new(),
                                matched_text: pattern.to_string(),
                                column_start: match_pos,
                                column_end: match_pos + pattern.len(),
                            });
                    }
                }
                self.fill_context_after(&mut matches, path, context_lines)?;
                self.buffer_pool.return_buffer(buffer);
                Ok(matches)
            }
            /// Fill context_after for matches by reading ahead
            fn fill_context_after(
                &self,
                matches: &mut [SearchMatch],
                path: &Path,
                context_lines: usize,
            ) -> crate::error::Result<()> {
                if context_lines == 0 {
                    return Ok(());
                }
                let file = File::open(path)?;
                let reader = BufReader::new(file);
                let lines: Vec<String> = reader.lines().collect::<Result<Vec<_>, _>>()?;
                for match_ in matches.iter_mut() {
                    let start_line = match_.line_number;
                    let end_line = (start_line + context_lines).min(lines.len());
                    match_.context_after = lines[start_line..end_line]
                        .iter()
                        .enumerate()
                        .map(|(i, line)| (start_line + i + 1, line.clone()))
                        .collect();
                }
                Ok(())
            }
            /// Search multiple files in parallel using streaming
            pub fn search_files_parallel<A>(
                &mut self,
                files: &[std::path::PathBuf],
                pattern: &str,
                algorithm: &A,
                context_lines: usize,
            ) -> crate::error::Result<Vec<SearchMatch>>
            where
                A: SearchAlgorithmTrait + Send + Sync,
            {
                use rayon::prelude::*;
                use std::sync::Mutex;
                let matches = Mutex::new(Vec::new());
                let errors = Mutex::new(Vec::new());
                files
                    .par_iter()
                    .for_each(|path| {
                        let mut local_search = StreamingSearch::new(self.chunk_size);
                        match local_search
                            .search_file_streaming(
                                path,
                                pattern,
                                algorithm,
                                context_lines,
                            )
                        {
                            Ok(file_matches) => {
                                if !file_matches.is_empty() {
                                    matches.lock().unwrap().extend(file_matches);
                                }
                            }
                            Err(e) => {
                                errors.lock().unwrap().push(e);
                            }
                        }
                    });
                let collected_errors = errors.into_inner().unwrap();
                if !collected_errors.is_empty() {
                    {
                        ::std::io::_eprint(
                            format_args!("Errors encountered during streaming search:\n"),
                        );
                    };
                    for err in collected_errors {
                        {
                            ::std::io::_eprint(format_args!("  {0}\n", err));
                        };
                    }
                }
                Ok(matches.into_inner().unwrap())
            }
        }
        /// Memory-mapped search for very large files
        pub struct MemoryMappedSearch {
            mmap_threshold: usize,
        }
        impl MemoryMappedSearch {
            pub fn new(mmap_threshold: usize) -> Self {
                Self { mmap_threshold }
            }
            /// Search using memory mapping for large files
            pub fn search_mmap<A>(
                &self,
                path: &Path,
                pattern: &str,
                algorithm: &A,
                context_lines: usize,
            ) -> crate::error::Result<Vec<SearchMatch>>
            where
                A: SearchAlgorithmTrait,
            {
                let metadata = std::fs::metadata(path)?;
                if metadata.len() as usize > self.mmap_threshold {
                    self.search_with_mmap(path, pattern, algorithm, context_lines)
                } else {
                    let content = std::fs::read_to_string(path)?;
                    let matches = algorithm
                        .search_with_context(&content, pattern, context_lines);
                    Ok(
                        matches
                            .into_iter()
                            .map(|mut m| {
                                m.path = path.to_path_buf();
                                m
                            })
                            .collect(),
                    )
                }
            }
            fn search_with_mmap<A>(
                &self,
                path: &Path,
                pattern: &str,
                algorithm: &A,
                context_lines: usize,
            ) -> crate::error::Result<Vec<SearchMatch>>
            where
                A: SearchAlgorithmTrait,
            {
                use memmap2::Mmap;
                let file = File::open(path)?;
                let mmap = unsafe { Mmap::map(&file)? };
                let content = std::str::from_utf8(&mmap)
                    .map_err(|e| crate::error::RfgrepError::Other(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("Invalid UTF-8: {0}", e))
                        }),
                    ))?;
                let matches = algorithm
                    .search_with_context(content, pattern, context_lines);
                Ok(
                    matches
                        .into_iter()
                        .map(|mut m| {
                            m.path = path.to_path_buf();
                            m
                        })
                        .collect(),
                )
            }
        }
        /// Adaptive search that chooses the best strategy based on file characteristics
        pub struct AdaptiveSearch {
            streaming: StreamingSearch,
            mmap: MemoryMappedSearch,
            small_file_threshold: usize,
            large_file_threshold: usize,
        }
        impl AdaptiveSearch {
            pub fn new() -> Self {
                Self {
                    streaming: StreamingSearch::new(64 * 1024),
                    mmap: MemoryMappedSearch::new(100 * 1024 * 1024),
                    small_file_threshold: 1024 * 1024,
                    large_file_threshold: 100 * 1024 * 1024,
                }
            }
            /// Choose the best search strategy based on file size
            pub fn search_adaptive<A>(
                &mut self,
                path: &Path,
                pattern: &str,
                algorithm: &A,
                context_lines: usize,
            ) -> crate::error::Result<Vec<SearchMatch>>
            where
                A: SearchAlgorithmTrait,
            {
                let metadata = std::fs::metadata(path)?;
                let file_size = metadata.len() as usize;
                if file_size < self.small_file_threshold {
                    let content = std::fs::read_to_string(path)?;
                    let matches = algorithm
                        .search_with_context(&content, pattern, context_lines);
                    Ok(
                        matches
                            .into_iter()
                            .map(|mut m| {
                                m.path = path.to_path_buf();
                                m
                            })
                            .collect(),
                    )
                } else if file_size < self.large_file_threshold {
                    self.streaming
                        .search_file_streaming(path, pattern, algorithm, context_lines)
                } else {
                    self.mmap.search_mmap(path, pattern, algorithm, context_lines)
                }
            }
        }
    }
    use crate::cli::{SearchAlgorithm, SearchMode};
    use crate::processor::SearchMatch;
    pub use engine::SearchEngine;
    /// Search configuration
    pub struct SearchConfig {
        pub mode: SearchMode,
        pub algorithm: SearchAlgorithm,
        pub recursive: bool,
        pub extensions: Option<Vec<String>>,
        pub context_lines: usize,
        pub case_sensitive: bool,
        pub invert_match: bool,
        pub max_matches: Option<usize>,
        pub timeout_per_file: Option<u64>,
        pub max_file_size: Option<usize>,
        pub skip_binary: bool,
        pub dry_run: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "mode",
                "algorithm",
                "recursive",
                "extensions",
                "context_lines",
                "case_sensitive",
                "invert_match",
                "max_matches",
                "timeout_per_file",
                "max_file_size",
                "skip_binary",
                "dry_run",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.mode,
                &self.algorithm,
                &self.recursive,
                &self.extensions,
                &self.context_lines,
                &self.case_sensitive,
                &self.invert_match,
                &self.max_matches,
                &self.timeout_per_file,
                &self.max_file_size,
                &self.skip_binary,
                &&self.dry_run,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SearchConfig",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchConfig {
        #[inline]
        fn clone(&self) -> SearchConfig {
            SearchConfig {
                mode: ::core::clone::Clone::clone(&self.mode),
                algorithm: ::core::clone::Clone::clone(&self.algorithm),
                recursive: ::core::clone::Clone::clone(&self.recursive),
                extensions: ::core::clone::Clone::clone(&self.extensions),
                context_lines: ::core::clone::Clone::clone(&self.context_lines),
                case_sensitive: ::core::clone::Clone::clone(&self.case_sensitive),
                invert_match: ::core::clone::Clone::clone(&self.invert_match),
                max_matches: ::core::clone::Clone::clone(&self.max_matches),
                timeout_per_file: ::core::clone::Clone::clone(&self.timeout_per_file),
                max_file_size: ::core::clone::Clone::clone(&self.max_file_size),
                skip_binary: ::core::clone::Clone::clone(&self.skip_binary),
                dry_run: ::core::clone::Clone::clone(&self.dry_run),
            }
        }
    }
    impl Default for SearchConfig {
        fn default() -> Self {
            Self {
                mode: SearchMode::Text,
                algorithm: SearchAlgorithm::BoyerMoore,
                recursive: true,
                extensions: None,
                context_lines: 0,
                case_sensitive: false,
                invert_match: false,
                max_matches: None,
                timeout_per_file: None,
                max_file_size: None,
                skip_binary: false,
                dry_run: false,
            }
        }
    }
    /// Search result with metadata
    pub struct SearchResult {
        pub matches: Vec<SearchMatch>,
        pub files_searched: usize,
        pub files_skipped: usize,
        pub total_bytes: u64,
        pub duration: std::time::Duration,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchResult {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SearchResult",
                "matches",
                &self.matches,
                "files_searched",
                &self.files_searched,
                "files_skipped",
                &self.files_skipped,
                "total_bytes",
                &self.total_bytes,
                "duration",
                &&self.duration,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchResult {
        #[inline]
        fn clone(&self) -> SearchResult {
            SearchResult {
                matches: ::core::clone::Clone::clone(&self.matches),
                files_searched: ::core::clone::Clone::clone(&self.files_searched),
                files_skipped: ::core::clone::Clone::clone(&self.files_skipped),
                total_bytes: ::core::clone::Clone::clone(&self.total_bytes),
                duration: ::core::clone::Clone::clone(&self.duration),
            }
        }
    }
}
/// Multiple search algorithms (SIMD, Boyer-Moore, Regex, Simple)
pub mod search_algorithms {
    use memchr::memmem;
    use std::collections::HashMap;
    /// SIMD-optimized string search using memchr
    pub struct SimdSearch {
        pattern: Vec<u8>,
        pattern_str: String,
    }
    impl SimdSearch {
        pub fn new(pattern: &str) -> Self {
            Self {
                pattern: pattern.as_bytes().to_vec(),
                pattern_str: pattern.to_string(),
            }
        }
        /// Ultra-fast SIMD search using memchr
        pub fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
            if self.pattern.is_empty() {
                return ::alloc::vec::Vec::new();
            }
            let text_bytes = text.as_bytes();
            let mut matches = Vec::new();
            let mut pos = 0;
            let finder = memmem::Finder::new(&self.pattern);
            while let Some(found_pos) = finder.find(&text_bytes[pos..]) {
                let absolute_pos = pos + found_pos;
                matches.push(absolute_pos);
                pos = absolute_pos + 1;
                if pos >= text_bytes.len() {
                    break;
                }
            }
            matches
        }
        /// Search with context lines
        pub fn search_with_context(
            &self,
            text: &str,
            _pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            let matches = self.search(text, "");
            let lines: Vec<&str> = text.lines().collect();
            let mut results = Vec::new();
            for &match_pos in &matches {
                let pre_lines = text[..match_pos].lines().count();
                let line_number = pre_lines.max(1);
                let line_index = line_number - 1;
                if line_index < lines.len() {
                    let line = lines[line_index];
                    let context_before = self
                        .get_context_before(&lines, line_index, context_lines);
                    let context_after = self
                        .get_context_after(&lines, line_index, context_lines);
                    let column_start = match_pos
                        - text[..match_pos].rfind('\n').unwrap_or(0);
                    let column_end = column_start + self.pattern.len();
                    let matched_text = if column_start < line.len()
                        && column_end <= line.len()
                    {
                        line[column_start..column_end].to_string()
                    } else {
                        self.pattern_str.clone()
                    };
                    results
                        .push(SearchMatch {
                            line_number,
                            line: line.to_string(),
                            context_before,
                            context_after,
                            matched_text,
                            column_start,
                            column_end,
                        });
                }
            }
            results
        }
        fn get_context_before(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let start = current_line.saturating_sub(context_lines);
            (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
        }
        fn get_context_after(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let end = (current_line + context_lines + 1).min(lines.len());
            ((current_line + 1)..end).map(|i| (i + 1, lines[i].to_string())).collect()
        }
    }
    /// Boyer-Moore string search algorithm for efficient text matching
    pub struct BoyerMoore {
        pattern: Vec<u8>,
        bad_char_table: HashMap<u8, usize>,
        good_suffix_table: Vec<usize>,
    }
    impl BoyerMoore {
        pub fn new(pattern: &str) -> Self {
            let pattern_bytes = pattern.as_bytes().to_vec();
            let bad_char_table = Self::build_bad_char_table(&pattern_bytes);
            let good_suffix_table = Self::build_good_suffix_table(&pattern_bytes);
            Self {
                pattern: pattern_bytes,
                bad_char_table,
                good_suffix_table,
            }
        }
        /// Build the bad character table for Boyer-Moore algorithm
        fn build_bad_char_table(pattern: &[u8]) -> HashMap<u8, usize> {
            let mut table = HashMap::new();
            let pattern_len = pattern.len();
            for (i, &byte) in pattern.iter().enumerate() {
                table.insert(byte, pattern_len - 1 - i);
            }
            table
        }
        /// Build the good suffix table for Boyer-Moore algorithm
        fn build_good_suffix_table(pattern: &[u8]) -> Vec<usize> {
            let pattern_len = pattern.len();
            let mut table = ::alloc::vec::from_elem(1, pattern_len);
            if pattern_len > 1 {
                table[pattern_len - 2] = pattern_len;
            }
            table
        }
        /// Search for the pattern in the given text
        pub fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
            let text_bytes = text.as_bytes();
            let pattern_len = self.pattern.len();
            let text_len = text_bytes.len();
            let mut matches = Vec::new();
            if pattern_len == 0 || text_len < pattern_len {
                return matches;
            }
            let mut i = pattern_len - 1;
            while i < text_len {
                let mut j = pattern_len - 1;
                let mut k = i;
                while j > 0 && text_bytes[k] == self.pattern[j] {
                    k -= 1;
                    j -= 1;
                }
                if j == 0 && text_bytes[k] == self.pattern[0] {
                    matches.push(k);
                }
                let bad_char_shift = self
                    .bad_char_table
                    .get(&text_bytes[i])
                    .unwrap_or(&pattern_len);
                let good_suffix_shift = if j < pattern_len - 1 {
                    self.good_suffix_table[j + 1]
                } else {
                    1
                };
                let shift = bad_char_shift.max(&good_suffix_shift);
                i += shift;
            }
            matches
        }
        /// Search for all occurrences with context
        pub fn search_with_context(
            &self,
            text: &str,
            _pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            let matches = self.search(text, "");
            let lines: Vec<&str> = text.lines().collect();
            let mut results = Vec::new();
            for &match_pos in &matches {
                let pre_lines = text[..match_pos].lines().count();
                let line_number = pre_lines.max(1);
                let line_index = line_number - 1;
                if line_index < lines.len() {
                    let line = lines[line_index];
                    let context_before = self
                        .get_context_before(&lines, line_index, context_lines);
                    let context_after = self
                        .get_context_after(&lines, line_index, context_lines);
                    let line_start = text[..match_pos].rfind('\n').unwrap_or(0);
                    let column_start = match_pos - line_start;
                    let column_end = column_start + self.pattern.len();
                    let matched_text = if column_start < line.len()
                        && column_end <= line.len()
                    {
                        line[column_start..column_end].to_string()
                    } else {
                        self.pattern.iter().map(|&b| b as char).collect()
                    };
                    results
                        .push(SearchMatch {
                            line_number,
                            line: line.to_string(),
                            context_before,
                            context_after,
                            matched_text,
                            column_start,
                            column_end,
                        });
                }
            }
            results
        }
        fn get_context_before(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let start = current_line.saturating_sub(context_lines);
            (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
        }
        fn get_context_after(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let end = (current_line + context_lines + 1).min(lines.len());
            ((current_line + 1)..end).map(|i| (i + 1, lines[i].to_string())).collect()
        }
    }
    /// Search match result with context
    pub struct SearchMatch {
        pub line_number: usize,
        pub line: String,
        pub context_before: Vec<(usize, String)>,
        pub context_after: Vec<(usize, String)>,
        pub matched_text: String,
        pub column_start: usize,
        pub column_end: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchMatch {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "line_number",
                "line",
                "context_before",
                "context_after",
                "matched_text",
                "column_start",
                "column_end",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.line_number,
                &self.line,
                &self.context_before,
                &self.context_after,
                &self.matched_text,
                &self.column_start,
                &&self.column_end,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SearchMatch",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchMatch {
        #[inline]
        fn clone(&self) -> SearchMatch {
            SearchMatch {
                line_number: ::core::clone::Clone::clone(&self.line_number),
                line: ::core::clone::Clone::clone(&self.line),
                context_before: ::core::clone::Clone::clone(&self.context_before),
                context_after: ::core::clone::Clone::clone(&self.context_after),
                matched_text: ::core::clone::Clone::clone(&self.matched_text),
                column_start: ::core::clone::Clone::clone(&self.column_start),
                column_end: ::core::clone::Clone::clone(&self.column_end),
            }
        }
    }
    /// Search algorithm types
    #[allow(dead_code)]
    pub enum SearchAlgorithm {
        Simd,
        BoyerMoore,
        Regex,
        Simple,
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::fmt::Debug for SearchAlgorithm {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SearchAlgorithm::Simd => "Simd",
                    SearchAlgorithm::BoyerMoore => "BoyerMoore",
                    SearchAlgorithm::Regex => "Regex",
                    SearchAlgorithm::Simple => "Simple",
                },
            )
        }
    }
    #[automatically_derived]
    #[allow(dead_code)]
    impl ::core::clone::Clone for SearchAlgorithm {
        #[inline]
        fn clone(&self) -> SearchAlgorithm {
            match self {
                SearchAlgorithm::Simd => SearchAlgorithm::Simd,
                SearchAlgorithm::BoyerMoore => SearchAlgorithm::BoyerMoore,
                SearchAlgorithm::Regex => SearchAlgorithm::Regex,
                SearchAlgorithm::Simple => SearchAlgorithm::Simple,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SearchAlgorithm {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SearchAlgorithm::Simd => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchAlgorithm",
                            0u32,
                            "Simd",
                        )
                    }
                    SearchAlgorithm::BoyerMoore => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchAlgorithm",
                            1u32,
                            "BoyerMoore",
                        )
                    }
                    SearchAlgorithm::Regex => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchAlgorithm",
                            2u32,
                            "Regex",
                        )
                    }
                    SearchAlgorithm::Simple => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchAlgorithm",
                            3u32,
                            "Simple",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SearchAlgorithm {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            1u64 => _serde::__private228::Ok(__Field::__field1),
                            2u64 => _serde::__private228::Ok(__Field::__field2),
                            3u64 => _serde::__private228::Ok(__Field::__field3),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Simd" => _serde::__private228::Ok(__Field::__field0),
                            "BoyerMoore" => _serde::__private228::Ok(__Field::__field1),
                            "Regex" => _serde::__private228::Ok(__Field::__field2),
                            "Simple" => _serde::__private228::Ok(__Field::__field3),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Simd" => _serde::__private228::Ok(__Field::__field0),
                            b"BoyerMoore" => _serde::__private228::Ok(__Field::__field1),
                            b"Regex" => _serde::__private228::Ok(__Field::__field2),
                            b"Simple" => _serde::__private228::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<SearchAlgorithm>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SearchAlgorithm;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum SearchAlgorithm",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchAlgorithm::Simd)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchAlgorithm::BoyerMoore)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchAlgorithm::Regex)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private228::Ok(SearchAlgorithm::Simple)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Simd",
                    "BoyerMoore",
                    "Regex",
                    "Simple",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SearchAlgorithm",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<SearchAlgorithm>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    /// Search algorithm factory
    pub struct SearchAlgorithmFactory;
    impl SearchAlgorithmFactory {
        pub fn create(
            algorithm: SearchAlgorithm,
            pattern: &str,
        ) -> Box<dyn SearchAlgorithmTrait> {
            match algorithm {
                SearchAlgorithm::Simd => Box::new(SimdSearch::new(pattern)),
                SearchAlgorithm::BoyerMoore => Box::new(BoyerMoore::new(pattern)),
                SearchAlgorithm::Regex => Box::new(RegexSearch::new(pattern)),
                SearchAlgorithm::Simple => Box::new(SimpleSearch::new(pattern)),
            }
        }
        pub fn create_with_case_sensitivity(
            algorithm: SearchAlgorithm,
            pattern: &str,
            case_sensitive: bool,
        ) -> Box<dyn SearchAlgorithmTrait> {
            match algorithm {
                SearchAlgorithm::Simd => Box::new(SimdSearch::new(pattern)),
                SearchAlgorithm::BoyerMoore => Box::new(BoyerMoore::new(pattern)),
                SearchAlgorithm::Regex => Box::new(RegexSearch::new(pattern)),
                SearchAlgorithm::Simple => {
                    if case_sensitive {
                        Box::new(SimpleSearch::new_case_sensitive(pattern))
                    } else {
                        Box::new(SimpleSearch::new(pattern))
                    }
                }
            }
        }
    }
    /// Trait for search algorithms
    pub trait SearchAlgorithmTrait: Send + Sync {
        #[allow(dead_code)]
        fn search(&self, text: &str, pattern: &str) -> Vec<usize>;
        fn search_with_context(
            &self,
            text: &str,
            pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch>;
        fn get_context_before(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let start = current_line.saturating_sub(context_lines);
            (start..current_line).map(|i| (i + 1, lines[i].to_string())).collect()
        }
        fn get_context_after(
            &self,
            lines: &[&str],
            current_line: usize,
            context_lines: usize,
        ) -> Vec<(usize, String)> {
            let end = (current_line + context_lines + 1).min(lines.len());
            ((current_line + 1)..end).map(|i| (i + 1, lines[i].to_string())).collect()
        }
    }
    impl SearchAlgorithmTrait for SimdSearch {
        fn search(&self, text: &str, pattern: &str) -> Vec<usize> {
            let _ = pattern;
            SimdSearch::search(self, text, "")
        }
        fn search_with_context(
            &self,
            text: &str,
            pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            let _ = pattern;
            SimdSearch::search_with_context(self, text, "", context_lines)
        }
    }
    impl SearchAlgorithmTrait for BoyerMoore {
        fn search(&self, text: &str, pattern: &str) -> Vec<usize> {
            self.search(text, pattern)
        }
        fn search_with_context(
            &self,
            text: &str,
            pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            self.search_with_context(text, pattern, context_lines)
        }
    }
    /// Simple text search implementation
    pub struct SimpleSearch {
        pattern: String,
        case_sensitive: bool,
    }
    impl SimpleSearch {
        pub fn new(pattern: &str) -> Self {
            Self {
                pattern: pattern.to_string(),
                case_sensitive: true,
            }
        }
        pub fn new_case_sensitive(pattern: &str) -> Self {
            Self {
                pattern: pattern.to_string(),
                case_sensitive: true,
            }
        }
    }
    impl SimpleSearch {
        pub fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
            let mut matches = Vec::new();
            let mut pos = 0;
            let search_text = if self.case_sensitive {
                text.to_string()
            } else {
                text.to_lowercase()
            };
            while let Some(found_pos) = search_text[pos..].find(&self.pattern) {
                matches.push(pos + found_pos);
                pos += found_pos + 1;
                if pos >= search_text.len() {
                    break;
                }
            }
            matches
        }
        pub fn search_with_context(
            &self,
            text: &str,
            pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            let matches = self.search(text, pattern);
            let lines: Vec<&str> = text.lines().collect();
            let mut results = Vec::new();
            for &match_pos in &matches {
                let pre_lines = text[..match_pos].lines().count();
                let line_number = pre_lines.max(1);
                let line_index = line_number - 1;
                if line_index < lines.len() {
                    let line = lines[line_index];
                    let context_before = self
                        .get_context_before(&lines, line_index, context_lines);
                    let context_after = self
                        .get_context_after(&lines, line_index, context_lines);
                    let line_start = text[..match_pos].rfind('\n').unwrap_or(0);
                    let column_start = match_pos - line_start;
                    let column_end = column_start + pattern.len();
                    let matched_text = if column_start < line.len()
                        && column_end <= line.len()
                    {
                        line[column_start..column_end].to_string()
                    } else {
                        pattern.to_string()
                    };
                    results
                        .push(SearchMatch {
                            line_number,
                            line: line.to_string(),
                            context_before,
                            context_after,
                            matched_text,
                            column_start,
                            column_end,
                        });
                }
            }
            results
        }
    }
    impl SearchAlgorithmTrait for SimpleSearch {
        fn search(&self, text: &str, pattern: &str) -> Vec<usize> {
            self.search(text, pattern)
        }
        fn search_with_context(
            &self,
            text: &str,
            pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            self.search_with_context(text, pattern, context_lines)
        }
    }
    /// Regex search implementation
    pub struct RegexSearch {
        #[allow(dead_code)]
        pattern: String,
        regex: regex::Regex,
    }
    impl RegexSearch {
        pub fn new(pattern: &str) -> Self {
            let regex = regex::Regex::new(pattern).expect("Invalid regex pattern");
            Self {
                pattern: pattern.to_string(),
                regex,
            }
        }
        pub fn search(&self, text: &str, _pattern: &str) -> Vec<usize> {
            self.regex.find_iter(text).map(|m| m.start()).collect()
        }
        pub fn search_with_context(
            &self,
            text: &str,
            _pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            let matches = self.search(text, "");
            let lines: Vec<&str> = text.lines().collect();
            let mut results = Vec::new();
            for &match_pos in &matches {
                let pre_lines = text[..match_pos].lines().count();
                let line_number = pre_lines.max(1);
                let line_index = line_number - 1;
                if line_index < lines.len() {
                    let line = lines[line_index];
                    let context_before = self
                        .get_context_before(&lines, line_index, context_lines);
                    let context_after = self
                        .get_context_after(&lines, line_index, context_lines);
                    let matched_text = self
                        .regex
                        .find(&text[match_pos..])
                        .map(|m| m.as_str().to_string())
                        .unwrap_or_default();
                    let matched_len = matched_text.len();
                    results
                        .push(SearchMatch {
                            line_number,
                            line: line.to_string(),
                            context_before,
                            context_after,
                            matched_text,
                            column_start: match_pos
                                - text[..match_pos].rfind('\n').unwrap_or(0),
                            column_end: match_pos
                                - text[..match_pos].rfind('\n').unwrap_or(0) + matched_len,
                        });
                }
            }
            results
        }
    }
    impl SearchAlgorithmTrait for RegexSearch {
        fn search(&self, text: &str, pattern: &str) -> Vec<usize> {
            self.search(text, pattern)
        }
        fn search_with_context(
            &self,
            text: &str,
            pattern: &str,
            context_lines: usize,
        ) -> Vec<SearchMatch> {
            self.search_with_context(text, pattern, context_lines)
        }
    }
}
/// Streaming search pipeline for large files
pub mod streaming_search {
    //! Streaming search pipeline for efficient file processing
    use crate::error::{Result as RfgrepResult, RfgrepError};
    use crate::processor::SearchMatch as ProcessorSearchMatch;
    use crate::search_algorithms::{SearchAlgorithm, SearchAlgorithmTrait, SearchMatch};
    use std::fs::File;
    use std::io::{BufRead, BufReader, Read};
    use std::path::Path;
    use std::sync::Arc;
    use tokio::sync::mpsc;
    use tokio::task;
    /// Configuration for streaming search
    pub struct StreamingConfig {
        pub algorithm: SearchAlgorithm,
        pub context_lines: usize,
        pub case_sensitive: bool,
        pub invert_match: bool,
        pub max_matches: Option<usize>,
        pub timeout_per_file: Option<u64>,
        pub chunk_size: usize,
        pub buffer_size: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StreamingConfig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "algorithm",
                "context_lines",
                "case_sensitive",
                "invert_match",
                "max_matches",
                "timeout_per_file",
                "chunk_size",
                "buffer_size",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.algorithm,
                &self.context_lines,
                &self.case_sensitive,
                &self.invert_match,
                &self.max_matches,
                &self.timeout_per_file,
                &self.chunk_size,
                &&self.buffer_size,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StreamingConfig",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StreamingConfig {
        #[inline]
        fn clone(&self) -> StreamingConfig {
            StreamingConfig {
                algorithm: ::core::clone::Clone::clone(&self.algorithm),
                context_lines: ::core::clone::Clone::clone(&self.context_lines),
                case_sensitive: ::core::clone::Clone::clone(&self.case_sensitive),
                invert_match: ::core::clone::Clone::clone(&self.invert_match),
                max_matches: ::core::clone::Clone::clone(&self.max_matches),
                timeout_per_file: ::core::clone::Clone::clone(&self.timeout_per_file),
                chunk_size: ::core::clone::Clone::clone(&self.chunk_size),
                buffer_size: ::core::clone::Clone::clone(&self.buffer_size),
            }
        }
    }
    impl Default for StreamingConfig {
        fn default() -> Self {
            Self {
                algorithm: SearchAlgorithm::BoyerMoore,
                context_lines: 2,
                case_sensitive: true,
                invert_match: false,
                max_matches: None,
                timeout_per_file: None,
                chunk_size: 8192,
                buffer_size: 65536,
            }
        }
    }
    /// Streaming search pipeline
    pub struct StreamingSearchPipeline {
        config: StreamingConfig,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StreamingSearchPipeline {
        #[inline]
        fn clone(&self) -> StreamingSearchPipeline {
            StreamingSearchPipeline {
                config: ::core::clone::Clone::clone(&self.config),
            }
        }
    }
    impl StreamingSearchPipeline {
        /// Fast-exit search: returns true if any match is found, exits early
        pub async fn search_file_fast_exit(
            &self,
            path: &Path,
            pattern: &str,
        ) -> RfgrepResult<bool> {
            if crate::processor::is_binary(path) {
                return Ok(false);
            }
            use memchr::memmem;
            use memmap2::Mmap;
            let file = std::fs::File::open(path).map_err(crate::error::RfgrepError::Io)?;
            let metadata = file.metadata().map_err(crate::error::RfgrepError::Io)?;
            let mmap_threshold = crate::processor::get_adaptive_mmap_threshold();
            let finder = memmem::Finder::new(pattern.as_bytes());
            let found = if metadata.len() >= mmap_threshold {
                let mmap = unsafe {
                    Mmap::map(&file).map_err(crate::error::RfgrepError::Io)?
                };
                finder.find(&mmap).is_some()
            } else {
                let buf = std::fs::read(path).map_err(crate::error::RfgrepError::Io)?;
                finder.find(&buf).is_some()
            };
            Ok(found)
        }
        pub fn new(config: StreamingConfig) -> Self {
            Self { config }
        }
        /// Search a single file using streaming approach
        pub async fn search_file(
            &self,
            path: &Path,
            pattern: &str,
        ) -> RfgrepResult<Vec<ProcessorSearchMatch>> {
            if crate::processor::is_binary(path) {
                return Ok(::alloc::vec::Vec::new());
            }
            let do_search = async {
                let file = File::open(path).map_err(RfgrepError::Io)?;
                let reader = BufReader::with_capacity(self.config.buffer_size, file);
                let search_algo = self.create_search_algorithm(pattern)?;
                let matches = self
                    .process_file_streaming(reader, search_algo.as_ref(), pattern, path)
                    .await?;
                let mut final_matches = self.apply_post_processing(matches, path)?;
                if let Some(max_matches) = self.config.max_matches {
                    if final_matches.len() > max_matches {
                        final_matches.truncate(max_matches);
                    }
                }
                RfgrepResult::Ok(final_matches)
            };
            if let Some(timeout_secs) = self.config.timeout_per_file {
                if let Ok(s) = std::env::var("RFGREP_WORKER_SLEEP") {
                    if let Ok(sec) = s.parse::<u64>() {
                        let sleep_fut = async {
                            tokio::time::sleep(std::time::Duration::from_secs(sec))
                                .await;
                            do_search.await
                        };
                        return match tokio::time::timeout(
                                std::time::Duration::from_secs(timeout_secs),
                                sleep_fut,
                            )
                            .await
                        {
                            Ok(res) => res,
                            Err(_elapsed) => Ok(::alloc::vec::Vec::new()),
                        };
                    }
                }
                match tokio::time::timeout(
                        std::time::Duration::from_secs(timeout_secs),
                        do_search,
                    )
                    .await
                {
                    Ok(res) => res,
                    Err(_elapsed) => Ok(::alloc::vec::Vec::new()),
                }
            } else {
                do_search.await
            }
        }
        /// Search multiple files in parallel
        pub async fn search_files_parallel(
            &self,
            files: &[&Path],
            pattern: &str,
            max_concurrent: usize,
        ) -> RfgrepResult<Vec<ProcessorSearchMatch>> {
            let (tx, mut rx) = mpsc::channel::<
                RfgrepResult<Vec<ProcessorSearchMatch>>,
            >(files.len());
            let semaphore = Arc::new(tokio::sync::Semaphore::new(max_concurrent));
            let config = Arc::new(self.config.clone());
            let pattern = Arc::new(pattern.to_string());
            for file_path in files {
                let tx = tx.clone();
                let semaphore = semaphore.clone();
                let config = config.clone();
                let pattern = pattern.clone();
                let file_path = (*file_path).to_path_buf();
                task::spawn(async move {
                    let _permit = semaphore.acquire().await.unwrap();
                    let pipeline = StreamingSearchPipeline::new((*config).clone());
                    let result = pipeline.search_file(&file_path, &pattern).await;
                    let _ = tx.send(result).await;
                });
            }
            drop(tx);
            let mut all_matches = Vec::new();
            while let Some(result) = rx.recv().await {
                match result {
                    Ok(matches) => all_matches.extend(matches),
                    Err(e) => {
                        {
                            ::std::io::_eprint(
                                format_args!("Error in parallel search: {0}\n", e),
                            );
                        };
                    }
                }
            }
            all_matches.sort();
            Ok(all_matches)
        }
        fn create_search_algorithm(
            &self,
            pattern: &str,
        ) -> RfgrepResult<Box<dyn SearchAlgorithmTrait>> {
            use crate::search_algorithms::SearchAlgorithmFactory;
            let processed_pattern = match self.config.algorithm {
                crate::search_algorithms::SearchAlgorithm::Regex => {
                    if self.config.case_sensitive {
                        pattern.to_string()
                    } else {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("(?i){0}", pattern))
                        })
                    }
                }
                _ => pattern.to_string(),
            };
            Ok(
                SearchAlgorithmFactory::create_with_case_sensitivity(
                    self.config.algorithm.clone(),
                    &processed_pattern,
                    self.config.case_sensitive,
                ),
            )
        }
        async fn process_file_streaming<R: Read + Send + 'static>(
            &self,
            reader: BufReader<R>,
            search_algo: &dyn SearchAlgorithmTrait,
            pattern: &str,
            _path: &Path,
        ) -> RfgrepResult<Vec<SearchMatch>> {
            let mut matches = Vec::new();
            let mut lines = reader.lines();
            let mut line_number = 0;
            let mut context_buffer = Vec::new();
            while let Some(line_result) = lines.next() {
                line_number += 1;
                let line = match line_result {
                    Ok(line) => line,
                    Err(e) => {
                        if e.kind() == std::io::ErrorKind::InvalidData {
                            continue;
                        }
                        return Err(RfgrepError::Io(e));
                    }
                };
                context_buffer.push((line_number, line.clone()));
                if context_buffer.len() > self.config.context_lines * 2 + 1 {
                    context_buffer.remove(0);
                }
                let line_matches = search_algo.search(&line, pattern);
                for match_pos in line_matches {
                    let context_before = self
                        .get_context_before(&context_buffer, line_number);
                    let context_after = self
                        .get_context_after(&context_buffer, line_number, &mut lines)?;
                    let matched_text = if match_pos + 1 < line.len() {
                        line[match_pos..].chars().take(50).collect::<String>()
                    } else {
                        line.clone()
                    };
                    matches
                        .push(SearchMatch {
                            line_number,
                            line: line.clone(),
                            context_before,
                            context_after,
                            matched_text,
                            column_start: match_pos,
                            column_end: match_pos + 1,
                        });
                }
            }
            Ok(matches)
        }
        fn get_context_before(
            &self,
            context_buffer: &[(usize, String)],
            current_line: usize,
        ) -> Vec<(usize, String)> {
            let start = current_line.saturating_sub(self.config.context_lines);
            context_buffer
                .iter()
                .filter(|(line_num, _)| *line_num >= start && *line_num < current_line)
                .cloned()
                .collect()
        }
        fn get_context_after<R: Read + Send + 'static>(
            &self,
            _context_buffer: &[(usize, String)],
            current_line: usize,
            lines: &mut std::io::Lines<BufReader<R>>,
        ) -> RfgrepResult<Vec<(usize, String)>> {
            let mut context_after = Vec::new();
            let mut line_number = current_line;
            for _ in 0..self.config.context_lines {
                if let Some(line_result) = lines.next() {
                    line_number += 1;
                    let line = line_result.map_err(RfgrepError::Io)?;
                    context_after.push((line_number, line));
                } else {
                    break;
                }
            }
            Ok(context_after)
        }
        fn apply_post_processing(
            &self,
            matches: Vec<SearchMatch>,
            path: &Path,
        ) -> RfgrepResult<Vec<ProcessorSearchMatch>> {
            let mut processor_matches = Vec::new();
            for search_match in matches {
                let should_include = if self.config.invert_match {
                    search_match.matched_text.is_empty()
                } else {
                    !search_match.matched_text.is_empty()
                };
                if should_include {
                    processor_matches
                        .push(ProcessorSearchMatch {
                            path: path.to_path_buf(),
                            line_number: search_match.line_number,
                            line: search_match.line,
                            context_before: search_match.context_before,
                            context_after: search_match.context_after,
                            matched_text: search_match.matched_text,
                            column_start: search_match.column_start,
                            column_end: search_match.column_end,
                        });
                }
            }
            Ok(processor_matches)
        }
    }
    /// Utility functions for streaming search
    pub mod utils {
        use super::*;
        use std::collections::HashMap;
        /// Analyze file patterns to optimize search strategy
        pub fn analyze_file_patterns(files: &[&Path]) -> HashMap<String, usize> {
            let mut extensions = HashMap::new();
            for file in files {
                if let Some(ext) = file.extension().and_then(|s| s.to_str()) {
                    *extensions.entry(ext.to_lowercase()).or_insert(0) += 1;
                }
            }
            extensions
        }
        /// Suggest optimal algorithm based on file characteristics
        pub fn suggest_algorithm(
            pattern: &str,
            file_count: usize,
            avg_file_size: Option<u64>,
        ) -> SearchAlgorithm {
            if pattern.len() <= 4 {
                return SearchAlgorithm::BoyerMoore;
            }
            if pattern.contains("\\") || pattern.contains("[") || pattern.contains("(") {
                return SearchAlgorithm::Regex;
            }
            if file_count > 1000 && avg_file_size.is_none_or(|size| size < 1024) {
                return SearchAlgorithm::Simple;
            }
            SearchAlgorithm::BoyerMoore
        }
        /// Estimate search performance
        pub fn estimate_performance(
            file_count: usize,
            avg_file_size: u64,
            algorithm: &SearchAlgorithm,
        ) -> (f64, String) {
            let base_time_per_mb = match algorithm {
                SearchAlgorithm::BoyerMoore => 0.1,
                SearchAlgorithm::Regex => 0.5,
                SearchAlgorithm::Simple => 0.2,
                SearchAlgorithm::Simd => 0.05,
            };
            let total_size_mb = (file_count as f64 * avg_file_size as f64)
                / (1024.0 * 1024.0);
            let estimated_seconds = total_size_mb * base_time_per_mb;
            let time_str = if estimated_seconds < 1.0 {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("{0:.0}ms", estimated_seconds * 1000.0),
                    )
                })
            } else if estimated_seconds < 60.0 {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("{0:.1}s", estimated_seconds))
                })
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("{0:.1}m", estimated_seconds / 60.0),
                    )
                })
            };
            (estimated_seconds, time_str)
        }
    }
}
/// Interactive Terminal User Interface
pub mod tui {
    //! Modern TUI interface for rfgrep using ratatui
    use crate::error::Result as RfgrepResult;
    use crate::plugin_system::{EnhancedPluginManager, PluginRegistry};
    use crate::processor::SearchMatch;
    use crate::search_algorithms::SearchAlgorithm;
    use crate::streaming_search::StreamingSearchPipeline;
    use crossterm::{
        event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEvent},
        execute,
        terminal::{
            disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen,
        },
    };
    use ratatui::{
        backend::CrosstermBackend,
        layout::{Alignment, Constraint, Direction, Layout, Margin, Rect},
        style::{Color, Modifier, Style},
        text::{Line, Span, Text},
        widgets::{
            Block, Borders, Cell, Clear, List, ListItem, ListState, Paragraph, Row,
            Scrollbar, ScrollbarOrientation, ScrollbarState, Table, TableState, Wrap,
        },
        Frame, Terminal,
    };
    use std::io::{self, Stdout};
    use std::sync::Arc;
    /// TUI application state
    pub struct TuiState {
        pub pattern: String,
        pub matches: Vec<SearchMatch>,
        pub current_file_index: usize,
        pub current_match_index: usize,
        pub files: Vec<String>,
        pub search_mode: SearchMode,
        pub algorithm: SearchAlgorithm,
        pub case_sensitive: bool,
        pub context_lines: usize,
        pub show_help: bool,
        pub status_message: String,
        pub search_in_progress: bool,
        pub scroll_offset: usize,
        pub input_mode: InputMode,
        pub input_buffer: String,
        pub input_cursor: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TuiState {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "pattern",
                "matches",
                "current_file_index",
                "current_match_index",
                "files",
                "search_mode",
                "algorithm",
                "case_sensitive",
                "context_lines",
                "show_help",
                "status_message",
                "search_in_progress",
                "scroll_offset",
                "input_mode",
                "input_buffer",
                "input_cursor",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.pattern,
                &self.matches,
                &self.current_file_index,
                &self.current_match_index,
                &self.files,
                &self.search_mode,
                &self.algorithm,
                &self.case_sensitive,
                &self.context_lines,
                &self.show_help,
                &self.status_message,
                &self.search_in_progress,
                &self.scroll_offset,
                &self.input_mode,
                &self.input_buffer,
                &&self.input_cursor,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TuiState",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TuiState {
        #[inline]
        fn clone(&self) -> TuiState {
            TuiState {
                pattern: ::core::clone::Clone::clone(&self.pattern),
                matches: ::core::clone::Clone::clone(&self.matches),
                current_file_index: ::core::clone::Clone::clone(
                    &self.current_file_index,
                ),
                current_match_index: ::core::clone::Clone::clone(
                    &self.current_match_index,
                ),
                files: ::core::clone::Clone::clone(&self.files),
                search_mode: ::core::clone::Clone::clone(&self.search_mode),
                algorithm: ::core::clone::Clone::clone(&self.algorithm),
                case_sensitive: ::core::clone::Clone::clone(&self.case_sensitive),
                context_lines: ::core::clone::Clone::clone(&self.context_lines),
                show_help: ::core::clone::Clone::clone(&self.show_help),
                status_message: ::core::clone::Clone::clone(&self.status_message),
                search_in_progress: ::core::clone::Clone::clone(
                    &self.search_in_progress,
                ),
                scroll_offset: ::core::clone::Clone::clone(&self.scroll_offset),
                input_mode: ::core::clone::Clone::clone(&self.input_mode),
                input_buffer: ::core::clone::Clone::clone(&self.input_buffer),
                input_cursor: ::core::clone::Clone::clone(&self.input_cursor),
            }
        }
    }
    pub enum SearchMode {
        Text,
        Word,
        Regex,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SearchMode::Text => "Text",
                    SearchMode::Word => "Word",
                    SearchMode::Regex => "Regex",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchMode {
        #[inline]
        fn clone(&self) -> SearchMode {
            match self {
                SearchMode::Text => SearchMode::Text,
                SearchMode::Word => SearchMode::Word,
                SearchMode::Regex => SearchMode::Regex,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SearchMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SearchMode {
        #[inline]
        fn eq(&self, other: &SearchMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    pub enum InputMode {
        Normal,
        Search,
        Command,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InputMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    InputMode::Normal => "Normal",
                    InputMode::Search => "Search",
                    InputMode::Command => "Command",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InputMode {
        #[inline]
        fn clone(&self) -> InputMode {
            match self {
                InputMode::Normal => InputMode::Normal,
                InputMode::Search => InputMode::Search,
                InputMode::Command => InputMode::Command,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InputMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InputMode {
        #[inline]
        fn eq(&self, other: &InputMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl Default for TuiState {
        fn default() -> Self {
            Self {
                pattern: String::new(),
                matches: Vec::new(),
                current_file_index: 0,
                current_match_index: 0,
                files: Vec::new(),
                search_mode: SearchMode::Text,
                algorithm: SearchAlgorithm::BoyerMoore,
                case_sensitive: false,
                context_lines: 0,
                show_help: false,
                status_message: "Ready".to_string(),
                search_in_progress: false,
                scroll_offset: 0,
                input_mode: InputMode::Normal,
                input_buffer: String::new(),
                input_cursor: 0,
            }
        }
    }
    /// TUI application
    pub struct TuiApp {
        pub state: TuiState,
        plugin_manager: Arc<EnhancedPluginManager>,
        streaming_pipeline: Option<StreamingSearchPipeline>,
        list_state: ListState,
        table_state: TableState,
        scrollbar_state: ScrollbarState,
        should_quit: bool,
    }
    impl TuiApp {
        pub async fn new() -> RfgrepResult<Self> {
            let plugin_manager = Arc::new(EnhancedPluginManager::new());
            let registry = PluginRegistry::new(plugin_manager.clone());
            registry.load_plugins().await?;
            let mut list_state = ListState::default();
            list_state.select(Some(0));
            let mut table_state = TableState::default();
            table_state.select(Some(0));
            Ok(Self {
                state: TuiState::default(),
                plugin_manager,
                streaming_pipeline: None,
                list_state,
                table_state,
                scrollbar_state: ScrollbarState::default(),
                should_quit: false,
            })
        }
        pub async fn run(
            &mut self,
            terminal: &mut Terminal<CrosstermBackend<Stdout>>,
        ) -> RfgrepResult<()> {
            loop {
                terminal.draw(|f| self.ui(f))?;
                if let Event::Key(key) = event::read()? {
                    if self.handle_key_event(key).await? {
                        break;
                    }
                }
            }
            Ok(())
        }
        fn ui(&mut self, f: &mut Frame) {
            let chunks = Layout::default()
                .direction(Direction::Vertical)
                .constraints([
                    Constraint::Length(3),
                    Constraint::Min(0),
                    Constraint::Length(3),
                ])
                .split(f.area());
            self.render_header(f, chunks[0]);
            self.render_main_content(f, chunks[1]);
            self.render_status_bar(f, chunks[2]);
            if self.state.show_help {
                self.render_help_overlay(f);
            }
        }
        fn render_header(&self, f: &mut Frame, area: Rect) {
            let header_text = if self.state.input_mode == InputMode::Search {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "rfgrep TUI - Search: {0}_",
                            self.state.input_buffer,
                        ),
                    )
                })
            } else if self.state.search_in_progress {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "rfgrep TUI - Searching for: \'{0}\'...",
                            self.state.pattern,
                        ),
                    )
                })
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("rfgrep TUI - Pattern: \'{0}\'", self.state.pattern),
                    )
                })
            };
            let header = Paragraph::new(header_text)
                .style(Style::default().fg(Color::White).add_modifier(Modifier::BOLD))
                .alignment(Alignment::Center)
                .block(Block::default().borders(Borders::ALL).title("rfgrep"));
            f.render_widget(header, area);
        }
        fn render_main_content(&mut self, f: &mut Frame, area: Rect) {
            if self.state.matches.is_empty() {
                self.render_empty_state(f, area);
            } else {
                let chunks = Layout::default()
                    .direction(Direction::Horizontal)
                    .constraints([
                        Constraint::Percentage(30),
                        Constraint::Percentage(70),
                    ])
                    .split(area);
                self.render_file_list(f, chunks[0]);
                self.render_matches_table(f, chunks[1]);
            }
        }
        fn render_empty_state(&self, f: &mut Frame, area: Rect) {
            let empty_text = if self.state.pattern.is_empty() {
                "Enter a search pattern to begin..."
            } else {
                "No matches found. Try a different pattern or press 'h' for help."
            };
            let empty_para = Paragraph::new(empty_text)
                .style(Style::default().fg(Color::Yellow))
                .alignment(Alignment::Center)
                .wrap(Wrap { trim: true });
            f.render_widget(empty_para, area);
        }
        fn render_file_list(&mut self, f: &mut Frame, area: Rect) {
            let items: Vec<ListItem> = self
                .state
                .files
                .iter()
                .enumerate()
                .map(|(i, file)| {
                    let style = if i == self.state.current_file_index {
                        Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
                    } else {
                        Style::default()
                    };
                    ListItem::new(Line::from(Span::styled(file.as_str(), style)))
                })
                .collect();
            let list = List::new(items)
                .block(Block::default().borders(Borders::ALL).title("Files"))
                .highlight_style(
                    Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD),
                );
            f.render_stateful_widget(list, area, &mut self.list_state);
        }
        fn render_matches_table(&mut self, f: &mut Frame, area: Rect) {
            let matches = &self.state.matches;
            let start_idx = self.state.scroll_offset;
            let end_idx = (start_idx + (area.height as usize).saturating_sub(2))
                .min(matches.len());
            let rows: Vec<Row> = matches[start_idx..end_idx]
                .iter()
                .enumerate()
                .map(|(i, m)| {
                    let line_num = ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("{0:<4}", m.line_number))
                    });
                    let content = if m.line.len() > 80 {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0}...", &m.line[..77]))
                        })
                    } else {
                        m.line.clone()
                    };
                    let style = if start_idx + i == self.state.current_match_index {
                        Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
                    } else {
                        Style::default()
                    };
                    Row::new(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                Cell::from(Span::styled(line_num, style)),
                                Cell::from(Span::styled(content, style)),
                            ]),
                        ),
                    )
                })
                .collect();
            let table = Table::new(rows, &[Constraint::Length(6), Constraint::Min(0)])
                .block(Block::default().borders(Borders::ALL).title("Matches"))
                .column_spacing(1);
            f.render_stateful_widget(table, area, &mut self.table_state);
            if matches.len() > (area.height as usize).saturating_sub(2) {
                let scrollbar = Scrollbar::default()
                    .orientation(ScrollbarOrientation::VerticalRight)
                    .begin_symbol(Some("â"))
                    .end_symbol(Some("â"));
                f.render_stateful_widget(
                    scrollbar,
                    area
                        .inner(Margin {
                            vertical: 1,
                            horizontal: 0,
                        }),
                    &mut self.scrollbar_state,
                );
            }
        }
        fn render_status_bar(&self, f: &mut Frame, area: Rect) {
            let status_text = if self.state.search_in_progress {
                "Searching...".to_string()
            } else {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "Matches: {0} | Files: {1} | Mode: {2:?} | Algorithm: {3:?} | Case: {4}",
                            self.state.matches.len(),
                            self.state.files.len(),
                            self.state.search_mode,
                            self.state.algorithm,
                            if self.state.case_sensitive { "ON" } else { "OFF" },
                        ),
                    )
                })
            };
            let status = Paragraph::new(status_text)
                .style(Style::default().fg(Color::White).bg(Color::DarkGray))
                .alignment(Alignment::Left);
            f.render_widget(status, area);
        }
        fn render_help_overlay(&self, f: &mut Frame) {
            let area = f.area();
            let help_text = <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    "rfgrep TUI Help",
                    "",
                    "Navigation:",
                    "  â/â, j/k    - Navigate matches",
                    "  â/â, h/l    - Navigate files",
                    "  Page Up/Dn  - Scroll matches",
                    "",
                    "Search:",
                    "  /           - Enter search input mode",
                    "  n           - Next match",
                    "  N           - Previous match",
                    "  Enter       - Open file in editor",
                    "",
                    "Search Input Mode:",
                    "  Type pattern - Enter search pattern",
                    "  Enter       - Execute search",
                    "  Esc         - Cancel search",
                    "  â/â         - Move cursor",
                    "  Home/End    - Jump to start/end",
                    "",
                    "Settings:",
                    "  c           - Toggle case sensitivity",
                    "  m           - Change search mode",
                    "  a           - Change algorithm",
                    "  r           - Refresh search",
                    "",
                    "Other:",
                    "  h           - Toggle this help",
                    "  q           - Quit",
                    "  ESC         - Exit current mode",
                ]),
            );
            let help_para = Paragraph::new(Text::from(help_text.join("\n")))
                .style(Style::default().fg(Color::White).bg(Color::Black))
                .alignment(Alignment::Left)
                .wrap(Wrap { trim: true })
                .block(Block::default().borders(Borders::ALL).title("Help"));
            let centered_area = centered_rect(60, 70, area);
            f.render_widget(Clear, area);
            f.render_widget(help_para, centered_area);
        }
        async fn handle_key_event(&mut self, key: KeyEvent) -> RfgrepResult<bool> {
            if self.state.show_help {
                if key.code == KeyCode::Char('h') || key.code == KeyCode::Esc {
                    self.state.show_help = false;
                }
                return Ok(false);
            }
            if self.state.input_mode != InputMode::Normal {
                return self.handle_input_mode(key).await;
            }
            match key.code {
                KeyCode::Char('q') => return Ok(true),
                KeyCode::Char('h') => {
                    self.state.show_help = true;
                }
                KeyCode::Char('j') | KeyCode::Down => {
                    self.next_match();
                }
                KeyCode::Char('k') | KeyCode::Up => {
                    self.previous_match();
                }
                KeyCode::Char('l') | KeyCode::Right => {
                    self.next_file();
                }
                KeyCode::Left => {
                    self.previous_file();
                }
                KeyCode::Char('n') => {
                    self.next_match();
                }
                KeyCode::Char('N') => {
                    self.previous_match();
                }
                KeyCode::Char('c') => {
                    self.state.case_sensitive = !self.state.case_sensitive;
                    self.state.status_message = ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Case sensitivity: {0}",
                                if self.state.case_sensitive { "ON" } else { "OFF" },
                            ),
                        )
                    });
                }
                KeyCode::Char('m') => {
                    self.cycle_search_mode();
                }
                KeyCode::Char('a') => {
                    self.cycle_algorithm();
                }
                KeyCode::Char('r') => {
                    self.refresh_search().await?;
                }
                KeyCode::Char('/') => {
                    self.enter_search_input_mode();
                }
                KeyCode::Enter => {
                    self.open_current_file();
                }
                KeyCode::PageUp => {
                    self.scroll_up();
                }
                KeyCode::PageDown => {
                    self.scroll_down();
                }
                _ => {}
            }
            Ok(false)
        }
        fn next_match(&mut self) {
            if !self.state.matches.is_empty() {
                self.state.current_match_index = (self.state.current_match_index + 1)
                    % self.state.matches.len();
                self.update_file_index_from_match();
            }
        }
        fn previous_match(&mut self) {
            if !self.state.matches.is_empty() {
                self.state.current_match_index = if self.state.current_match_index == 0 {
                    self.state.matches.len() - 1
                } else {
                    self.state.current_match_index - 1
                };
                self.update_file_index_from_match();
            }
        }
        fn next_file(&mut self) {
            if !self.state.files.is_empty() {
                self.state.current_file_index = (self.state.current_file_index + 1)
                    % self.state.files.len();
                self.update_match_index_from_file();
            }
        }
        fn previous_file(&mut self) {
            if !self.state.files.is_empty() {
                self.state.current_file_index = if self.state.current_file_index == 0 {
                    self.state.files.len() - 1
                } else {
                    self.state.current_file_index - 1
                };
                self.update_match_index_from_file();
            }
        }
        fn update_file_index_from_match(&mut self) {
            if let Some(current_match) = self
                .state
                .matches
                .get(self.state.current_match_index)
            {
                if let Some(file_index) = self
                    .state
                    .files
                    .iter()
                    .position(|f| f == &current_match.path.to_string_lossy())
                {
                    self.state.current_file_index = file_index;
                }
            }
        }
        fn update_match_index_from_file(&mut self) {
            if let Some(current_file) = self
                .state
                .files
                .get(self.state.current_file_index)
            {
                if let Some(match_index) = self
                    .state
                    .matches
                    .iter()
                    .position(|m| m.path.to_string_lossy() == *current_file)
                {
                    self.state.current_match_index = match_index;
                }
            }
        }
        fn cycle_search_mode(&mut self) {
            self.state.search_mode = match self.state.search_mode {
                SearchMode::Text => SearchMode::Word,
                SearchMode::Word => SearchMode::Regex,
                SearchMode::Regex => SearchMode::Text,
            };
            self.state.status_message = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("Search mode: {0:?}", self.state.search_mode),
                )
            });
        }
        fn cycle_algorithm(&mut self) {
            self.state.algorithm = match self.state.algorithm {
                SearchAlgorithm::BoyerMoore => SearchAlgorithm::Regex,
                SearchAlgorithm::Regex => SearchAlgorithm::Simple,
                SearchAlgorithm::Simple => SearchAlgorithm::Simd,
                SearchAlgorithm::Simd => SearchAlgorithm::BoyerMoore,
            };
            self.state.status_message = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("Algorithm: {0:?}", self.state.algorithm),
                )
            });
        }
        fn scroll_up(&mut self) {
            if self.state.scroll_offset > 0 {
                self.state.scroll_offset -= 1;
            }
        }
        fn scroll_down(&mut self) {
            let max_scroll = self.state.matches.len().saturating_sub(10);
            if self.state.scroll_offset < max_scroll {
                self.state.scroll_offset += 1;
            }
        }
        fn open_current_file(&mut self) {
            if let Some(current_match) = self
                .state
                .matches
                .get(self.state.current_match_index)
            {
                self.state.status_message = ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("Opening: {0}", current_match.path.display()),
                    )
                });
                let path = &current_match.path;
                let editor = std::env::var("EDITOR").ok();
                let result = if let Some(ed) = editor {
                    std::process::Command::new(ed).arg(path).spawn()
                } else if false {
                    std::process::Command::new("open").arg(path).spawn()
                } else if false {
                    std::process::Command::new("cmd")
                        .args(["/C", "start", "", &path.to_string_lossy()])
                        .spawn()
                } else {
                    std::process::Command::new("xdg-open").arg(path).spawn()
                };
                if result.is_err() {
                    self.state.status_message = ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("Failed to open: {0}", path.display()),
                        )
                    });
                }
            }
        }
        async fn refresh_search(&mut self) -> RfgrepResult<()> {
            if self.state.pattern.is_empty() {
                self.state.status_message = "No pattern to search".to_string();
                return Ok(());
            }
            self.state.search_in_progress = true;
            self.state.status_message = "Searching...".to_string();
            use crate::walker::walk_dir;
            use std::path::Path;
            let pattern = self.state.pattern.clone();
            let mut all_matches: Vec<SearchMatch> = Vec::new();
            let cwd = std::env::current_dir()
                .unwrap_or_else(|_| std::path::PathBuf::from("."));
            let entries: Vec<_> = walk_dir(Path::new(&cwd), true, false).collect();
            for entry in entries {
                let path = entry.path();
                if path.is_file() {
                    let res = self.plugin_manager.search_file(path, &pattern).await;
                    if let Ok(mut matches) = res {
                        all_matches.append(&mut matches);
                    }
                }
            }
            self.set_matches(all_matches);
            self.state.search_in_progress = false;
            self.state.status_message = "Search completed".to_string();
            Ok(())
        }
        pub fn set_pattern(&mut self, pattern: String) {
            self.state.pattern = pattern;
        }
        pub fn set_matches(&mut self, matches: Vec<SearchMatch>) {
            self.state.matches = matches;
            self.state.current_match_index = 0;
            self.state.current_file_index = 0;
            self.state.scroll_offset = 0;
            let mut files = std::collections::HashSet::new();
            for m in &self.state.matches {
                files.insert(m.path.to_string_lossy().to_string());
            }
            self.state.files = files.into_iter().collect();
            self.state.files.sort();
        }
        /// Enter search input mode
        fn enter_search_input_mode(&mut self) {
            self.state.input_mode = InputMode::Search;
            self.state.input_buffer = self.state.pattern.clone();
            self.state.input_cursor = self.state.input_buffer.len();
            self.state.status_message = "Enter search pattern (Enter to search, Esc to cancel)"
                .to_string();
        }
        /// Handle input mode key events
        async fn handle_input_mode(&mut self, key: KeyEvent) -> RfgrepResult<bool> {
            match self.state.input_mode {
                InputMode::Search => self.handle_search_input(key).await,
                InputMode::Command => self.handle_command_input(key).await,
                InputMode::Normal => Ok(false),
            }
        }
        /// Handle search input mode
        async fn handle_search_input(&mut self, key: KeyEvent) -> RfgrepResult<bool> {
            match key.code {
                KeyCode::Enter => {
                    self.state.pattern = self.state.input_buffer.clone();
                    self.state.input_mode = InputMode::Normal;
                    self.state.input_buffer.clear();
                    self.state.input_cursor = 0;
                    self.state.status_message = "Searching...".to_string();
                    self.refresh_search().await?;
                    Ok(false)
                }
                KeyCode::Esc => {
                    self.state.input_mode = InputMode::Normal;
                    self.state.input_buffer.clear();
                    self.state.input_cursor = 0;
                    self.state.status_message = "Search cancelled".to_string();
                    Ok(false)
                }
                KeyCode::Backspace => {
                    if self.state.input_cursor > 0 {
                        self.state.input_cursor -= 1;
                        self.state.input_buffer.remove(self.state.input_cursor);
                    }
                    Ok(false)
                }
                KeyCode::Delete => {
                    if self.state.input_cursor < self.state.input_buffer.len() {
                        self.state.input_buffer.remove(self.state.input_cursor);
                    }
                    Ok(false)
                }
                KeyCode::Left => {
                    if self.state.input_cursor > 0 {
                        self.state.input_cursor -= 1;
                    }
                    Ok(false)
                }
                KeyCode::Right => {
                    if self.state.input_cursor < self.state.input_buffer.len() {
                        self.state.input_cursor += 1;
                    }
                    Ok(false)
                }
                KeyCode::Home => {
                    self.state.input_cursor = 0;
                    Ok(false)
                }
                KeyCode::End => {
                    self.state.input_cursor = self.state.input_buffer.len();
                    Ok(false)
                }
                KeyCode::Char(c) => {
                    self.state.input_buffer.insert(self.state.input_cursor, c);
                    self.state.input_cursor += 1;
                    Ok(false)
                }
                _ => Ok(false),
            }
        }
        /// Handle command input mode (for future use)
        async fn handle_command_input(&mut self, key: KeyEvent) -> RfgrepResult<bool> {
            match key.code {
                KeyCode::Enter => {
                    self.state.input_mode = InputMode::Normal;
                    self.state.input_buffer.clear();
                    self.state.input_cursor = 0;
                    self.state.status_message = "Command processed".to_string();
                    Ok(false)
                }
                KeyCode::Esc => {
                    self.state.input_mode = InputMode::Normal;
                    self.state.input_buffer.clear();
                    self.state.input_cursor = 0;
                    self.state.status_message = "Command cancelled".to_string();
                    Ok(false)
                }
                _ => self.handle_search_input(key).await,
            }
        }
    }
    fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -> Rect {
        let popup_layout = Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Percentage((100 - percent_y) / 2),
                Constraint::Percentage(percent_y),
                Constraint::Percentage((100 - percent_y) / 2),
            ])
            .split(r);
        Layout::default()
            .direction(Direction::Horizontal)
            .constraints([
                Constraint::Percentage((100 - percent_x) / 2),
                Constraint::Percentage(percent_x),
                Constraint::Percentage((100 - percent_x) / 2),
            ])
            .split(popup_layout[1])[1]
    }
    pub fn init_terminal() -> RfgrepResult<Terminal<CrosstermBackend<Stdout>>> {
        if !atty::is(atty::Stream::Stdout) {
            return Err(
                crate::error::RfgrepError::Io(
                    std::io::Error::new(
                        std::io::ErrorKind::Unsupported,
                        "TUI requires an interactive terminal. Please run in a proper terminal environment.",
                    ),
                ),
            );
        }
        if std::env::var("TERM").is_err() {
            return Err(
                crate::error::RfgrepError::Io(
                    std::io::Error::new(
                        std::io::ErrorKind::Unsupported,
                        "TUI requires a proper terminal environment. TERM environment variable not set.",
                    ),
                ),
            );
        }
        enable_raw_mode()?;
        let mut stdout = io::stdout();
        {
            use ::std::io::Write;
            {
                use ::std::io::Write;
                Ok(stdout.by_ref())
                    .and_then(|writer| ::crossterm::QueueableCommand::queue(
                        writer,
                        EnterAlternateScreen,
                    ))
                    .and_then(|writer| ::crossterm::QueueableCommand::queue(
                        writer,
                        EnableMouseCapture,
                    ))
                    .map(|_| ())
            }
                .and_then(|()| { ::std::io::Write::flush(stdout.by_ref()) })
        }?;
        let backend = CrosstermBackend::new(stdout);
        let terminal = Terminal::new(backend)?;
        Ok(terminal)
    }
    pub fn restore_terminal(
        terminal: &mut Terminal<CrosstermBackend<Stdout>>,
    ) -> RfgrepResult<()> {
        disable_raw_mode()?;
        {
            use ::std::io::Write;
            {
                use ::std::io::Write;
                Ok(terminal.backend_mut().by_ref())
                    .and_then(|writer| ::crossterm::QueueableCommand::queue(
                        writer,
                        LeaveAlternateScreen,
                    ))
                    .and_then(|writer| ::crossterm::QueueableCommand::queue(
                        writer,
                        DisableMouseCapture,
                    ))
                    .map(|_| ())
            }
                .and_then(|()| {
                    ::std::io::Write::flush(terminal.backend_mut().by_ref())
                })
        }?;
        terminal.show_cursor()?;
        Ok(())
    }
}
/// Directory walking and file discovery
pub mod walker {
    use ignore::{DirEntry, WalkBuilder};
    use std::path::Path;
    pub fn walk_dir(
        path: &Path,
        recursive: bool,
        show_hidden: bool,
    ) -> impl Iterator<Item = DirEntry> {
        let max_depth = if recursive { None } else { Some(1) };
        WalkBuilder::new(path)
            .hidden(!show_hidden)
            .git_global(!show_hidden)
            .git_ignore(!show_hidden)
            .git_exclude(!show_hidden)
            .ignore(!show_hidden)
            .max_depth(max_depth)
            .build()
            .filter_map(Result::ok)
    }
}
use crate::config::Config;
/// Result type alias for rfgrep operations
pub use crate::error::Result;
/// Command-line argument parser from clap
pub use clap::Parser;
/// CLI definitions and search modes
pub use cli::{Cli, Commands, SearchMode};
/// File information structure for listing operations
pub use list::FileInfo;
/// Core file processing functions
pub use processor::{is_binary, search_file};
/// Search algorithm implementations and utilities
pub use search_algorithms::{
    BoyerMoore, RegexSearch, SearchAlgorithm, SearchAlgorithmFactory, SearchMatch,
    SimdSearch, SimpleSearch,
};
use std::path::Path;
/// Path buffer type for file operations
pub use std::path::PathBuf;
/// Directory walking functionality
pub use walker::walk_dir;
/// Application configuration for rfgrep operations
///
/// Contains runtime configuration including chunk sizes, executable paths,
/// and output directories for benchmarking and testing operations.
pub struct AppConfig {
    /// Chunk size for parallel processing (in number of files)
    pub chunk_size: Option<u32>,
    /// Path to the rfgrep executable
    pub rfgrep_exe: PathBuf,
    /// Directory for storing benchmark results and test outputs
    pub results_dir: PathBuf,
}
#[automatically_derived]
impl ::core::fmt::Debug for AppConfig {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "AppConfig",
            "chunk_size",
            &self.chunk_size,
            "rfgrep_exe",
            &self.rfgrep_exe,
            "results_dir",
            &&self.results_dir,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for AppConfig {
    #[inline]
    fn clone(&self) -> AppConfig {
        AppConfig {
            chunk_size: ::core::clone::Clone::clone(&self.chunk_size),
            rfgrep_exe: ::core::clone::Clone::clone(&self.rfgrep_exe),
            results_dir: ::core::clone::Clone::clone(&self.results_dir),
        }
    }
}
impl AppConfig {
    /// Create application configuration from CLI arguments
    ///
    /// # Arguments
    /// * `cli` - Parsed command-line interface arguments
    ///
    /// # Returns
    /// * `AppConfig` - Configured application settings
    ///
    /// # Panics
    /// Panics if the results directory cannot be created
    pub fn from_cli(cli: &Cli) -> Self {
        let rfgrep_exe = cli.path.join("rfgrep");
        let results_dir = cli.path.join("results");
        std::fs::create_dir_all(&results_dir)
            .expect("Failed to create results directory");
        AppConfig {
            chunk_size: Some(100),
            rfgrep_exe,
            results_dir,
        }
    }
}
/// Load application configuration from file or use defaults
///
/// Attempts to load configuration from the default location, falling back
/// to default values if no configuration file is found.
///
/// # Returns
/// * `AppConfig` - Loaded or default configuration
pub fn load_config() -> AppConfig {
    let mut cfg = Config::default();
    if let Ok(config) = Config::load() {
        cfg = config;
    }
    AppConfig {
        chunk_size: Some(cfg.search.chunk_size as u32),
        rfgrep_exe: std::env::current_exe()
            .unwrap_or_else(|_| std::path::PathBuf::from("rfgrep")),
        results_dir: std::path::PathBuf::from("results"),
    }
}
/// Execute an external command with optional environment variables
///
/// # Arguments
/// * `command` - Command to execute
/// * `args` - Command arguments
/// * `env` - Optional environment variable value
///
/// # Returns
/// * `std::io::Result<()>` - Success or I/O error
///
/// # Example
/// ```no_run
/// use rfgrep::run_external_command;
///
/// fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // Run a simple command
///     run_external_command("echo", &["hello"], None)?;
///
///     // Run with environment variable
///     run_external_command("env", &[], Some("test_value"))?;
///     Ok(())
/// }
/// ```
pub fn run_external_command(
    command: &str,
    args: &[&str],
    env: Option<&str>,
) -> std::io::Result<()> {
    let mut cmd = std::process::Command::new(command);
    cmd.args(args);
    if let Some(env_var) = env {
        cmd.env("RFGREP_TEST_ENV", env_var);
    }
    cmd.status()?;
    Ok(())
}
/// Run comprehensive performance benchmarks using hyperfine
///
/// Executes a series of performance tests including warmup and detailed
/// benchmarking with JSON and Markdown output formats.
///
/// # Arguments
/// * `config` - Application configuration with paths and settings
/// * `test_dir` - Directory containing test files for benchmarking
///
/// # Returns
/// * `Result<()>` - Success or error during benchmark execution
///
/// # Example
/// ```no_run
/// use rfgrep::{AppConfig, run_benchmarks};
/// use std::path::Path;
///
/// fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // Create config manually for doctest
///     let config = AppConfig {
///         chunk_size: Some(100),
///         rfgrep_exe: std::env::current_exe().unwrap_or_else(|_| std::path::PathBuf::from("rfgrep")),
///         results_dir: std::path::PathBuf::from("results"),
///     };
///     let test_dir = Path::new("/path/to/test/files");
///     run_benchmarks(&config, test_dir)?;
///     Ok(())
/// }
/// ```
pub fn run_benchmarks(config: &AppConfig, test_dir: &Path) -> Result<()> {
    {
        ::std::io::_print(format_args!("Warming up rfgrep...\n"));
    };
    run_external_command(
        config.rfgrep_exe.to_str().unwrap(),
        &["search", "xyz123", test_dir.to_str().unwrap()],
        None,
    )?;
    {
        ::std::io::_print(format_args!("Running search performance benchmarks...\n"));
    };
    run_external_command(
        "hyperfine",
        &[
            "--warmup",
            "3",
            "--export-json",
            config.results_dir.join("search.json").to_str().unwrap(),
            "--export-markdown",
            config.results_dir.join("search.md").to_str().unwrap(),
            config.rfgrep_exe.to_str().unwrap(),
            "search",
            "pattern1",
            test_dir.to_str().unwrap(),
        ],
        None,
    )?;
    Ok(())
}
/// Run benchmarks from CLI arguments with automatic test data setup
///
/// Convenience function that creates test data directory if needed and
/// runs comprehensive benchmarks using the provided CLI configuration.
///
/// # Arguments
/// * `cli` - Parsed command-line interface arguments
///
/// # Returns
/// * `Result<()>` - Success or error during benchmark execution
///
/// # Example
/// ```no_run
/// use rfgrep::{Cli, run_benchmarks_cli};
/// use clap::Parser;
///
/// fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // In a real application, you would parse from command line
///     let cli = Cli::try_parse_from(&["rfgrep", ".", "search", "pattern"]).unwrap();
///     run_benchmarks_cli(&cli)?;
///     Ok(())
/// }
/// ```
pub fn run_benchmarks_cli(cli: &Cli) -> Result<()> {
    let config = AppConfig::from_cli(cli);
    let test_dir = cli.path.join("test_data");
    if !test_dir.exists() {
        std::fs::create_dir_all(&test_dir).map_err(crate::error::RfgrepError::Io)?;
    }
    run_benchmarks(&config, &test_dir)
}
